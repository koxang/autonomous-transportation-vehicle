ARM GAS  /tmp/cchLDBog.s 			page 1


   1              		.cpu cortex-m3
   2              		.arch armv7-m
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 1
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.file	"util.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.file 1 "Src/util.c"
  18              		.section	.text.BLDC_Init,"ax",%progbits
  19              		.align	1
  20              		.global	BLDC_Init
  21              		.syntax unified
  22              		.thumb
  23              		.thumb_func
  25              	BLDC_Init:
  26              	.LFB66:
   1:Src/util.c    **** /**
   2:Src/util.c    ****   * This file is part of the hoverboard-firmware-hack project.
   3:Src/util.c    ****   *
   4:Src/util.c    ****   * Copyright (C) 2020-2021 Emanuel FERU <aerdronix@gmail.com>
   5:Src/util.c    ****   *
   6:Src/util.c    ****   * This program is free software: you can redistribute it and/or modify
   7:Src/util.c    ****   * it under the terms of the GNU General Public License as published by
   8:Src/util.c    ****   * the Free Software Foundation, either version 3 of the License, or
   9:Src/util.c    ****   * (at your option) any later version.
  10:Src/util.c    ****   *
  11:Src/util.c    ****   * This program is distributed in the hope that it will be useful,
  12:Src/util.c    ****   * but WITHOUT ANY WARRANTY; without even the implied warranty of
  13:Src/util.c    ****   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  14:Src/util.c    ****   * GNU General Public License for more details.
  15:Src/util.c    ****   *
  16:Src/util.c    ****   * You should have received a copy of the GNU General Public License
  17:Src/util.c    ****   * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  18:Src/util.c    **** */
  19:Src/util.c    **** 
  20:Src/util.c    **** // Includes
  21:Src/util.c    **** #include <stdio.h>
  22:Src/util.c    **** #include <stdlib.h> // for abs()
  23:Src/util.c    **** #include <string.h>
  24:Src/util.c    **** #include "stm32f1xx_hal.h"
  25:Src/util.c    **** #include "defines.h"
  26:Src/util.c    **** #include "setup.h"
  27:Src/util.c    **** #include "config.h"
  28:Src/util.c    **** #include "eeprom.h"
  29:Src/util.c    **** #include "util.h"
  30:Src/util.c    **** #include "BLDC_controller.h"
  31:Src/util.c    **** #include "rtwtypes.h"
  32:Src/util.c    **** #include "comms.h"
ARM GAS  /tmp/cchLDBog.s 			page 2


  33:Src/util.c    **** 
  34:Src/util.c    **** #if defined(DEBUG_I2C_LCD) || defined(SUPPORT_LCD)
  35:Src/util.c    **** #include "hd44780.h"
  36:Src/util.c    **** #endif
  37:Src/util.c    **** 
  38:Src/util.c    **** /* =========================== Variable Definitions =========================== */
  39:Src/util.c    **** 
  40:Src/util.c    **** //------------------------------------------------------------------------
  41:Src/util.c    **** // Global variables set externally
  42:Src/util.c    **** //------------------------------------------------------------------------
  43:Src/util.c    **** extern volatile adc_buf_t adc_buffer;
  44:Src/util.c    **** extern I2C_HandleTypeDef hi2c2;
  45:Src/util.c    **** extern UART_HandleTypeDef huart2;
  46:Src/util.c    **** extern UART_HandleTypeDef huart3;
  47:Src/util.c    **** 
  48:Src/util.c    **** extern int16_t batVoltage;
  49:Src/util.c    **** extern uint8_t backwardDrive;
  50:Src/util.c    **** extern uint8_t buzzerCount;             // global variable for the buzzer counts. can be 1, 2, 3, 4
  51:Src/util.c    **** extern uint8_t buzzerFreq;              // global variable for the buzzer pitch. can be 1, 2, 3, 4,
  52:Src/util.c    **** extern uint8_t buzzerPattern;           // global variable for the buzzer pattern. can be 1, 2, 3, 
  53:Src/util.c    **** 
  54:Src/util.c    **** extern uint8_t enable;                  // global variable for motor enable
  55:Src/util.c    **** 
  56:Src/util.c    **** extern uint8_t nunchuk_data[6];
  57:Src/util.c    **** extern volatile uint32_t timeoutCntGen; // global counter for general timeout counter
  58:Src/util.c    **** extern volatile uint8_t  timeoutFlgGen; // global flag for general timeout counter
  59:Src/util.c    **** extern volatile uint32_t main_loop_counter;
  60:Src/util.c    **** 
  61:Src/util.c    **** #if defined(CONTROL_PPM_LEFT) || defined(CONTROL_PPM_RIGHT)
  62:Src/util.c    **** extern volatile uint16_t ppm_captured_value[PPM_NUM_CHANNELS+1];
  63:Src/util.c    **** #endif
  64:Src/util.c    **** 
  65:Src/util.c    **** #if defined(CONTROL_PWM_LEFT) || defined(CONTROL_PWM_RIGHT)
  66:Src/util.c    **** extern volatile uint16_t pwm_captured_ch1_value;
  67:Src/util.c    **** extern volatile uint16_t pwm_captured_ch2_value;
  68:Src/util.c    **** #endif
  69:Src/util.c    **** 
  70:Src/util.c    **** 
  71:Src/util.c    **** //------------------------------------------------------------------------
  72:Src/util.c    **** // Global variables set here in util.c
  73:Src/util.c    **** //------------------------------------------------------------------------
  74:Src/util.c    **** // Matlab defines - from auto-code generation
  75:Src/util.c    **** //---------------
  76:Src/util.c    **** RT_MODEL rtM_Left_;                     /* Real-time model */
  77:Src/util.c    **** RT_MODEL rtM_Right_;                    /* Real-time model */
  78:Src/util.c    **** RT_MODEL *const rtM_Left  = &rtM_Left_;
  79:Src/util.c    **** RT_MODEL *const rtM_Right = &rtM_Right_;
  80:Src/util.c    **** 
  81:Src/util.c    **** extern P rtP_Left;                      /* Block parameters (auto storage) */
  82:Src/util.c    **** DW       rtDW_Left;                     /* Observable states */
  83:Src/util.c    **** ExtU     rtU_Left;                      /* External inputs */
  84:Src/util.c    **** ExtY     rtY_Left;                      /* External outputs */
  85:Src/util.c    **** 
  86:Src/util.c    **** P        rtP_Right;                     /* Block parameters (auto storage) */
  87:Src/util.c    **** DW       rtDW_Right;                    /* Observable states */
  88:Src/util.c    **** ExtU     rtU_Right;                     /* External inputs */
  89:Src/util.c    **** ExtY     rtY_Right;                     /* External outputs */
ARM GAS  /tmp/cchLDBog.s 			page 3


  90:Src/util.c    **** //---------------
  91:Src/util.c    **** 
  92:Src/util.c    **** uint8_t  inIdx      = 0;
  93:Src/util.c    **** uint8_t  inIdx_prev = 0;
  94:Src/util.c    **** #if defined(PRI_INPUT1) && defined(PRI_INPUT2) && defined(AUX_INPUT1) && defined(AUX_INPUT2)
  95:Src/util.c    **** InputStruct input1[INPUTS_NR] = { {0, 0, 0, PRI_INPUT1}, {0, 0, 0, AUX_INPUT1} };
  96:Src/util.c    **** InputStruct input2[INPUTS_NR] = { {0, 0, 0, PRI_INPUT2}, {0, 0, 0, AUX_INPUT2} };
  97:Src/util.c    **** #else
  98:Src/util.c    **** InputStruct input1[INPUTS_NR] = { {0, 0, 0, PRI_INPUT1} };
  99:Src/util.c    **** InputStruct input2[INPUTS_NR] = { {0, 0, 0, PRI_INPUT2} };
 100:Src/util.c    **** #endif
 101:Src/util.c    **** 
 102:Src/util.c    **** int16_t  speedAvg;                      // average measured speed
 103:Src/util.c    **** int16_t  speedAvgAbs;                   // average measured speed in absolute
 104:Src/util.c    **** uint8_t  timeoutFlgADC    = 0;          // Timeout Flag for ADC Protection:    0 = OK, 1 = Problem 
 105:Src/util.c    **** uint8_t  timeoutFlgSerial = 0;          // Timeout Flag for Rx Serial command: 0 = OK, 1 = Problem 
 106:Src/util.c    **** 
 107:Src/util.c    **** uint8_t  ctrlModReqRaw = CTRL_MOD_REQ;
 108:Src/util.c    **** uint8_t  ctrlModReq    = CTRL_MOD_REQ;  // Final control mode request 
 109:Src/util.c    **** 
 110:Src/util.c    **** #if defined(DEBUG_I2C_LCD) || defined(SUPPORT_LCD)
 111:Src/util.c    **** LCD_PCF8574_HandleTypeDef lcd;
 112:Src/util.c    **** #endif
 113:Src/util.c    **** 
 114:Src/util.c    **** #ifdef VARIANT_TRANSPOTTER
 115:Src/util.c    **** float    setDistance;
 116:Src/util.c    **** uint16_t VirtAddVarTab[NB_OF_VAR] = {1337};       // Virtual address defined by the user: 0xFFFF va
 117:Src/util.c    **** static   uint16_t saveValue       = 0;
 118:Src/util.c    **** static   uint8_t  saveValue_valid = 0;
 119:Src/util.c    **** #elif !defined(VARIANT_HOVERBOARD) && !defined(VARIANT_TRANSPOTTER)
 120:Src/util.c    **** uint16_t VirtAddVarTab[NB_OF_VAR] = {1000, 1001, 1002, 1003, 1004, 1005, 1006, 1007, 1008, 1009,
 121:Src/util.c    ****                                      1010, 1011, 1012, 1013, 1014, 1015, 1016, 1017, 1018};
 122:Src/util.c    **** #else
 123:Src/util.c    **** uint16_t VirtAddVarTab[NB_OF_VAR] = {1000};       // Dummy virtual address to avoid warnings
 124:Src/util.c    **** #endif
 125:Src/util.c    **** 
 126:Src/util.c    **** 
 127:Src/util.c    **** //------------------------------------------------------------------------
 128:Src/util.c    **** // Local variables
 129:Src/util.c    **** //------------------------------------------------------------------------
 130:Src/util.c    **** static int16_t INPUT_MAX;             // [-] Input target maximum limitation
 131:Src/util.c    **** static int16_t INPUT_MIN;             // [-] Input target minimum limitation
 132:Src/util.c    **** 
 133:Src/util.c    **** 
 134:Src/util.c    **** #if !defined(VARIANT_HOVERBOARD) && !defined(VARIANT_TRANSPOTTER)
 135:Src/util.c    ****   static uint8_t  cur_spd_valid  = 0;
 136:Src/util.c    ****   static uint8_t  inp_cal_valid  = 0;
 137:Src/util.c    **** #endif
 138:Src/util.c    **** 
 139:Src/util.c    **** #if defined(CONTROL_ADC)
 140:Src/util.c    **** static uint16_t timeoutCntADC = ADC_PROTECT_TIMEOUT;  // Timeout counter for ADC Protection
 141:Src/util.c    **** #endif
 142:Src/util.c    **** 
 143:Src/util.c    **** #if defined(DEBUG_SERIAL_USART2) || defined(CONTROL_SERIAL_USART2) || defined(SIDEBOARD_SERIAL_USAR
 144:Src/util.c    **** static uint8_t  rx_buffer_L[SERIAL_BUFFER_SIZE];      // USART Rx DMA circular buffer
 145:Src/util.c    **** static uint32_t rx_buffer_L_len = ARRAY_LEN(rx_buffer_L);
 146:Src/util.c    **** #endif
ARM GAS  /tmp/cchLDBog.s 			page 4


 147:Src/util.c    **** #if defined(CONTROL_SERIAL_USART2) || defined(SIDEBOARD_SERIAL_USART2)
 148:Src/util.c    **** static uint16_t timeoutCntSerial_L = SERIAL_TIMEOUT;  // Timeout counter for Rx Serial command
 149:Src/util.c    **** static uint8_t  timeoutFlgSerial_L = 0;               // Timeout Flag for Rx Serial command: 0 = OK
 150:Src/util.c    **** #endif
 151:Src/util.c    **** #if defined(SIDEBOARD_SERIAL_USART2)
 152:Src/util.c    **** SerialSideboard Sideboard_L;
 153:Src/util.c    **** SerialSideboard Sideboard_L_raw;
 154:Src/util.c    **** static uint32_t Sideboard_L_len = sizeof(Sideboard_L);
 155:Src/util.c    **** #endif
 156:Src/util.c    **** 
 157:Src/util.c    **** #if defined(DEBUG_SERIAL_USART3) || defined(CONTROL_SERIAL_USART3) || defined(SIDEBOARD_SERIAL_USAR
 158:Src/util.c    **** static uint8_t  rx_buffer_R[SERIAL_BUFFER_SIZE];      // USART Rx DMA circular buffer
 159:Src/util.c    **** static uint32_t rx_buffer_R_len = ARRAY_LEN(rx_buffer_R);
 160:Src/util.c    **** #endif
 161:Src/util.c    **** #if defined(CONTROL_SERIAL_USART3) || defined(SIDEBOARD_SERIAL_USART3)
 162:Src/util.c    **** static uint16_t timeoutCntSerial_R = SERIAL_TIMEOUT;  // Timeout counter for Rx Serial command
 163:Src/util.c    **** static uint8_t  timeoutFlgSerial_R = 0;               // Timeout Flag for Rx Serial command: 0 = OK
 164:Src/util.c    **** #endif
 165:Src/util.c    **** #if defined(SIDEBOARD_SERIAL_USART3)
 166:Src/util.c    **** SerialSideboard Sideboard_R;
 167:Src/util.c    **** SerialSideboard Sideboard_R_raw;
 168:Src/util.c    **** static uint32_t Sideboard_R_len = sizeof(Sideboard_R);
 169:Src/util.c    **** #endif
 170:Src/util.c    **** 
 171:Src/util.c    **** #if defined(CONTROL_SERIAL_USART2)
 172:Src/util.c    **** static SerialCommand commandL;
 173:Src/util.c    **** static SerialCommand commandL_raw;
 174:Src/util.c    **** static uint32_t commandL_len = sizeof(commandL);
 175:Src/util.c    ****   #ifdef CONTROL_IBUS
 176:Src/util.c    ****   static uint16_t ibusL_captured_value[IBUS_NUM_CHANNELS];
 177:Src/util.c    ****   #endif
 178:Src/util.c    **** #endif
 179:Src/util.c    **** 
 180:Src/util.c    **** #if defined(CONTROL_SERIAL_USART3)
 181:Src/util.c    **** static SerialCommand commandR;
 182:Src/util.c    **** static SerialCommand commandR_raw;
 183:Src/util.c    **** static uint32_t commandR_len = sizeof(commandR);
 184:Src/util.c    ****   #ifdef CONTROL_IBUS
 185:Src/util.c    ****   static uint16_t ibusR_captured_value[IBUS_NUM_CHANNELS];
 186:Src/util.c    ****   #endif
 187:Src/util.c    **** #endif
 188:Src/util.c    **** 
 189:Src/util.c    **** #if defined(SUPPORT_BUTTONS) || defined(SUPPORT_BUTTONS_LEFT) || defined(SUPPORT_BUTTONS_RIGHT)
 190:Src/util.c    **** static uint8_t button1;                 // Blue
 191:Src/util.c    **** static uint8_t button2;                 // Green
 192:Src/util.c    **** #endif
 193:Src/util.c    **** 
 194:Src/util.c    **** #ifdef VARIANT_HOVERCAR
 195:Src/util.c    **** static uint8_t brakePressed;
 196:Src/util.c    **** #endif
 197:Src/util.c    **** 
 198:Src/util.c    **** #if defined(CRUISE_CONTROL_SUPPORT) || (defined(STANDSTILL_HOLD_ENABLE) && (CTRL_TYP_SEL == FOC_CTR
 199:Src/util.c    **** static uint8_t cruiseCtrlAcv = 0;
 200:Src/util.c    **** static uint8_t standstillAcv = 0;
 201:Src/util.c    **** #endif
 202:Src/util.c    **** 
 203:Src/util.c    **** /* =========================== Retargeting printf =========================== */
ARM GAS  /tmp/cchLDBog.s 			page 5


 204:Src/util.c    **** /* retarget the C library printf function to the USART */
 205:Src/util.c    **** #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 206:Src/util.c    ****   #ifdef __GNUC__
 207:Src/util.c    ****     #define PUTCHAR_PROTOTYPE int __io_putchar(int ch)
 208:Src/util.c    ****   #else
 209:Src/util.c    ****     #define PUTCHAR_PROTOTYPE int fputc(int ch, FILE *f)
 210:Src/util.c    ****   #endif
 211:Src/util.c    ****   PUTCHAR_PROTOTYPE {
 212:Src/util.c    ****     #if defined(DEBUG_SERIAL_USART2)
 213:Src/util.c    ****       HAL_UART_Transmit(&huart2, (uint8_t *)&ch, 1, 1000);
 214:Src/util.c    ****     #elif defined(DEBUG_SERIAL_USART3)
 215:Src/util.c    ****       HAL_UART_Transmit(&huart3, (uint8_t *)&ch, 1, 1000);
 216:Src/util.c    ****     #endif
 217:Src/util.c    ****     return ch;
 218:Src/util.c    ****   }
 219:Src/util.c    ****   
 220:Src/util.c    ****   #ifdef __GNUC__
 221:Src/util.c    ****     int _write(int file, char *data, int len) {
 222:Src/util.c    ****       int i;
 223:Src/util.c    ****       for (i = 0; i < len; i++) { __io_putchar( *data++ );}
 224:Src/util.c    ****       return len;
 225:Src/util.c    ****     }
 226:Src/util.c    ****   #endif
 227:Src/util.c    **** #endif
 228:Src/util.c    **** 
 229:Src/util.c    ****  
 230:Src/util.c    **** /* =========================== Initialization Functions =========================== */
 231:Src/util.c    **** 
 232:Src/util.c    **** void BLDC_Init(void) {
  27              		.loc 1 232 22 view -0
  28              		.cfi_startproc
  29              		@ args = 0, pretend = 0, frame = 0
  30              		@ frame_needed = 0, uses_anonymous_args = 0
  31 0000 70B5     		push	{r4, r5, r6, lr}
  32              	.LCFI0:
  33              		.cfi_def_cfa_offset 16
  34              		.cfi_offset 4, -16
  35              		.cfi_offset 5, -12
  36              		.cfi_offset 6, -8
  37              		.cfi_offset 14, -4
 233:Src/util.c    ****   /* Set BLDC controller parameters */ 
 234:Src/util.c    ****   rtP_Left.b_angleMeasEna       = 0;            // Motor angle input: 0 = estimated angle, 1 = meas
  38              		.loc 1 234 3 view .LVU1
  39              		.loc 1 234 33 is_stmt 0 view .LVU2
  40 0002 204C     		ldr	r4, .L3
  41 0004 0023     		movs	r3, #0
  42 0006 84F8FB30 		strb	r3, [r4, #251]
 235:Src/util.c    ****   rtP_Left.z_selPhaCurMeasABC   = 0;            // Left motor measured current phases {Green, Blue}
  43              		.loc 1 235 3 is_stmt 1 view .LVU3
  44              		.loc 1 235 33 is_stmt 0 view .LVU4
  45 000a 84F8FA30 		strb	r3, [r4, #250]
 236:Src/util.c    ****   rtP_Left.z_ctrlTypSel         = CTRL_TYP_SEL;
  46              		.loc 1 236 3 is_stmt 1 view .LVU5
  47              		.loc 1 236 33 is_stmt 0 view .LVU6
  48 000e 0222     		movs	r2, #2
  49 0010 84F8F920 		strb	r2, [r4, #249]
 237:Src/util.c    ****   rtP_Left.b_diagEna            = DIAG_ENA;
ARM GAS  /tmp/cchLDBog.s 			page 6


  50              		.loc 1 237 3 is_stmt 1 view .LVU7
  51              		.loc 1 237 33 is_stmt 0 view .LVU8
  52 0014 0126     		movs	r6, #1
  53 0016 84F8FD60 		strb	r6, [r4, #253]
 238:Src/util.c    ****   rtP_Left.i_max                = (I_MOT_MAX * A2BIT_CONV) << 4;        // fixdt(1,16,4)
  54              		.loc 1 238 3 is_stmt 1 view .LVU9
  55              		.loc 1 238 33 is_stmt 0 view .LVU10
  56 001a 42F6E062 		movw	r2, #12000
  57 001e A4F8CE20 		strh	r2, [r4, #206]	@ movhi
 239:Src/util.c    ****   rtP_Left.n_max                = N_MOT_MAX << 4;                       // fixdt(1,16,4)
  58              		.loc 1 239 3 is_stmt 1 view .LVU11
  59              		.loc 1 239 33 is_stmt 0 view .LVU12
  60 0022 4FF47A51 		mov	r1, #16000
  61 0026 A4F8DA10 		strh	r1, [r4, #218]	@ movhi
 240:Src/util.c    ****   rtP_Left.b_fieldWeakEna       = FIELD_WEAK_ENA; 
  62              		.loc 1 240 3 is_stmt 1 view .LVU13
  63              		.loc 1 240 33 is_stmt 0 view .LVU14
  64 002a 84F8FE30 		strb	r3, [r4, #254]
 241:Src/util.c    ****   rtP_Left.id_fieldWeakMax      = (FIELD_WEAK_MAX * A2BIT_CONV) << 4;   // fixdt(1,16,4)
  65              		.loc 1 241 3 is_stmt 1 view .LVU15
  66              		.loc 1 241 33 is_stmt 0 view .LVU16
  67 002e 4FF47A63 		mov	r3, #4000
  68 0032 A4F8D030 		strh	r3, [r4, #208]	@ movhi
 242:Src/util.c    ****   rtP_Left.a_phaAdvMax          = PHASE_ADV_MAX << 4;                   // fixdt(1,16,4)
  69              		.loc 1 242 3 is_stmt 1 view .LVU17
  70              		.loc 1 242 33 is_stmt 0 view .LVU18
  71 0036 4FF4C873 		mov	r3, #400
  72 003a A4F8CC30 		strh	r3, [r4, #204]	@ movhi
 243:Src/util.c    ****   rtP_Left.r_fieldWeakHi        = FIELD_WEAK_HI << 4;                   // fixdt(1,16,4)
  73              		.loc 1 243 3 is_stmt 1 view .LVU19
  74              		.loc 1 243 33 is_stmt 0 view .LVU20
  75 003e A4F8E010 		strh	r1, [r4, #224]	@ movhi
 244:Src/util.c    ****   rtP_Left.r_fieldWeakLo        = FIELD_WEAK_LO << 4;                   // fixdt(1,16,4)
  76              		.loc 1 244 3 is_stmt 1 view .LVU21
  77              		.loc 1 244 33 is_stmt 0 view .LVU22
  78 0042 A4F8E220 		strh	r2, [r4, #226]	@ movhi
 245:Src/util.c    **** 
 246:Src/util.c    ****   rtP_Right                     = rtP_Left;     // Copy the Left motor parameters to the Right moto
  79              		.loc 1 246 3 is_stmt 1 view .LVU23
  80              		.loc 1 246 33 is_stmt 0 view .LVU24
  81 0046 104D     		ldr	r5, .L3+4
  82 0048 4FF48072 		mov	r2, #256
  83 004c 2146     		mov	r1, r4
  84 004e 2846     		mov	r0, r5
  85 0050 FFF7FEFF 		bl	memcpy
  86              	.LVL0:
 247:Src/util.c    ****   rtP_Right.z_selPhaCurMeasABC  = 1;            // Right motor measured current phases {Blue, Yello
  87              		.loc 1 247 3 is_stmt 1 view .LVU25
  88              		.loc 1 247 33 is_stmt 0 view .LVU26
  89 0054 85F8FA60 		strb	r6, [r5, #250]
 248:Src/util.c    **** 
 249:Src/util.c    ****   /* Pack LEFT motor data into RTM */
 250:Src/util.c    ****   rtM_Left->defaultParam        = &rtP_Left;
  90              		.loc 1 250 3 is_stmt 1 view .LVU27
  91              		.loc 1 250 33 is_stmt 0 view .LVU28
  92 0058 0C48     		ldr	r0, .L3+8
  93 005a 0460     		str	r4, [r0]
ARM GAS  /tmp/cchLDBog.s 			page 7


 251:Src/util.c    ****   rtM_Left->dwork               = &rtDW_Left;
  94              		.loc 1 251 3 is_stmt 1 view .LVU29
  95              		.loc 1 251 33 is_stmt 0 view .LVU30
  96 005c 0C4B     		ldr	r3, .L3+12
  97 005e C360     		str	r3, [r0, #12]
 252:Src/util.c    ****   rtM_Left->inputs              = &rtU_Left;
  98              		.loc 1 252 3 is_stmt 1 view .LVU31
  99              		.loc 1 252 33 is_stmt 0 view .LVU32
 100 0060 0C4B     		ldr	r3, .L3+16
 101 0062 4360     		str	r3, [r0, #4]
 253:Src/util.c    ****   rtM_Left->outputs             = &rtY_Left;
 102              		.loc 1 253 3 is_stmt 1 view .LVU33
 103              		.loc 1 253 33 is_stmt 0 view .LVU34
 104 0064 0C4B     		ldr	r3, .L3+20
 105 0066 8360     		str	r3, [r0, #8]
 254:Src/util.c    **** 
 255:Src/util.c    ****   /* Pack RIGHT motor data into RTM */
 256:Src/util.c    ****   rtM_Right->defaultParam       = &rtP_Right;
 106              		.loc 1 256 3 is_stmt 1 view .LVU35
 107              		.loc 1 256 33 is_stmt 0 view .LVU36
 108 0068 0C4C     		ldr	r4, .L3+24
 109 006a 2560     		str	r5, [r4]
 257:Src/util.c    ****   rtM_Right->dwork              = &rtDW_Right;
 110              		.loc 1 257 3 is_stmt 1 view .LVU37
 111              		.loc 1 257 33 is_stmt 0 view .LVU38
 112 006c 0C4B     		ldr	r3, .L3+28
 113 006e E360     		str	r3, [r4, #12]
 258:Src/util.c    ****   rtM_Right->inputs             = &rtU_Right;
 114              		.loc 1 258 3 is_stmt 1 view .LVU39
 115              		.loc 1 258 33 is_stmt 0 view .LVU40
 116 0070 0C4B     		ldr	r3, .L3+32
 117 0072 6360     		str	r3, [r4, #4]
 259:Src/util.c    ****   rtM_Right->outputs            = &rtY_Right;
 118              		.loc 1 259 3 is_stmt 1 view .LVU41
 119              		.loc 1 259 33 is_stmt 0 view .LVU42
 120 0074 0C4B     		ldr	r3, .L3+36
 121 0076 A360     		str	r3, [r4, #8]
 260:Src/util.c    **** 
 261:Src/util.c    ****   /* Initialize BLDC controllers */
 262:Src/util.c    ****   BLDC_controller_initialize(rtM_Left);
 122              		.loc 1 262 3 is_stmt 1 view .LVU43
 123 0078 FFF7FEFF 		bl	BLDC_controller_initialize
 124              	.LVL1:
 263:Src/util.c    ****   BLDC_controller_initialize(rtM_Right);
 125              		.loc 1 263 3 view .LVU44
 126 007c 2046     		mov	r0, r4
 127 007e FFF7FEFF 		bl	BLDC_controller_initialize
 128              	.LVL2:
 264:Src/util.c    **** }
 129              		.loc 1 264 1 is_stmt 0 view .LVU45
 130 0082 70BD     		pop	{r4, r5, r6, pc}
 131              	.L4:
 132              		.align	2
 133              	.L3:
 134 0084 00000000 		.word	rtP_Left
 135 0088 00000000 		.word	rtP_Right
 136 008c 00000000 		.word	rtM_Left_
ARM GAS  /tmp/cchLDBog.s 			page 8


 137 0090 00000000 		.word	rtDW_Left
 138 0094 00000000 		.word	rtU_Left
 139 0098 00000000 		.word	rtY_Left
 140 009c 00000000 		.word	rtM_Right_
 141 00a0 00000000 		.word	rtDW_Right
 142 00a4 00000000 		.word	rtU_Right
 143 00a8 00000000 		.word	rtY_Right
 144              		.cfi_endproc
 145              	.LFE66:
 147              		.section	.text.Input_Lim_Init,"ax",%progbits
 148              		.align	1
 149              		.global	Input_Lim_Init
 150              		.syntax unified
 151              		.thumb
 152              		.thumb_func
 154              	Input_Lim_Init:
 155              	.LFB67:
 265:Src/util.c    **** 
 266:Src/util.c    **** void Input_Lim_Init(void) {     // Input Limitations - ! Do NOT touch !
 156              		.loc 1 266 27 is_stmt 1 view -0
 157              		.cfi_startproc
 158              		@ args = 0, pretend = 0, frame = 0
 159              		@ frame_needed = 0, uses_anonymous_args = 0
 160              		@ link register save eliminated.
 267:Src/util.c    ****   if (rtP_Left.b_fieldWeakEna || rtP_Right.b_fieldWeakEna) {
 161              		.loc 1 267 3 view .LVU47
 162              		.loc 1 267 15 is_stmt 0 view .LVU48
 163 0000 0C4B     		ldr	r3, .L9
 164 0002 93F8FE30 		ldrb	r3, [r3, #254]	@ zero_extendqisi2
 165              		.loc 1 267 6 view .LVU49
 166 0006 1BB9     		cbnz	r3, .L6
 167              		.loc 1 267 43 discriminator 1 view .LVU50
 168 0008 0B4B     		ldr	r3, .L9+4
 169 000a 93F8FE30 		ldrb	r3, [r3, #254]	@ zero_extendqisi2
 170              		.loc 1 267 31 discriminator 1 view .LVU51
 171 000e 43B1     		cbz	r3, .L7
 172              	.L6:
 268:Src/util.c    ****     INPUT_MAX = MAX( 1000, FIELD_WEAK_HI);
 173              		.loc 1 268 5 is_stmt 1 view .LVU52
 174              		.loc 1 268 15 is_stmt 0 view .LVU53
 175 0010 0A4B     		ldr	r3, .L9+8
 176 0012 4FF47A72 		mov	r2, #1000
 177 0016 1A80     		strh	r2, [r3]	@ movhi
 269:Src/util.c    ****     INPUT_MIN = MIN(-1000,-FIELD_WEAK_HI);
 178              		.loc 1 269 5 is_stmt 1 view .LVU54
 179              		.loc 1 269 15 is_stmt 0 view .LVU55
 180 0018 094B     		ldr	r3, .L9+12
 181 001a 4FF61842 		movw	r2, #64536
 182 001e 1A80     		strh	r2, [r3]	@ movhi
 183 0020 7047     		bx	lr
 184              	.L7:
 270:Src/util.c    ****   } else {
 271:Src/util.c    ****     INPUT_MAX =  1000;
 185              		.loc 1 271 5 is_stmt 1 view .LVU56
 186              		.loc 1 271 15 is_stmt 0 view .LVU57
 187 0022 064B     		ldr	r3, .L9+8
 188 0024 4FF47A72 		mov	r2, #1000
ARM GAS  /tmp/cchLDBog.s 			page 9


 189 0028 1A80     		strh	r2, [r3]	@ movhi
 272:Src/util.c    ****     INPUT_MIN = -1000;
 190              		.loc 1 272 5 is_stmt 1 view .LVU58
 191              		.loc 1 272 15 is_stmt 0 view .LVU59
 192 002a 054B     		ldr	r3, .L9+12
 193 002c 4FF61842 		movw	r2, #64536
 194 0030 1A80     		strh	r2, [r3]	@ movhi
 273:Src/util.c    ****   }
 274:Src/util.c    **** }
 195              		.loc 1 274 1 view .LVU60
 196 0032 7047     		bx	lr
 197              	.L10:
 198              		.align	2
 199              	.L9:
 200 0034 00000000 		.word	rtP_Left
 201 0038 00000000 		.word	rtP_Right
 202 003c 00000000 		.word	INPUT_MAX
 203 0040 00000000 		.word	INPUT_MIN
 204              		.cfi_endproc
 205              	.LFE67:
 207              		.section	.text.UART_DisableRxErrors,"ax",%progbits
 208              		.align	1
 209              		.global	UART_DisableRxErrors
 210              		.syntax unified
 211              		.thumb
 212              		.thumb_func
 214              	UART_DisableRxErrors:
 215              	.LVL3:
 216              	.LFB69:
 275:Src/util.c    **** 
 276:Src/util.c    **** void Input_Init(void) {
 277:Src/util.c    ****   #if defined(CONTROL_PPM_LEFT) || defined(CONTROL_PPM_RIGHT)
 278:Src/util.c    ****     PPM_Init();
 279:Src/util.c    ****   #endif
 280:Src/util.c    **** 
 281:Src/util.c    ****  #if defined(CONTROL_PWM_LEFT) || defined(CONTROL_PWM_RIGHT)
 282:Src/util.c    ****     PWM_Init();
 283:Src/util.c    ****   #endif
 284:Src/util.c    **** 
 285:Src/util.c    ****   #if defined(DEBUG_SERIAL_USART2) || defined(CONTROL_SERIAL_USART2) || defined(FEEDBACK_SERIAL_USA
 286:Src/util.c    ****     UART2_Init();
 287:Src/util.c    ****   #endif
 288:Src/util.c    ****   #if defined(DEBUG_SERIAL_USART3) || defined(CONTROL_SERIAL_USART3) || defined(FEEDBACK_SERIAL_USA
 289:Src/util.c    ****     UART3_Init();
 290:Src/util.c    ****   #endif
 291:Src/util.c    ****   #if defined(DEBUG_SERIAL_USART2) || defined(CONTROL_SERIAL_USART2) || defined(SIDEBOARD_SERIAL_US
 292:Src/util.c    ****     HAL_UART_Receive_DMA(&huart2, (uint8_t *)rx_buffer_L, sizeof(rx_buffer_L));
 293:Src/util.c    ****     UART_DisableRxErrors(&huart2);
 294:Src/util.c    ****   #endif
 295:Src/util.c    ****   #if defined(DEBUG_SERIAL_USART3) || defined(CONTROL_SERIAL_USART3) || defined(SIDEBOARD_SERIAL_US
 296:Src/util.c    ****     HAL_UART_Receive_DMA(&huart3, (uint8_t *)rx_buffer_R, sizeof(rx_buffer_R));
 297:Src/util.c    ****     UART_DisableRxErrors(&huart3);
 298:Src/util.c    ****   #endif
 299:Src/util.c    **** 
 300:Src/util.c    ****   #if !defined(VARIANT_HOVERBOARD) && !defined(VARIANT_TRANSPOTTER)
 301:Src/util.c    ****     uint16_t writeCheck, readVal;
 302:Src/util.c    ****     HAL_FLASH_Unlock();
ARM GAS  /tmp/cchLDBog.s 			page 10


 303:Src/util.c    ****     EE_Init();            /* EEPROM Init */
 304:Src/util.c    ****     EE_ReadVariable(VirtAddVarTab[0], &writeCheck);
 305:Src/util.c    ****     if (writeCheck == FLASH_WRITE_KEY) {
 306:Src/util.c    ****       #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 307:Src/util.c    ****         printf("Using the configuration from EEprom\r\n");
 308:Src/util.c    ****       #endif
 309:Src/util.c    **** 
 310:Src/util.c    ****       EE_ReadVariable(VirtAddVarTab[1] , &readVal); rtP_Left.i_max = rtP_Right.i_max = (int16_t)rea
 311:Src/util.c    ****       EE_ReadVariable(VirtAddVarTab[2] , &readVal); rtP_Left.n_max = rtP_Right.n_max = (int16_t)rea
 312:Src/util.c    ****       for (uint8_t i=0; i<INPUTS_NR; i++) {
 313:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 3+8*i] , &readVal); input1[i].typ = (uint8_t)readVal;
 314:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 4+8*i] , &readVal); input1[i].min = (int16_t)readVal;
 315:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 5+8*i] , &readVal); input1[i].mid = (int16_t)readVal;
 316:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 6+8*i] , &readVal); input1[i].max = (int16_t)readVal;
 317:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 7+8*i] , &readVal); input2[i].typ = (uint8_t)readVal;
 318:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 8+8*i] , &readVal); input2[i].min = (int16_t)readVal;
 319:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 9+8*i] , &readVal); input2[i].mid = (int16_t)readVal;
 320:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[10+8*i] , &readVal); input2[i].max = (int16_t)readVal;
 321:Src/util.c    ****       
 322:Src/util.c    ****         printf("Limits Input1: TYP:%i MIN:%i MID:%i MAX:%i\r\nLimits Input2: TYP:%i MIN:%i MID:%i M
 323:Src/util.c    ****           input1[i].typ, input1[i].min, input1[i].mid, input1[i].max,
 324:Src/util.c    ****           input2[i].typ, input2[i].min, input2[i].mid, input2[i].max);
 325:Src/util.c    ****       }
 326:Src/util.c    ****     } else {
 327:Src/util.c    ****       #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 328:Src/util.c    ****         printf("Using the configuration from config.h\r\n");
 329:Src/util.c    ****       #endif
 330:Src/util.c    **** 
 331:Src/util.c    ****       for (uint8_t i=0; i<INPUTS_NR; i++) {
 332:Src/util.c    ****         if (input1[i].typDef == 3) {  // If Input type defined is 3 (auto), identify the input type
 333:Src/util.c    ****           input1[i].typ = checkInputType(input1[i].min, input1[i].mid, input1[i].max);
 334:Src/util.c    ****         } else {
 335:Src/util.c    ****           input1[i].typ = input1[i].typDef;
 336:Src/util.c    ****         }
 337:Src/util.c    ****         if (input2[i].typDef == 3) {
 338:Src/util.c    ****           input2[i].typ = checkInputType(input2[i].min, input2[i].mid, input2[i].max);
 339:Src/util.c    ****         } else {
 340:Src/util.c    ****           input2[i].typ = input2[i].typDef;
 341:Src/util.c    ****         }
 342:Src/util.c    ****         printf("Limits Input1: TYP:%i MIN:%i MID:%i MAX:%i\r\nLimits Input2: TYP:%i MIN:%i MID:%i M
 343:Src/util.c    ****           input1[i].typ, input1[i].min, input1[i].mid, input1[i].max,
 344:Src/util.c    ****           input2[i].typ, input2[i].min, input2[i].mid, input2[i].max);
 345:Src/util.c    ****       }
 346:Src/util.c    ****     }
 347:Src/util.c    ****     HAL_FLASH_Lock();
 348:Src/util.c    ****   #endif
 349:Src/util.c    **** 
 350:Src/util.c    ****   #ifdef VARIANT_TRANSPOTTER
 351:Src/util.c    ****     enable = 1;
 352:Src/util.c    **** 
 353:Src/util.c    ****     HAL_FLASH_Unlock();
 354:Src/util.c    ****     EE_Init();            /* EEPROM Init */
 355:Src/util.c    ****     EE_ReadVariable(VirtAddVarTab[0], &saveValue);
 356:Src/util.c    ****     HAL_FLASH_Lock();
 357:Src/util.c    **** 
 358:Src/util.c    ****     setDistance = saveValue / 1000.0;
 359:Src/util.c    ****     if (setDistance < 0.2) {
ARM GAS  /tmp/cchLDBog.s 			page 11


 360:Src/util.c    ****       setDistance = 1.0;
 361:Src/util.c    ****     }
 362:Src/util.c    ****   #endif
 363:Src/util.c    **** 
 364:Src/util.c    ****   #if defined(DEBUG_I2C_LCD) || defined(SUPPORT_LCD)
 365:Src/util.c    ****     I2C_Init();
 366:Src/util.c    ****     HAL_Delay(50);
 367:Src/util.c    ****     lcd.pcf8574.PCF_I2C_ADDRESS = 0x27;
 368:Src/util.c    ****     lcd.pcf8574.PCF_I2C_TIMEOUT = 5;
 369:Src/util.c    ****     lcd.pcf8574.i2c             = hi2c2;
 370:Src/util.c    ****     lcd.NUMBER_OF_LINES         = NUMBER_OF_LINES_2;
 371:Src/util.c    ****     lcd.type                    = TYPE0;
 372:Src/util.c    **** 
 373:Src/util.c    ****     if(LCD_Init(&lcd)!=LCD_OK) {
 374:Src/util.c    ****         // error occured
 375:Src/util.c    ****         //TODO while(1);
 376:Src/util.c    ****     }
 377:Src/util.c    **** 
 378:Src/util.c    ****     LCD_ClearDisplay(&lcd);
 379:Src/util.c    ****     HAL_Delay(5);
 380:Src/util.c    ****     LCD_SetLocation(&lcd, 0, 0);
 381:Src/util.c    ****     #ifdef VARIANT_TRANSPOTTER
 382:Src/util.c    ****       LCD_WriteString(&lcd, "TranspOtter V2.1");
 383:Src/util.c    ****     #else
 384:Src/util.c    ****       LCD_WriteString(&lcd, "Hover V2.0");
 385:Src/util.c    ****     #endif
 386:Src/util.c    ****     LCD_SetLocation(&lcd,  0, 1); LCD_WriteString(&lcd, "Initializing...");
 387:Src/util.c    ****   #endif
 388:Src/util.c    **** 
 389:Src/util.c    ****   #if defined(VARIANT_TRANSPOTTER) && defined(SUPPORT_LCD)
 390:Src/util.c    ****     LCD_ClearDisplay(&lcd);
 391:Src/util.c    ****     HAL_Delay(5);
 392:Src/util.c    ****     LCD_SetLocation(&lcd,  0, 1); LCD_WriteString(&lcd, "Bat:");
 393:Src/util.c    ****     LCD_SetLocation(&lcd,  8, 1); LCD_WriteString(&lcd, "V");
 394:Src/util.c    ****     LCD_SetLocation(&lcd, 15, 1); LCD_WriteString(&lcd, "A");
 395:Src/util.c    ****     LCD_SetLocation(&lcd,  0, 0); LCD_WriteString(&lcd, "Len:");
 396:Src/util.c    ****     LCD_SetLocation(&lcd,  8, 0); LCD_WriteString(&lcd, "m(");
 397:Src/util.c    ****     LCD_SetLocation(&lcd, 14, 0); LCD_WriteString(&lcd, "m)");
 398:Src/util.c    ****   #endif
 399:Src/util.c    **** }
 400:Src/util.c    **** 
 401:Src/util.c    **** /**
 402:Src/util.c    ****   * @brief  Disable Rx Errors detection interrupts on UART peripheral (since we do not want DMA to 
 403:Src/util.c    ****   *         The incorrect data will be filtered based on the START_FRAME and checksum.
 404:Src/util.c    ****   * @param  huart: UART handle.
 405:Src/util.c    ****   * @retval None
 406:Src/util.c    ****   */
 407:Src/util.c    **** #if defined(DEBUG_SERIAL_USART2) || defined(CONTROL_SERIAL_USART2) || defined(SIDEBOARD_SERIAL_USAR
 408:Src/util.c    ****     defined(DEBUG_SERIAL_USART3) || defined(CONTROL_SERIAL_USART3) || defined(SIDEBOARD_SERIAL_USAR
 409:Src/util.c    **** void UART_DisableRxErrors(UART_HandleTypeDef *huart)
 410:Src/util.c    **** {  
 217              		.loc 1 410 1 is_stmt 1 view -0
 218              		.cfi_startproc
 219              		@ args = 0, pretend = 0, frame = 0
 220              		@ frame_needed = 0, uses_anonymous_args = 0
 221              		@ link register save eliminated.
 411:Src/util.c    ****   CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);    /* Disable PE (Parity Error) interrupts */  
ARM GAS  /tmp/cchLDBog.s 			page 12


 222              		.loc 1 411 3 view .LVU62
 223 0000 0268     		ldr	r2, [r0]
 224 0002 D368     		ldr	r3, [r2, #12]
 225 0004 23F48073 		bic	r3, r3, #256
 226 0008 D360     		str	r3, [r2, #12]
 412:Src/util.c    ****   CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);     /* Disable EIE (Frame error, noise error, ove
 227              		.loc 1 412 3 view .LVU63
 228 000a 0268     		ldr	r2, [r0]
 229 000c 5369     		ldr	r3, [r2, #20]
 230 000e 23F00103 		bic	r3, r3, #1
 231 0012 5361     		str	r3, [r2, #20]
 413:Src/util.c    **** }
 232              		.loc 1 413 1 is_stmt 0 view .LVU64
 233 0014 7047     		bx	lr
 234              		.cfi_endproc
 235              	.LFE69:
 237              		.section	.text.poweronMelody,"ax",%progbits
 238              		.align	1
 239              		.global	poweronMelody
 240              		.syntax unified
 241              		.thumb
 242              		.thumb_func
 244              	poweronMelody:
 245              	.LFB70:
 414:Src/util.c    **** #endif
 415:Src/util.c    **** 
 416:Src/util.c    **** 
 417:Src/util.c    **** /* =========================== General Functions =========================== */
 418:Src/util.c    **** 
 419:Src/util.c    **** void poweronMelody(void) {
 246              		.loc 1 419 26 is_stmt 1 view -0
 247              		.cfi_startproc
 248              		@ args = 0, pretend = 0, frame = 0
 249              		@ frame_needed = 0, uses_anonymous_args = 0
 250 0000 10B5     		push	{r4, lr}
 251              	.LCFI1:
 252              		.cfi_def_cfa_offset 8
 253              		.cfi_offset 4, -8
 254              		.cfi_offset 14, -4
 420:Src/util.c    ****     buzzerCount = 0;  // prevent interraction with beep counter
 255              		.loc 1 420 5 view .LVU66
 256              		.loc 1 420 17 is_stmt 0 view .LVU67
 257 0002 084B     		ldr	r3, .L16
 258 0004 0022     		movs	r2, #0
 259 0006 1A70     		strb	r2, [r3]
 421:Src/util.c    ****     for (int i = 8; i >= 0; i--) {
 260              		.loc 1 421 5 is_stmt 1 view .LVU68
 261              	.LBB2:
 262              		.loc 1 421 10 view .LVU69
 263              	.LVL4:
 264              		.loc 1 421 14 is_stmt 0 view .LVU70
 265 0008 0824     		movs	r4, #8
 266              		.loc 1 421 5 view .LVU71
 267 000a 05E0     		b	.L13
 268              	.LVL5:
 269              	.L14:
 422:Src/util.c    ****       buzzerFreq = (uint8_t)i;
ARM GAS  /tmp/cchLDBog.s 			page 13


 270              		.loc 1 422 7 is_stmt 1 view .LVU72
 271              		.loc 1 422 18 is_stmt 0 view .LVU73
 272 000c 064B     		ldr	r3, .L16+4
 273 000e 1C70     		strb	r4, [r3]
 423:Src/util.c    ****       HAL_Delay(100);
 274              		.loc 1 423 7 is_stmt 1 view .LVU74
 275 0010 6420     		movs	r0, #100
 276 0012 FFF7FEFF 		bl	HAL_Delay
 277              	.LVL6:
 421:Src/util.c    ****     for (int i = 8; i >= 0; i--) {
 278              		.loc 1 421 30 discriminator 3 view .LVU75
 279 0016 013C     		subs	r4, r4, #1
 280              	.LVL7:
 281              	.L13:
 421:Src/util.c    ****     for (int i = 8; i >= 0; i--) {
 282              		.loc 1 421 23 discriminator 1 view .LVU76
 283 0018 002C     		cmp	r4, #0
 284 001a F7DA     		bge	.L14
 285              	.LBE2:
 424:Src/util.c    ****     }
 425:Src/util.c    ****     buzzerFreq = 0;
 286              		.loc 1 425 5 view .LVU77
 287              		.loc 1 425 16 is_stmt 0 view .LVU78
 288 001c 024B     		ldr	r3, .L16+4
 289 001e 0022     		movs	r2, #0
 290 0020 1A70     		strb	r2, [r3]
 426:Src/util.c    **** }
 291              		.loc 1 426 1 view .LVU79
 292 0022 10BD     		pop	{r4, pc}
 293              	.LVL8:
 294              	.L17:
 295              		.loc 1 426 1 view .LVU80
 296              		.align	2
 297              	.L16:
 298 0024 00000000 		.word	buzzerCount
 299 0028 00000000 		.word	buzzerFreq
 300              		.cfi_endproc
 301              	.LFE70:
 303              		.section	.text.beepCount,"ax",%progbits
 304              		.align	1
 305              		.global	beepCount
 306              		.syntax unified
 307              		.thumb
 308              		.thumb_func
 310              	beepCount:
 311              	.LVL9:
 312              	.LFB71:
 427:Src/util.c    **** 
 428:Src/util.c    **** void beepCount(uint8_t cnt, uint8_t freq, uint8_t pattern) {
 313              		.loc 1 428 60 is_stmt 1 view -0
 314              		.cfi_startproc
 315              		@ args = 0, pretend = 0, frame = 0
 316              		@ frame_needed = 0, uses_anonymous_args = 0
 317              		@ link register save eliminated.
 429:Src/util.c    ****     buzzerCount   = cnt;
 318              		.loc 1 429 5 view .LVU82
 319              		.loc 1 429 19 is_stmt 0 view .LVU83
ARM GAS  /tmp/cchLDBog.s 			page 14


 320 0000 034B     		ldr	r3, .L19
 321 0002 1870     		strb	r0, [r3]
 430:Src/util.c    ****     buzzerFreq    = freq;
 322              		.loc 1 430 5 is_stmt 1 view .LVU84
 323              		.loc 1 430 19 is_stmt 0 view .LVU85
 324 0004 034B     		ldr	r3, .L19+4
 325 0006 1970     		strb	r1, [r3]
 431:Src/util.c    ****     buzzerPattern = pattern;
 326              		.loc 1 431 5 is_stmt 1 view .LVU86
 327              		.loc 1 431 19 is_stmt 0 view .LVU87
 328 0008 034B     		ldr	r3, .L19+8
 329 000a 1A70     		strb	r2, [r3]
 432:Src/util.c    **** }
 330              		.loc 1 432 1 view .LVU88
 331 000c 7047     		bx	lr
 332              	.L20:
 333 000e 00BF     		.align	2
 334              	.L19:
 335 0010 00000000 		.word	buzzerCount
 336 0014 00000000 		.word	buzzerFreq
 337 0018 00000000 		.word	buzzerPattern
 338              		.cfi_endproc
 339              	.LFE71:
 341              		.section	.text.beepLong,"ax",%progbits
 342              		.align	1
 343              		.global	beepLong
 344              		.syntax unified
 345              		.thumb
 346              		.thumb_func
 348              	beepLong:
 349              	.LVL10:
 350              	.LFB72:
 433:Src/util.c    **** 
 434:Src/util.c    **** void beepLong(uint8_t freq) {
 351              		.loc 1 434 29 is_stmt 1 view -0
 352              		.cfi_startproc
 353              		@ args = 0, pretend = 0, frame = 0
 354              		@ frame_needed = 0, uses_anonymous_args = 0
 355              		.loc 1 434 29 is_stmt 0 view .LVU90
 356 0000 38B5     		push	{r3, r4, r5, lr}
 357              	.LCFI2:
 358              		.cfi_def_cfa_offset 16
 359              		.cfi_offset 3, -16
 360              		.cfi_offset 4, -12
 361              		.cfi_offset 5, -8
 362              		.cfi_offset 14, -4
 435:Src/util.c    ****     buzzerCount = 0;  // prevent interraction with beep counter
 363              		.loc 1 435 5 is_stmt 1 view .LVU91
 364              		.loc 1 435 17 is_stmt 0 view .LVU92
 365 0002 0025     		movs	r5, #0
 366 0004 044B     		ldr	r3, .L23
 367 0006 1D70     		strb	r5, [r3]
 436:Src/util.c    ****     buzzerFreq = freq;
 368              		.loc 1 436 5 is_stmt 1 view .LVU93
 369              		.loc 1 436 16 is_stmt 0 view .LVU94
 370 0008 044C     		ldr	r4, .L23+4
 371 000a 2070     		strb	r0, [r4]
ARM GAS  /tmp/cchLDBog.s 			page 15


 437:Src/util.c    ****     HAL_Delay(500);
 372              		.loc 1 437 5 is_stmt 1 view .LVU95
 373 000c 4FF4FA70 		mov	r0, #500
 374              	.LVL11:
 375              		.loc 1 437 5 is_stmt 0 view .LVU96
 376 0010 FFF7FEFF 		bl	HAL_Delay
 377              	.LVL12:
 438:Src/util.c    ****     buzzerFreq = 0;
 378              		.loc 1 438 5 is_stmt 1 view .LVU97
 379              		.loc 1 438 16 is_stmt 0 view .LVU98
 380 0014 2570     		strb	r5, [r4]
 439:Src/util.c    **** }
 381              		.loc 1 439 1 view .LVU99
 382 0016 38BD     		pop	{r3, r4, r5, pc}
 383              	.L24:
 384              		.align	2
 385              	.L23:
 386 0018 00000000 		.word	buzzerCount
 387 001c 00000000 		.word	buzzerFreq
 388              		.cfi_endproc
 389              	.LFE72:
 391              		.section	.text.beepShort,"ax",%progbits
 392              		.align	1
 393              		.global	beepShort
 394              		.syntax unified
 395              		.thumb
 396              		.thumb_func
 398              	beepShort:
 399              	.LVL13:
 400              	.LFB73:
 440:Src/util.c    **** 
 441:Src/util.c    **** void beepShort(uint8_t freq) {
 401              		.loc 1 441 30 is_stmt 1 view -0
 402              		.cfi_startproc
 403              		@ args = 0, pretend = 0, frame = 0
 404              		@ frame_needed = 0, uses_anonymous_args = 0
 405              		.loc 1 441 30 is_stmt 0 view .LVU101
 406 0000 38B5     		push	{r3, r4, r5, lr}
 407              	.LCFI3:
 408              		.cfi_def_cfa_offset 16
 409              		.cfi_offset 3, -16
 410              		.cfi_offset 4, -12
 411              		.cfi_offset 5, -8
 412              		.cfi_offset 14, -4
 442:Src/util.c    ****     buzzerCount = 0;  // prevent interraction with beep counter
 413              		.loc 1 442 5 is_stmt 1 view .LVU102
 414              		.loc 1 442 17 is_stmt 0 view .LVU103
 415 0002 0025     		movs	r5, #0
 416 0004 044B     		ldr	r3, .L27
 417 0006 1D70     		strb	r5, [r3]
 443:Src/util.c    ****     buzzerFreq = freq;
 418              		.loc 1 443 5 is_stmt 1 view .LVU104
 419              		.loc 1 443 16 is_stmt 0 view .LVU105
 420 0008 044C     		ldr	r4, .L27+4
 421 000a 2070     		strb	r0, [r4]
 444:Src/util.c    ****     HAL_Delay(100);
 422              		.loc 1 444 5 is_stmt 1 view .LVU106
ARM GAS  /tmp/cchLDBog.s 			page 16


 423 000c 6420     		movs	r0, #100
 424              	.LVL14:
 425              		.loc 1 444 5 is_stmt 0 view .LVU107
 426 000e FFF7FEFF 		bl	HAL_Delay
 427              	.LVL15:
 445:Src/util.c    ****     buzzerFreq = 0;
 428              		.loc 1 445 5 is_stmt 1 view .LVU108
 429              		.loc 1 445 16 is_stmt 0 view .LVU109
 430 0012 2570     		strb	r5, [r4]
 446:Src/util.c    **** }
 431              		.loc 1 446 1 view .LVU110
 432 0014 38BD     		pop	{r3, r4, r5, pc}
 433              	.L28:
 434 0016 00BF     		.align	2
 435              	.L27:
 436 0018 00000000 		.word	buzzerCount
 437 001c 00000000 		.word	buzzerFreq
 438              		.cfi_endproc
 439              	.LFE73:
 441              		.section	.text.beepShortMany,"ax",%progbits
 442              		.align	1
 443              		.global	beepShortMany
 444              		.syntax unified
 445              		.thumb
 446              		.thumb_func
 448              	beepShortMany:
 449              	.LVL16:
 450              	.LFB74:
 447:Src/util.c    **** 
 448:Src/util.c    **** void beepShortMany(uint8_t cnt, int8_t dir) {
 451              		.loc 1 448 45 is_stmt 1 view -0
 452              		.cfi_startproc
 453              		@ args = 0, pretend = 0, frame = 0
 454              		@ frame_needed = 0, uses_anonymous_args = 0
 455              		.loc 1 448 45 is_stmt 0 view .LVU112
 456 0000 38B5     		push	{r3, r4, r5, lr}
 457              	.LCFI4:
 458              		.cfi_def_cfa_offset 16
 459              		.cfi_offset 3, -16
 460              		.cfi_offset 4, -12
 461              		.cfi_offset 5, -8
 462              		.cfi_offset 14, -4
 463 0002 0446     		mov	r4, r0
 449:Src/util.c    ****     if (dir >= 0) {   // increasing tone
 464              		.loc 1 449 5 is_stmt 1 view .LVU113
 465              		.loc 1 449 8 is_stmt 0 view .LVU114
 466 0004 0029     		cmp	r1, #0
 467 0006 15DB     		blt	.L35
 450:Src/util.c    ****       for(uint8_t i = 2*cnt; i >= 2; i=i-2) {
 468              		.loc 1 450 7 is_stmt 1 view .LVU115
 469              	.LBB3:
 470              		.loc 1 450 11 view .LVU116
 471              		.loc 1 450 19 is_stmt 0 view .LVU117
 472 0008 4400     		lsls	r4, r0, #1
 473 000a E4B2     		uxtb	r4, r4
 474              	.LVL17:
 475              		.loc 1 450 7 view .LVU118
ARM GAS  /tmp/cchLDBog.s 			page 17


 476 000c 05E0     		b	.L31
 477              	.LVL18:
 478              	.L32:
 451:Src/util.c    ****         beepShort(i + 3);
 479              		.loc 1 451 9 is_stmt 1 view .LVU119
 480 000e E01C     		adds	r0, r4, #3
 481 0010 C0B2     		uxtb	r0, r0
 482 0012 FFF7FEFF 		bl	beepShort
 483              	.LVL19:
 450:Src/util.c    ****       for(uint8_t i = 2*cnt; i >= 2; i=i-2) {
 484              		.loc 1 450 39 discriminator 3 view .LVU120
 485 0016 023C     		subs	r4, r4, #2
 486              	.LVL20:
 450:Src/util.c    ****       for(uint8_t i = 2*cnt; i >= 2; i=i-2) {
 487              		.loc 1 450 39 is_stmt 0 discriminator 3 view .LVU121
 488 0018 E4B2     		uxtb	r4, r4
 489              	.LVL21:
 490              	.L31:
 450:Src/util.c    ****       for(uint8_t i = 2*cnt; i >= 2; i=i-2) {
 491              		.loc 1 450 32 is_stmt 1 discriminator 1 view .LVU122
 492 001a 012C     		cmp	r4, #1
 493 001c F7D8     		bhi	.L32
 494              	.LVL22:
 495              	.L29:
 450:Src/util.c    ****       for(uint8_t i = 2*cnt; i >= 2; i=i-2) {
 496              		.loc 1 450 32 is_stmt 0 discriminator 1 view .LVU123
 497              	.LBE3:
 452:Src/util.c    ****       }
 453:Src/util.c    ****     } else {          // decreasing tone
 454:Src/util.c    ****       for(uint8_t i = 2; i <= 2*cnt; i=i+2) {
 455:Src/util.c    ****         beepShort(i + 3);
 456:Src/util.c    ****       }
 457:Src/util.c    ****     }
 458:Src/util.c    **** }
 498              		.loc 1 458 1 view .LVU124
 499 001e 38BD     		pop	{r3, r4, r5, pc}
 500              	.LVL23:
 501              	.L34:
 502              	.LBB4:
 455:Src/util.c    ****       }
 503              		.loc 1 455 9 is_stmt 1 view .LVU125
 504 0020 E81C     		adds	r0, r5, #3
 505 0022 C0B2     		uxtb	r0, r0
 506 0024 FFF7FEFF 		bl	beepShort
 507              	.LVL24:
 454:Src/util.c    ****         beepShort(i + 3);
 508              		.loc 1 454 39 discriminator 3 view .LVU126
 509 0028 0235     		adds	r5, r5, #2
 510              	.LVL25:
 454:Src/util.c    ****         beepShort(i + 3);
 511              		.loc 1 454 39 is_stmt 0 discriminator 3 view .LVU127
 512 002a EDB2     		uxtb	r5, r5
 513              	.LVL26:
 514              	.L30:
 454:Src/util.c    ****         beepShort(i + 3);
 515              		.loc 1 454 28 is_stmt 1 discriminator 1 view .LVU128
 516 002c B5EB440F 		cmp	r5, r4, lsl #1
ARM GAS  /tmp/cchLDBog.s 			page 18


 517 0030 F6DD     		ble	.L34
 518 0032 F4E7     		b	.L29
 519              	.LVL27:
 520              	.L35:
 454:Src/util.c    ****         beepShort(i + 3);
 521              		.loc 1 454 19 is_stmt 0 view .LVU129
 522 0034 0225     		movs	r5, #2
 523 0036 F9E7     		b	.L30
 524              	.LBE4:
 525              		.cfi_endproc
 526              	.LFE74:
 528              		.section	.text.calcAvgSpeed,"ax",%progbits
 529              		.align	1
 530              		.global	calcAvgSpeed
 531              		.syntax unified
 532              		.thumb
 533              		.thumb_func
 535              	calcAvgSpeed:
 536              	.LFB75:
 459:Src/util.c    **** 
 460:Src/util.c    **** void calcAvgSpeed(void) {
 537              		.loc 1 460 25 is_stmt 1 view -0
 538              		.cfi_startproc
 539              		@ args = 0, pretend = 0, frame = 0
 540              		@ frame_needed = 0, uses_anonymous_args = 0
 541              		@ link register save eliminated.
 461:Src/util.c    ****     // Calculate measured average speed. The minus sign (-) is because motors spin in opposite dire
 462:Src/util.c    ****     speedAvg = 0;
 542              		.loc 1 462 5 view .LVU131
 543              		.loc 1 462 14 is_stmt 0 view .LVU132
 544 0000 0B4A     		ldr	r2, .L38
 545 0002 0023     		movs	r3, #0
 546 0004 1380     		strh	r3, [r2]	@ movhi
 463:Src/util.c    ****     #if defined(MOTOR_LEFT_ENA)
 464:Src/util.c    ****       #if defined(INVERT_L_DIRECTION)
 465:Src/util.c    ****         speedAvg -= rtY_Left.n_mot;
 466:Src/util.c    ****       #else
 467:Src/util.c    ****         speedAvg += rtY_Left.n_mot;
 547              		.loc 1 467 9 is_stmt 1 view .LVU133
 548              		.loc 1 467 29 is_stmt 0 view .LVU134
 549 0006 0B4B     		ldr	r3, .L38+4
 550 0008 B3F90810 		ldrsh	r1, [r3, #8]
 551 000c 8BB2     		uxth	r3, r1
 552              		.loc 1 467 18 view .LVU135
 553 000e 1180     		strh	r1, [r2]	@ movhi
 468:Src/util.c    ****       #endif
 469:Src/util.c    ****     #endif
 470:Src/util.c    ****     #if defined(MOTOR_RIGHT_ENA)
 471:Src/util.c    ****       #if defined(INVERT_R_DIRECTION)
 472:Src/util.c    ****         speedAvg += rtY_Right.n_mot;
 473:Src/util.c    ****       #else
 474:Src/util.c    ****         speedAvg -= rtY_Right.n_mot;
 554              		.loc 1 474 9 is_stmt 1 view .LVU136
 555              		.loc 1 474 30 is_stmt 0 view .LVU137
 556 0010 0949     		ldr	r1, .L38+8
 557 0012 0989     		ldrh	r1, [r1, #8]
 558              		.loc 1 474 18 view .LVU138
ARM GAS  /tmp/cchLDBog.s 			page 19


 559 0014 5B1A     		subs	r3, r3, r1
 560 0016 1BB2     		sxth	r3, r3
 561 0018 1380     		strh	r3, [r2]	@ movhi
 475:Src/util.c    ****       #endif
 476:Src/util.c    **** 
 477:Src/util.c    ****       // Average only if both motors are enabled
 478:Src/util.c    ****       #if defined(MOTOR_LEFT_ENA)
 479:Src/util.c    ****         speedAvg /= 2;
 562              		.loc 1 479 9 is_stmt 1 view .LVU139
 563              		.loc 1 479 18 is_stmt 0 view .LVU140
 564 001a 03EBD373 		add	r3, r3, r3, lsr #31
 565 001e 5B10     		asrs	r3, r3, #1
 566 0020 1380     		strh	r3, [r2]	@ movhi
 480:Src/util.c    ****       #endif  
 481:Src/util.c    ****     #endif
 482:Src/util.c    **** 
 483:Src/util.c    ****     // Handle the case when SPEED_COEFFICIENT sign is negative (which is when most significant bit 
 484:Src/util.c    ****     if (SPEED_COEFFICIENT & (1 << 16)) {
 567              		.loc 1 484 5 is_stmt 1 view .LVU141
 485:Src/util.c    ****       speedAvg    = -speedAvg;
 486:Src/util.c    ****     } 
 487:Src/util.c    ****     speedAvgAbs   = abs(speedAvg);
 568              		.loc 1 487 5 view .LVU142
 569              		.loc 1 487 21 is_stmt 0 view .LVU143
 570 0022 002B     		cmp	r3, #0
 571 0024 B8BF     		it	lt
 572 0026 5B42     		rsblt	r3, r3, #0
 573              		.loc 1 487 19 view .LVU144
 574 0028 044A     		ldr	r2, .L38+12
 575 002a 1380     		strh	r3, [r2]	@ movhi
 488:Src/util.c    **** }
 576              		.loc 1 488 1 view .LVU145
 577 002c 7047     		bx	lr
 578              	.L39:
 579 002e 00BF     		.align	2
 580              	.L38:
 581 0030 00000000 		.word	speedAvg
 582 0034 00000000 		.word	rtY_Left
 583 0038 00000000 		.word	rtY_Right
 584 003c 00000000 		.word	speedAvgAbs
 585              		.cfi_endproc
 586              	.LFE75:
 588              		.section	.text.standstillHold,"ax",%progbits
 589              		.align	1
 590              		.global	standstillHold
 591              		.syntax unified
 592              		.thumb
 593              		.thumb_func
 595              	standstillHold:
 596              	.LFB78:
 489:Src/util.c    **** 
 490:Src/util.c    ****  /*
 491:Src/util.c    ****  * Auto-calibration of the ADC Limits
 492:Src/util.c    ****  * This function finds the Minimum, Maximum, and Middle for the ADC input
 493:Src/util.c    ****  * Procedure:
 494:Src/util.c    ****  * - press the power button for more than 5 sec and release after the beep sound
 495:Src/util.c    ****  * - move the potentiometers freely to the min and max limits repeatedly
ARM GAS  /tmp/cchLDBog.s 			page 20


 496:Src/util.c    ****  * - release potentiometers to the resting postion
 497:Src/util.c    ****  * - press the power button to confirm or wait for the 20 sec timeout
 498:Src/util.c    ****  * The Values will be saved to flash. Values are persistent if you flash with platformio. To erase 
 499:Src/util.c    ****  */
 500:Src/util.c    **** void adcCalibLim(void) {
 501:Src/util.c    **** #ifdef AUTO_CALIBRATION_ENA
 502:Src/util.c    ****   calcAvgSpeed();
 503:Src/util.c    ****   if (speedAvgAbs > 5) {    // do not enter this mode if motors are spinning
 504:Src/util.c    ****     return;
 505:Src/util.c    ****   }
 506:Src/util.c    **** 
 507:Src/util.c    **** #if !defined(VARIANT_HOVERBOARD) && !defined(VARIANT_TRANSPOTTER)
 508:Src/util.c    **** 
 509:Src/util.c    ****   #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 510:Src/util.c    ****   printf("Input calibration started...\r\n");
 511:Src/util.c    ****   #endif
 512:Src/util.c    **** 
 513:Src/util.c    ****   readInputRaw();
 514:Src/util.c    ****   // Inititalization: MIN = a high value, MAX = a low value
 515:Src/util.c    ****   int32_t  input1_fixdt = input1[inIdx].raw << 16;
 516:Src/util.c    ****   int32_t  input2_fixdt = input2[inIdx].raw << 16;
 517:Src/util.c    ****   int16_t  INPUT1_MIN_temp = MAX_int16_T;
 518:Src/util.c    ****   int16_t  INPUT1_MID_temp = 0;
 519:Src/util.c    ****   int16_t  INPUT1_MAX_temp = MIN_int16_T;
 520:Src/util.c    ****   int16_t  INPUT2_MIN_temp = MAX_int16_T;
 521:Src/util.c    ****   int16_t  INPUT2_MID_temp = 0;
 522:Src/util.c    ****   int16_t  INPUT2_MAX_temp = MIN_int16_T;
 523:Src/util.c    ****   int16_t  input_margin    = 0;
 524:Src/util.c    ****   uint16_t input_cal_timeout = 0;
 525:Src/util.c    ****   
 526:Src/util.c    ****   #ifdef CONTROL_ADC
 527:Src/util.c    ****   if (inIdx == CONTROL_ADC) {
 528:Src/util.c    ****     input_margin = ADC_MARGIN;
 529:Src/util.c    ****   }
 530:Src/util.c    ****   #endif
 531:Src/util.c    **** 
 532:Src/util.c    ****   // Extract MIN, MAX and MID from ADC while the power button is not pressed
 533:Src/util.c    ****   while (!HAL_GPIO_ReadPin(BUTTON_PORT, BUTTON_PIN) && input_cal_timeout++ < 4000) {   // 20 sec ti
 534:Src/util.c    ****     readInputRaw();
 535:Src/util.c    ****     filtLowPass32(input1[inIdx].raw, FILTER, &input1_fixdt);
 536:Src/util.c    ****     filtLowPass32(input2[inIdx].raw, FILTER, &input2_fixdt);
 537:Src/util.c    ****     
 538:Src/util.c    ****     INPUT1_MID_temp = (int16_t)(input1_fixdt >> 16);// CLAMP(input1_fixdt >> 16, INPUT1_MIN, INPUT1
 539:Src/util.c    ****     INPUT2_MID_temp = (int16_t)(input2_fixdt >> 16);// CLAMP(input2_fixdt >> 16, INPUT2_MIN, INPUT2
 540:Src/util.c    ****     INPUT1_MIN_temp = MIN(INPUT1_MIN_temp, INPUT1_MID_temp);
 541:Src/util.c    ****     INPUT1_MAX_temp = MAX(INPUT1_MAX_temp, INPUT1_MID_temp);
 542:Src/util.c    ****     INPUT2_MIN_temp = MIN(INPUT2_MIN_temp, INPUT2_MID_temp);
 543:Src/util.c    ****     INPUT2_MAX_temp = MAX(INPUT2_MAX_temp, INPUT2_MID_temp);
 544:Src/util.c    ****     HAL_Delay(5);
 545:Src/util.c    ****   }
 546:Src/util.c    **** 
 547:Src/util.c    ****   #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 548:Src/util.c    ****   printf("Input1 is ");
 549:Src/util.c    ****   #endif
 550:Src/util.c    ****   uint8_t input1TypTemp = checkInputType(INPUT1_MIN_temp, INPUT1_MID_temp, INPUT1_MAX_temp);
 551:Src/util.c    ****   if (input1TypTemp == input1[inIdx].typDef || input1[inIdx].typDef == 3) {  // Accept calibration 
 552:Src/util.c    ****     #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
ARM GAS  /tmp/cchLDBog.s 			page 21


 553:Src/util.c    ****     printf("..OK\r\n");
 554:Src/util.c    ****     #endif
 555:Src/util.c    ****   } else {
 556:Src/util.c    ****     input1TypTemp = 0; // Disable input
 557:Src/util.c    ****     #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 558:Src/util.c    ****     printf("..NOK\r\n");
 559:Src/util.c    ****     #endif
 560:Src/util.c    ****   }
 561:Src/util.c    **** 
 562:Src/util.c    ****   #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 563:Src/util.c    ****   printf("Input2 is ");
 564:Src/util.c    ****   #endif
 565:Src/util.c    ****   uint8_t input2TypTemp = checkInputType(INPUT2_MIN_temp, INPUT2_MID_temp, INPUT2_MAX_temp);
 566:Src/util.c    ****   if (input2TypTemp == input2[inIdx].typDef || input2[inIdx].typDef == 3) {  // Accept calibration 
 567:Src/util.c    ****     #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 568:Src/util.c    ****     printf("..OK\r\n");
 569:Src/util.c    ****     #endif
 570:Src/util.c    ****   } else {
 571:Src/util.c    ****     input2TypTemp = 0; // Disable input
 572:Src/util.c    ****     #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 573:Src/util.c    ****     printf("..NOK\r\n");
 574:Src/util.c    ****     #endif
 575:Src/util.c    ****   }
 576:Src/util.c    **** 
 577:Src/util.c    **** 
 578:Src/util.c    ****   // At least one of the inputs is not ignored
 579:Src/util.c    ****   if (input1TypTemp != 0 || input2TypTemp != 0){
 580:Src/util.c    ****     input1[inIdx].typ = input1TypTemp;
 581:Src/util.c    ****     input1[inIdx].min = INPUT1_MIN_temp + input_margin;
 582:Src/util.c    ****     input1[inIdx].mid = INPUT1_MID_temp;
 583:Src/util.c    ****     input1[inIdx].max = INPUT1_MAX_temp - input_margin;
 584:Src/util.c    **** 
 585:Src/util.c    ****     input2[inIdx].typ = input2TypTemp;
 586:Src/util.c    ****     input2[inIdx].min = INPUT2_MIN_temp + input_margin;
 587:Src/util.c    ****     input2[inIdx].mid = INPUT2_MID_temp;
 588:Src/util.c    ****     input2[inIdx].max = INPUT2_MAX_temp - input_margin;
 589:Src/util.c    **** 
 590:Src/util.c    ****     inp_cal_valid = 1;    // Mark calibration to be saved in Flash at shutdown
 591:Src/util.c    ****     #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 592:Src/util.c    ****     printf("Limits Input1: TYP:%i MIN:%i MID:%i MAX:%i\r\nLimits Input2: TYP:%i MIN:%i MID:%i MAX:%
 593:Src/util.c    ****             input1[inIdx].typ, input1[inIdx].min, input1[inIdx].mid, input1[inIdx].max,
 594:Src/util.c    ****             input2[inIdx].typ, input2[inIdx].min, input2[inIdx].mid, input2[inIdx].max);
 595:Src/util.c    ****     #endif
 596:Src/util.c    ****   }else{
 597:Src/util.c    ****     #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 598:Src/util.c    ****     printf("Both inputs cannot be ignored, calibration rejected.\r\n");
 599:Src/util.c    ****     #endif
 600:Src/util.c    ****   }
 601:Src/util.c    **** 
 602:Src/util.c    **** #endif
 603:Src/util.c    **** #endif  // AUTO_CALIBRATION_ENA
 604:Src/util.c    **** }
 605:Src/util.c    ****  /*
 606:Src/util.c    ****  * Update Maximum Motor Current Limit (via ADC1) and Maximum Speed Limit (via ADC2)
 607:Src/util.c    ****  * Procedure:
 608:Src/util.c    ****  * - press the power button for more than 5 sec and immediatelly after the beep sound press one mor
 609:Src/util.c    ****  * - move and hold the pots to a desired limit position for Current and Speed
ARM GAS  /tmp/cchLDBog.s 			page 22


 610:Src/util.c    ****  * - press the power button to confirm or wait for the 10 sec timeout
 611:Src/util.c    ****  */
 612:Src/util.c    **** void updateCurSpdLim(void) {
 613:Src/util.c    ****   calcAvgSpeed();
 614:Src/util.c    ****   if (speedAvgAbs > 5) {    // do not enter this mode if motors are spinning
 615:Src/util.c    ****     return;
 616:Src/util.c    ****   }
 617:Src/util.c    **** 
 618:Src/util.c    **** #if !defined(VARIANT_HOVERBOARD) && !defined(VARIANT_TRANSPOTTER)
 619:Src/util.c    **** 
 620:Src/util.c    ****   #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 621:Src/util.c    ****   printf("Torque and Speed limits update started...\r\n");
 622:Src/util.c    ****   #endif
 623:Src/util.c    **** 
 624:Src/util.c    ****   int32_t  input1_fixdt = input1[inIdx].raw << 16;
 625:Src/util.c    ****   int32_t  input2_fixdt = input2[inIdx].raw << 16;
 626:Src/util.c    ****   uint16_t cur_factor;    // fixdt(0,16,16)
 627:Src/util.c    ****   uint16_t spd_factor;    // fixdt(0,16,16)
 628:Src/util.c    ****   uint16_t cur_spd_timeout = 0;
 629:Src/util.c    ****   cur_spd_valid = 0;
 630:Src/util.c    **** 
 631:Src/util.c    ****   // Wait for the power button press
 632:Src/util.c    ****   while (!HAL_GPIO_ReadPin(BUTTON_PORT, BUTTON_PIN) && cur_spd_timeout++ < 2000) {  // 10 sec timeo
 633:Src/util.c    ****     readInputRaw();
 634:Src/util.c    ****     filtLowPass32(input1[inIdx].raw, FILTER, &input1_fixdt);
 635:Src/util.c    ****     filtLowPass32(input2[inIdx].raw, FILTER, &input2_fixdt);
 636:Src/util.c    ****     HAL_Delay(5);
 637:Src/util.c    ****   }
 638:Src/util.c    ****   // Calculate scaling factors
 639:Src/util.c    ****   cur_factor = CLAMP((input1_fixdt - (input1[inIdx].min << 16)) / (input1[inIdx].max - input1[inIdx
 640:Src/util.c    ****   spd_factor = CLAMP((input2_fixdt - (input2[inIdx].min << 16)) / (input2[inIdx].max - input2[inIdx
 641:Src/util.c    ****       
 642:Src/util.c    ****   if (input1[inIdx].typ != 0){
 643:Src/util.c    ****     // Update current limit
 644:Src/util.c    ****     rtP_Left.i_max = rtP_Right.i_max  = (int16_t)((I_MOT_MAX * A2BIT_CONV * cur_factor) >> 12);    
 645:Src/util.c    ****     cur_spd_valid   = 1;  // Mark update to be saved in Flash at shutdown
 646:Src/util.c    ****   }
 647:Src/util.c    **** 
 648:Src/util.c    ****   if (input2[inIdx].typ != 0){
 649:Src/util.c    ****     // Update speed limit
 650:Src/util.c    ****     rtP_Left.n_max = rtP_Right.n_max  = (int16_t)((N_MOT_MAX * spd_factor) >> 12);                 
 651:Src/util.c    ****     cur_spd_valid  += 2;  // Mark update to be saved in Flash at shutdown
 652:Src/util.c    ****   }
 653:Src/util.c    **** 
 654:Src/util.c    ****   #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 655:Src/util.c    ****   // cur_spd_valid: 0 = No limit changed, 1 = Current limit changed, 2 = Speed limit changed, 3 = B
 656:Src/util.c    ****   printf("Limits (%i)\r\nCurrent: fixdt:%li factor%i i_max:%i \r\nSpeed: fixdt:%li factor:%i n_max:
 657:Src/util.c    ****           cur_spd_valid, input1_fixdt, cur_factor, rtP_Left.i_max, input2_fixdt, spd_factor, rtP_Le
 658:Src/util.c    ****   #endif
 659:Src/util.c    **** 
 660:Src/util.c    **** #endif
 661:Src/util.c    **** }
 662:Src/util.c    **** 
 663:Src/util.c    ****  /*
 664:Src/util.c    ****  * Standstill Hold Function
 665:Src/util.c    ****  * This function uses Cruise Control to provide an anti-roll functionality at standstill.
 666:Src/util.c    ****  * Only available and makes sense for FOC VOLTAGE or FOC TORQUE mode.
ARM GAS  /tmp/cchLDBog.s 			page 23


 667:Src/util.c    ****  * 
 668:Src/util.c    ****  * Input:  none
 669:Src/util.c    ****  * Output: standstillAcv
 670:Src/util.c    ****  */
 671:Src/util.c    **** void standstillHold(void) {
 597              		.loc 1 671 27 is_stmt 1 view -0
 598              		.cfi_startproc
 599              		@ args = 0, pretend = 0, frame = 0
 600              		@ frame_needed = 0, uses_anonymous_args = 0
 601              		@ link register save eliminated.
 672:Src/util.c    ****   #if defined(STANDSTILL_HOLD_ENABLE) && (CTRL_TYP_SEL == FOC_CTRL) && (CTRL_MOD_REQ != SPD_MODE)
 673:Src/util.c    ****     if (!rtP_Left.b_cruiseCtrlEna) {                                  // If Stanstill in NOT Active
 674:Src/util.c    ****       if (((input1[inIdx].cmd > 50 || input2[inIdx].cmd < -50) && speedAvgAbs < 30) // Check if Bra
 675:Src/util.c    ****           || (input2[inIdx].cmd < 20 && speedAvgAbs < 5)) {           // OR Throttle is small AND m
 676:Src/util.c    ****         rtP_Left.n_cruiseMotTgt   = 0;
 677:Src/util.c    ****         rtP_Right.n_cruiseMotTgt  = 0;
 678:Src/util.c    ****         rtP_Left.b_cruiseCtrlEna  = 1;
 679:Src/util.c    ****         rtP_Right.b_cruiseCtrlEna = 1;
 680:Src/util.c    ****         standstillAcv = 1;
 681:Src/util.c    ****       } 
 682:Src/util.c    ****     }
 683:Src/util.c    ****     else {                                                            // If Stanstill is Active -> 
 684:Src/util.c    ****       if (input1[inIdx].cmd < 20 && input2[inIdx].cmd > 50 && !cruiseCtrlAcv) { // Check if Brake i
 685:Src/util.c    ****         rtP_Left.b_cruiseCtrlEna  = 0;
 686:Src/util.c    ****         rtP_Right.b_cruiseCtrlEna = 0;
 687:Src/util.c    ****         standstillAcv = 0;
 688:Src/util.c    ****       }
 689:Src/util.c    ****     }
 690:Src/util.c    ****   #endif
 691:Src/util.c    **** }
 602              		.loc 1 691 1 view .LVU147
 603 0000 7047     		bx	lr
 604              		.cfi_endproc
 605              	.LFE78:
 607              		.section	.text.electricBrake,"ax",%progbits
 608              		.align	1
 609              		.global	electricBrake
 610              		.syntax unified
 611              		.thumb
 612              		.thumb_func
 614              	electricBrake:
 615              	.LVL28:
 616              	.LFB79:
 692:Src/util.c    **** 
 693:Src/util.c    ****  /*
 694:Src/util.c    ****  * Electric Brake Function
 695:Src/util.c    ****  * In case of TORQUE mode, this function replaces the motor "freewheel" with a constant braking whe
 696:Src/util.c    ****  * This is useful when a small amount of motor braking is desired instead of "freewheel".
 697:Src/util.c    ****  * 
 698:Src/util.c    ****  * Input: speedBlend = fixdt(0,16,15), reverseDir = {0, 1}
 699:Src/util.c    ****  * Output: input2.cmd (Throtle) with brake component included
 700:Src/util.c    ****  */
 701:Src/util.c    **** void electricBrake(uint16_t speedBlend, uint8_t reverseDir) {
 617              		.loc 1 701 61 view -0
 618              		.cfi_startproc
 619              		@ args = 0, pretend = 0, frame = 0
 620              		@ frame_needed = 0, uses_anonymous_args = 0
ARM GAS  /tmp/cchLDBog.s 			page 24


 621              		@ link register save eliminated.
 702:Src/util.c    ****   #if defined(ELECTRIC_BRAKE_ENABLE) && (CTRL_TYP_SEL == FOC_CTRL) && (CTRL_MOD_REQ == TRQ_MODE)
 703:Src/util.c    ****     int16_t brakeVal;
 704:Src/util.c    **** 
 705:Src/util.c    ****     // Make sure the Brake pedal is opposite to the direction of motion AND it goes to 0 as we reac
 706:Src/util.c    ****     if (speedAvg > 0) {
 707:Src/util.c    ****       brakeVal = (int16_t)((-ELECTRIC_BRAKE_MAX * speedBlend) >> 15);
 708:Src/util.c    ****     } else {
 709:Src/util.c    ****       brakeVal = (int16_t)(( ELECTRIC_BRAKE_MAX * speedBlend) >> 15);
 710:Src/util.c    ****     }
 711:Src/util.c    **** 
 712:Src/util.c    ****     // Check if direction is reversed
 713:Src/util.c    ****     if (reverseDir) {
 714:Src/util.c    ****       brakeVal = -brakeVal;
 715:Src/util.c    ****     }
 716:Src/util.c    **** 
 717:Src/util.c    ****     // Calculate the new input2.cmd with brake component included
 718:Src/util.c    ****     if (input2[inIdx].cmd >= 0 && input2[inIdx].cmd < ELECTRIC_BRAKE_THRES) {
 719:Src/util.c    ****       input2[inIdx].cmd = MAX(brakeVal, ((ELECTRIC_BRAKE_THRES - input2[inIdx].cmd) * brakeVal) / E
 720:Src/util.c    ****     } else if (input2[inIdx].cmd >= -ELECTRIC_BRAKE_THRES && input2[inIdx].cmd < 0) {
 721:Src/util.c    ****       input2[inIdx].cmd = MIN(brakeVal, ((ELECTRIC_BRAKE_THRES + input2[inIdx].cmd) * brakeVal) / E
 722:Src/util.c    ****     } else if (input2[inIdx].cmd >= ELECTRIC_BRAKE_THRES) {
 723:Src/util.c    ****       input2[inIdx].cmd = MAX(brakeVal, ((input2[inIdx].cmd - ELECTRIC_BRAKE_THRES) * INPUT_MAX) / 
 724:Src/util.c    ****     } else {  // when (input2.cmd < -ELECTRIC_BRAKE_THRES)
 725:Src/util.c    ****       input2[inIdx].cmd = MIN(brakeVal, ((input2[inIdx].cmd + ELECTRIC_BRAKE_THRES) * INPUT_MIN) / 
 726:Src/util.c    ****     }
 727:Src/util.c    ****   #endif
 728:Src/util.c    **** }
 622              		.loc 1 728 1 view .LVU149
 623 0000 7047     		bx	lr
 624              		.cfi_endproc
 625              	.LFE79:
 627              		.section	.text.cruiseControl,"ax",%progbits
 628              		.align	1
 629              		.global	cruiseControl
 630              		.syntax unified
 631              		.thumb
 632              		.thumb_func
 634              	cruiseControl:
 635              	.LVL29:
 636              	.LFB80:
 729:Src/util.c    **** 
 730:Src/util.c    ****  /*
 731:Src/util.c    ****  * Cruise Control Function
 732:Src/util.c    ****  * This function activates/deactivates cruise control.
 733:Src/util.c    ****  * 
 734:Src/util.c    ****  * Input: button (as a pulse)
 735:Src/util.c    ****  * Output: cruiseCtrlAcv
 736:Src/util.c    ****  */
 737:Src/util.c    **** void cruiseControl(uint8_t button) {
 637              		.loc 1 737 36 view -0
 638              		.cfi_startproc
 639              		@ args = 0, pretend = 0, frame = 0
 640              		@ frame_needed = 0, uses_anonymous_args = 0
 641              		@ link register save eliminated.
 738:Src/util.c    ****   #ifdef CRUISE_CONTROL_SUPPORT
 739:Src/util.c    ****     if (button && !rtP_Left.b_cruiseCtrlEna) {                          // Cruise control activated
ARM GAS  /tmp/cchLDBog.s 			page 25


 740:Src/util.c    ****       rtP_Left.n_cruiseMotTgt   = rtY_Left.n_mot;
 741:Src/util.c    ****       rtP_Right.n_cruiseMotTgt  = rtY_Right.n_mot;
 742:Src/util.c    ****       rtP_Left.b_cruiseCtrlEna  = 1;
 743:Src/util.c    ****       rtP_Right.b_cruiseCtrlEna = 1;
 744:Src/util.c    ****       cruiseCtrlAcv = 1;
 745:Src/util.c    ****       beepShortMany(2, 1);                                              // 200 ms beep delay. Acts 
 746:Src/util.c    ****     } else if (button && rtP_Left.b_cruiseCtrlEna && !standstillAcv) {  // Cruise control deactivat
 747:Src/util.c    ****       rtP_Left.b_cruiseCtrlEna  = 0;
 748:Src/util.c    ****       rtP_Right.b_cruiseCtrlEna = 0;
 749:Src/util.c    ****       cruiseCtrlAcv = 0;
 750:Src/util.c    ****       beepShortMany(2, -1);
 751:Src/util.c    ****     }
 752:Src/util.c    ****   #endif
 753:Src/util.c    **** }
 642              		.loc 1 753 1 view .LVU151
 643 0000 7047     		bx	lr
 644              		.cfi_endproc
 645              	.LFE80:
 647              		.section	.text.checkInputType,"ax",%progbits
 648              		.align	1
 649              		.global	checkInputType
 650              		.syntax unified
 651              		.thumb
 652              		.thumb_func
 654              	checkInputType:
 655              	.LVL30:
 656              	.LFB81:
 754:Src/util.c    **** 
 755:Src/util.c    ****  /*
 756:Src/util.c    ****  * Check Input Type
 757:Src/util.c    ****  * This function identifies the input type: 0: Disabled, 1: Normal Pot, 2: Middle Resting Pot
 758:Src/util.c    ****  */
 759:Src/util.c    **** int checkInputType(int16_t min, int16_t mid, int16_t max){
 657              		.loc 1 759 58 view -0
 658              		.cfi_startproc
 659              		@ args = 0, pretend = 0, frame = 0
 660              		@ frame_needed = 0, uses_anonymous_args = 0
 661              		.loc 1 759 58 is_stmt 0 view .LVU153
 662 0000 10B5     		push	{r4, lr}
 663              	.LCFI5:
 664              		.cfi_def_cfa_offset 8
 665              		.cfi_offset 4, -8
 666              		.cfi_offset 14, -4
 760:Src/util.c    **** 
 761:Src/util.c    ****   int type = 0;  
 667              		.loc 1 761 3 is_stmt 1 view .LVU154
 668              	.LVL31:
 762:Src/util.c    ****   #ifdef CONTROL_ADC
 763:Src/util.c    ****   int16_t threshold = 400;      // Threshold to define if values are too close
 764:Src/util.c    ****   #else
 765:Src/util.c    ****   int16_t threshold = 200;
 669              		.loc 1 765 3 view .LVU155
 766:Src/util.c    ****   #endif
 767:Src/util.c    **** 
 768:Src/util.c    ****   if ((min / threshold) == (max / threshold) || (mid / threshold) == (max / threshold) || min > max
 670              		.loc 1 768 3 view .LVU156
 671              		.loc 1 768 12 is_stmt 0 view .LVU157
ARM GAS  /tmp/cchLDBog.s 			page 26


 672 0002 154B     		ldr	r3, .L52
 673 0004 83FB00C4 		smull	ip, r4, r3, r0
 674 0008 4FEAE07E 		asr	lr, r0, #31
 675 000c CEEBA41E 		rsb	lr, lr, r4, asr #6
 676              		.loc 1 768 33 view .LVU158
 677 0010 83FB0243 		smull	r4, r3, r3, r2
 678 0014 4FEAE27C 		asr	ip, r2, #31
 679 0018 CCEBA313 		rsb	r3, ip, r3, asr #6
 680              		.loc 1 768 6 view .LVU159
 681 001c 9E45     		cmp	lr, r3
 682 001e 12D0     		beq	.L45
 683              		.loc 1 768 54 discriminator 1 view .LVU160
 684 0020 0D4C     		ldr	r4, .L52
 685 0022 84FB01C4 		smull	ip, r4, r4, r1
 686 0026 4FEAE17C 		asr	ip, r1, #31
 687 002a CCEBA41C 		rsb	ip, ip, r4, asr #6
 688              		.loc 1 768 46 discriminator 1 view .LVU161
 689 002e 6345     		cmp	r3, ip
 690 0030 0BD0     		beq	.L46
 691              		.loc 1 768 88 discriminator 2 view .LVU162
 692 0032 9042     		cmp	r0, r2
 693 0034 0BDC     		bgt	.L47
 694              		.loc 1 768 101 discriminator 3 view .LVU163
 695 0036 8A42     		cmp	r2, r1
 696 0038 0BDB     		blt	.L48
 769:Src/util.c    ****     type = 0;
 770:Src/util.c    ****     #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 771:Src/util.c    ****     printf("ignored");                // (MIN and MAX) OR (MID and MAX) are close, disable input
 772:Src/util.c    ****     #endif
 773:Src/util.c    ****   } else {
 774:Src/util.c    ****     if ((min / threshold) == (mid / threshold)){
 697              		.loc 1 774 5 is_stmt 1 view .LVU164
 698              		.loc 1 774 8 is_stmt 0 view .LVU165
 699 003a E645     		cmp	lr, ip
 700 003c 01D0     		beq	.L51
 775:Src/util.c    ****       type = 1;
 776:Src/util.c    ****       #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 777:Src/util.c    ****       printf("a normal pot");        // MIN and MID are close, it's a normal pot
 778:Src/util.c    ****       #endif
 779:Src/util.c    ****     } else {
 780:Src/util.c    ****       type = 2;
 701              		.loc 1 780 12 view .LVU166
 702 003e 0220     		movs	r0, #2
 703              	.LVL32:
 781:Src/util.c    ****       #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 782:Src/util.c    ****       printf("a mid-resting pot");   // it's a mid resting pot
 783:Src/util.c    ****       #endif
 784:Src/util.c    ****     }
 785:Src/util.c    **** 
 786:Src/util.c    ****     #ifdef CONTROL_ADC
 787:Src/util.c    ****     if ((min + ADC_MARGIN - ADC_PROTECT_THRESH) > 0 && (max - ADC_MARGIN + ADC_PROTECT_THRESH) < 40
 788:Src/util.c    ****       #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 789:Src/util.c    ****       printf(" AND protected");
 790:Src/util.c    ****       #endif
 791:Src/util.c    ****       beepLong(2); // Indicate protection by a beep
 792:Src/util.c    ****     }
 793:Src/util.c    ****     #endif
ARM GAS  /tmp/cchLDBog.s 			page 27


 794:Src/util.c    ****   }
 795:Src/util.c    **** 
 796:Src/util.c    ****   return type;
 704              		.loc 1 796 3 is_stmt 1 view .LVU167
 705              		.loc 1 796 10 is_stmt 0 view .LVU168
 706 0040 02E0     		b	.L43
 707              	.LVL33:
 708              	.L51:
 775:Src/util.c    ****       type = 1;
 709              		.loc 1 775 12 view .LVU169
 710 0042 0120     		movs	r0, #1
 711              	.LVL34:
 775:Src/util.c    ****       type = 1;
 712              		.loc 1 775 12 view .LVU170
 713 0044 00E0     		b	.L43
 714              	.LVL35:
 715              	.L45:
 769:Src/util.c    ****     #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 716              		.loc 1 769 10 view .LVU171
 717 0046 0020     		movs	r0, #0
 718              	.LVL36:
 719              	.L43:
 797:Src/util.c    **** }
 720              		.loc 1 797 1 view .LVU172
 721 0048 10BD     		pop	{r4, pc}
 722              	.LVL37:
 723              	.L46:
 769:Src/util.c    ****     #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 724              		.loc 1 769 10 view .LVU173
 725 004a 0020     		movs	r0, #0
 726              	.LVL38:
 769:Src/util.c    ****     #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 727              		.loc 1 769 10 view .LVU174
 728 004c FCE7     		b	.L43
 729              	.LVL39:
 730              	.L47:
 769:Src/util.c    ****     #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 731              		.loc 1 769 10 view .LVU175
 732 004e 0020     		movs	r0, #0
 733              	.LVL40:
 769:Src/util.c    ****     #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 734              		.loc 1 769 10 view .LVU176
 735 0050 FAE7     		b	.L43
 736              	.LVL41:
 737              	.L48:
 769:Src/util.c    ****     #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 738              		.loc 1 769 10 view .LVU177
 739 0052 0020     		movs	r0, #0
 740              	.LVL42:
 769:Src/util.c    ****     #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 741              		.loc 1 769 10 view .LVU178
 742 0054 F8E7     		b	.L43
 743              	.L53:
 744 0056 00BF     		.align	2
 745              	.L52:
 746 0058 1F85EB51 		.word	1374389535
 747              		.cfi_endproc
ARM GAS  /tmp/cchLDBog.s 			page 28


 748              	.LFE81:
 750              		.section	.rodata.Input_Init.str1.4,"aMS",%progbits,1
 751              		.align	2
 752              	.LC0:
 753 0000 4C696D69 		.ascii	"Limits Input1: TYP:%i MIN:%i MID:%i MAX:%i\015\012L"
 753      74732049 
 753      6E707574 
 753      313A2054 
 753      59503A25 
 754 002d 696D6974 		.ascii	"imits Input2: TYP:%i MIN:%i MID:%i MAX:%i\015\012\000"
 754      7320496E 
 754      70757432 
 754      3A205459 
 754      503A2569 
 755              		.section	.text.Input_Init,"ax",%progbits
 756              		.align	1
 757              		.global	Input_Init
 758              		.syntax unified
 759              		.thumb
 760              		.thumb_func
 762              	Input_Init:
 763              	.LFB68:
 276:Src/util.c    ****   #if defined(CONTROL_PPM_LEFT) || defined(CONTROL_PPM_RIGHT)
 764              		.loc 1 276 23 is_stmt 1 view -0
 765              		.cfi_startproc
 766              		@ args = 0, pretend = 0, frame = 8
 767              		@ frame_needed = 0, uses_anonymous_args = 0
 768 0000 2DE9F047 		push	{r4, r5, r6, r7, r8, r9, r10, lr}
 769              	.LCFI6:
 770              		.cfi_def_cfa_offset 32
 771              		.cfi_offset 4, -32
 772              		.cfi_offset 5, -28
 773              		.cfi_offset 6, -24
 774              		.cfi_offset 7, -20
 775              		.cfi_offset 8, -16
 776              		.cfi_offset 9, -12
 777              		.cfi_offset 10, -8
 778              		.cfi_offset 14, -4
 779 0004 88B0     		sub	sp, sp, #32
 780              	.LCFI7:
 781              		.cfi_def_cfa_offset 64
 289:Src/util.c    ****   #endif
 782              		.loc 1 289 5 view .LVU180
 783 0006 FFF7FEFF 		bl	UART3_Init
 784              	.LVL43:
 296:Src/util.c    ****     UART_DisableRxErrors(&huart3);
 785              		.loc 1 296 5 view .LVU181
 786 000a 844C     		ldr	r4, .L69
 787 000c 4022     		movs	r2, #64
 788 000e 8449     		ldr	r1, .L69+4
 789 0010 2046     		mov	r0, r4
 790 0012 FFF7FEFF 		bl	HAL_UART_Receive_DMA
 791              	.LVL44:
 297:Src/util.c    ****   #endif
 792              		.loc 1 297 5 view .LVU182
 793 0016 2046     		mov	r0, r4
 794 0018 FFF7FEFF 		bl	UART_DisableRxErrors
ARM GAS  /tmp/cchLDBog.s 			page 29


 795              	.LVL45:
 301:Src/util.c    ****     HAL_FLASH_Unlock();
 796              		.loc 1 301 5 view .LVU183
 302:Src/util.c    ****     EE_Init();            /* EEPROM Init */
 797              		.loc 1 302 5 view .LVU184
 798 001c FFF7FEFF 		bl	HAL_FLASH_Unlock
 799              	.LVL46:
 303:Src/util.c    ****     EE_ReadVariable(VirtAddVarTab[0], &writeCheck);
 800              		.loc 1 303 5 view .LVU185
 801 0020 FFF7FEFF 		bl	EE_Init
 802              	.LVL47:
 304:Src/util.c    ****     if (writeCheck == FLASH_WRITE_KEY) {
 803              		.loc 1 304 5 view .LVU186
 804 0024 0DF11E01 		add	r1, sp, #30
 805 0028 7E4B     		ldr	r3, .L69+8
 806 002a 1888     		ldrh	r0, [r3]
 807 002c FFF7FEFF 		bl	EE_ReadVariable
 808              	.LVL48:
 305:Src/util.c    ****       #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 809              		.loc 1 305 5 view .LVU187
 305:Src/util.c    ****       #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 810              		.loc 1 305 20 is_stmt 0 view .LVU188
 811 0030 BDF81E20 		ldrh	r2, [sp, #30]
 305:Src/util.c    ****       #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 812              		.loc 1 305 8 view .LVU189
 813 0034 41F20203 		movw	r3, #4098
 814 0038 9A42     		cmp	r2, r3
 815 003a 01D0     		beq	.L66
 816              	.LBB5:
 331:Src/util.c    ****         if (input1[i].typDef == 3) {  // If Input type defined is 3 (auto), identify the input type
 817              		.loc 1 331 20 view .LVU190
 818 003c 0025     		movs	r5, #0
 819 003e CBE0     		b	.L55
 820              	.L66:
 821              	.LBE5:
 310:Src/util.c    ****       EE_ReadVariable(VirtAddVarTab[2] , &readVal); rtP_Left.n_max = rtP_Right.n_max = (int16_t)rea
 822              		.loc 1 310 7 is_stmt 1 view .LVU191
 823 0040 784E     		ldr	r6, .L69+8
 824 0042 07A9     		add	r1, sp, #28
 825 0044 7088     		ldrh	r0, [r6, #2]
 826 0046 FFF7FEFF 		bl	EE_ReadVariable
 827              	.LVL49:
 310:Src/util.c    ****       EE_ReadVariable(VirtAddVarTab[2] , &readVal); rtP_Left.n_max = rtP_Right.n_max = (int16_t)rea
 828              		.loc 1 310 53 discriminator 1 view .LVU192
 310:Src/util.c    ****       EE_ReadVariable(VirtAddVarTab[2] , &readVal); rtP_Left.n_max = rtP_Right.n_max = (int16_t)rea
 829              		.loc 1 310 88 is_stmt 0 discriminator 1 view .LVU193
 830 004a BDF91C30 		ldrsh	r3, [sp, #28]
 310:Src/util.c    ****       EE_ReadVariable(VirtAddVarTab[2] , &readVal); rtP_Left.n_max = rtP_Right.n_max = (int16_t)rea
 831              		.loc 1 310 86 discriminator 1 view .LVU194
 832 004e 764D     		ldr	r5, .L69+12
 833 0050 A5F8CE30 		strh	r3, [r5, #206]	@ movhi
 310:Src/util.c    ****       EE_ReadVariable(VirtAddVarTab[2] , &readVal); rtP_Left.n_max = rtP_Right.n_max = (int16_t)rea
 834              		.loc 1 310 68 discriminator 1 view .LVU195
 835 0054 754C     		ldr	r4, .L69+16
 836 0056 A4F8CE30 		strh	r3, [r4, #206]	@ movhi
 311:Src/util.c    ****       for (uint8_t i=0; i<INPUTS_NR; i++) {
 837              		.loc 1 311 7 is_stmt 1 view .LVU196
ARM GAS  /tmp/cchLDBog.s 			page 30


 838 005a 07A9     		add	r1, sp, #28
 839 005c B088     		ldrh	r0, [r6, #4]
 840 005e FFF7FEFF 		bl	EE_ReadVariable
 841              	.LVL50:
 311:Src/util.c    ****       for (uint8_t i=0; i<INPUTS_NR; i++) {
 842              		.loc 1 311 53 discriminator 1 view .LVU197
 311:Src/util.c    ****       for (uint8_t i=0; i<INPUTS_NR; i++) {
 843              		.loc 1 311 88 is_stmt 0 discriminator 1 view .LVU198
 844 0062 BDF91C30 		ldrsh	r3, [sp, #28]
 311:Src/util.c    ****       for (uint8_t i=0; i<INPUTS_NR; i++) {
 845              		.loc 1 311 86 discriminator 1 view .LVU199
 846 0066 A5F8DA30 		strh	r3, [r5, #218]	@ movhi
 311:Src/util.c    ****       for (uint8_t i=0; i<INPUTS_NR; i++) {
 847              		.loc 1 311 68 discriminator 1 view .LVU200
 848 006a A4F8DA30 		strh	r3, [r4, #218]	@ movhi
 312:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 3+8*i] , &readVal); input1[i].typ = (uint8_t)readVal;
 849              		.loc 1 312 7 is_stmt 1 view .LVU201
 850              	.LBB6:
 312:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 3+8*i] , &readVal); input1[i].typ = (uint8_t)readVal;
 851              		.loc 1 312 12 view .LVU202
 852              	.LVL51:
 312:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 3+8*i] , &readVal); input1[i].typ = (uint8_t)readVal;
 853              		.loc 1 312 20 is_stmt 0 view .LVU203
 854 006e 0026     		movs	r6, #0
 855              	.LVL52:
 856              	.L56:
 312:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 3+8*i] , &readVal); input1[i].typ = (uint8_t)readVal;
 857              		.loc 1 312 26 is_stmt 1 discriminator 1 view .LVU204
 858 0070 002E     		cmp	r6, #0
 859 0072 40F0B380 		bne	.L58
 313:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 4+8*i] , &readVal); input1[i].min = (int16_t)readVal;
 860              		.loc 1 313 9 view .LVU205
 313:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 4+8*i] , &readVal); input1[i].min = (int16_t)readVal;
 861              		.loc 1 313 43 is_stmt 0 view .LVU206
 862 0076 F400     		lsls	r4, r6, #3
 313:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 4+8*i] , &readVal); input1[i].min = (int16_t)readVal;
 863              		.loc 1 313 41 view .LVU207
 864 0078 E31C     		adds	r3, r4, #3
 313:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 4+8*i] , &readVal); input1[i].min = (int16_t)readVal;
 865              		.loc 1 313 9 view .LVU208
 866 007a DFF8A881 		ldr	r8, .L69+8
 867 007e 07A9     		add	r1, sp, #28
 868 0080 38F81300 		ldrh	r0, [r8, r3, lsl #1]
 869 0084 FFF7FEFF 		bl	EE_ReadVariable
 870              	.LVL53:
 313:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 4+8*i] , &readVal); input1[i].min = (int16_t)readVal;
 871              		.loc 1 313 60 is_stmt 1 discriminator 1 view .LVU209
 313:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 4+8*i] , &readVal); input1[i].min = (int16_t)readVal;
 872              		.loc 1 313 76 is_stmt 0 discriminator 1 view .LVU210
 873 0088 9DF81C30 		ldrb	r3, [sp, #28]	@ zero_extendqisi2
 313:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 4+8*i] , &readVal); input1[i].min = (int16_t)readVal;
 874              		.loc 1 313 74 discriminator 1 view .LVU211
 875 008c A21B     		subs	r2, r4, r6
 876 008e 684D     		ldr	r5, .L69+20
 877 0090 05EB4205 		add	r5, r5, r2, lsl #1
 878 0094 2B71     		strb	r3, [r5, #4]
 314:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 5+8*i] , &readVal); input1[i].mid = (int16_t)readVal;
ARM GAS  /tmp/cchLDBog.s 			page 31


 879              		.loc 1 314 9 is_stmt 1 view .LVU212
 314:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 5+8*i] , &readVal); input1[i].mid = (int16_t)readVal;
 880              		.loc 1 314 41 is_stmt 0 view .LVU213
 881 0096 231D     		adds	r3, r4, #4
 314:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 5+8*i] , &readVal); input1[i].mid = (int16_t)readVal;
 882              		.loc 1 314 9 view .LVU214
 883 0098 07A9     		add	r1, sp, #28
 884 009a 38F81300 		ldrh	r0, [r8, r3, lsl #1]
 885 009e FFF7FEFF 		bl	EE_ReadVariable
 886              	.LVL54:
 314:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 5+8*i] , &readVal); input1[i].mid = (int16_t)readVal;
 887              		.loc 1 314 60 is_stmt 1 discriminator 1 view .LVU215
 314:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 5+8*i] , &readVal); input1[i].mid = (int16_t)readVal;
 888              		.loc 1 314 76 is_stmt 0 discriminator 1 view .LVU216
 889 00a2 BDF91C30 		ldrsh	r3, [sp, #28]
 314:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 5+8*i] , &readVal); input1[i].mid = (int16_t)readVal;
 890              		.loc 1 314 74 discriminator 1 view .LVU217
 891 00a6 EB80     		strh	r3, [r5, #6]	@ movhi
 315:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 6+8*i] , &readVal); input1[i].max = (int16_t)readVal;
 892              		.loc 1 315 9 is_stmt 1 view .LVU218
 315:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 6+8*i] , &readVal); input1[i].max = (int16_t)readVal;
 893              		.loc 1 315 41 is_stmt 0 view .LVU219
 894 00a8 631D     		adds	r3, r4, #5
 315:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 6+8*i] , &readVal); input1[i].max = (int16_t)readVal;
 895              		.loc 1 315 9 view .LVU220
 896 00aa 07A9     		add	r1, sp, #28
 897 00ac 38F81300 		ldrh	r0, [r8, r3, lsl #1]
 898 00b0 FFF7FEFF 		bl	EE_ReadVariable
 899              	.LVL55:
 315:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 6+8*i] , &readVal); input1[i].max = (int16_t)readVal;
 900              		.loc 1 315 60 is_stmt 1 discriminator 1 view .LVU221
 315:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 6+8*i] , &readVal); input1[i].max = (int16_t)readVal;
 901              		.loc 1 315 76 is_stmt 0 discriminator 1 view .LVU222
 902 00b4 BDF91C30 		ldrsh	r3, [sp, #28]
 315:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 6+8*i] , &readVal); input1[i].max = (int16_t)readVal;
 903              		.loc 1 315 74 discriminator 1 view .LVU223
 904 00b8 2B81     		strh	r3, [r5, #8]	@ movhi
 316:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 7+8*i] , &readVal); input2[i].typ = (uint8_t)readVal;
 905              		.loc 1 316 9 is_stmt 1 view .LVU224
 316:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 7+8*i] , &readVal); input2[i].typ = (uint8_t)readVal;
 906              		.loc 1 316 41 is_stmt 0 view .LVU225
 907 00ba A31D     		adds	r3, r4, #6
 316:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 7+8*i] , &readVal); input2[i].typ = (uint8_t)readVal;
 908              		.loc 1 316 9 view .LVU226
 909 00bc 07A9     		add	r1, sp, #28
 910 00be 38F81300 		ldrh	r0, [r8, r3, lsl #1]
 911 00c2 FFF7FEFF 		bl	EE_ReadVariable
 912              	.LVL56:
 316:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 7+8*i] , &readVal); input2[i].typ = (uint8_t)readVal;
 913              		.loc 1 316 60 is_stmt 1 discriminator 1 view .LVU227
 316:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 7+8*i] , &readVal); input2[i].typ = (uint8_t)readVal;
 914              		.loc 1 316 76 is_stmt 0 discriminator 1 view .LVU228
 915 00c6 BDF91C30 		ldrsh	r3, [sp, #28]
 316:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 7+8*i] , &readVal); input2[i].typ = (uint8_t)readVal;
 916              		.loc 1 316 74 discriminator 1 view .LVU229
 917 00ca 6B81     		strh	r3, [r5, #10]	@ movhi
 317:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 8+8*i] , &readVal); input2[i].min = (int16_t)readVal;
ARM GAS  /tmp/cchLDBog.s 			page 32


 918              		.loc 1 317 9 is_stmt 1 view .LVU230
 317:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 8+8*i] , &readVal); input2[i].min = (int16_t)readVal;
 919              		.loc 1 317 41 is_stmt 0 view .LVU231
 920 00cc E31D     		adds	r3, r4, #7
 317:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 8+8*i] , &readVal); input2[i].min = (int16_t)readVal;
 921              		.loc 1 317 9 view .LVU232
 922 00ce 07A9     		add	r1, sp, #28
 923 00d0 38F81300 		ldrh	r0, [r8, r3, lsl #1]
 924 00d4 FFF7FEFF 		bl	EE_ReadVariable
 925              	.LVL57:
 317:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 8+8*i] , &readVal); input2[i].min = (int16_t)readVal;
 926              		.loc 1 317 60 is_stmt 1 discriminator 1 view .LVU233
 317:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 8+8*i] , &readVal); input2[i].min = (int16_t)readVal;
 927              		.loc 1 317 76 is_stmt 0 discriminator 1 view .LVU234
 928 00d8 9DF81C30 		ldrb	r3, [sp, #28]	@ zero_extendqisi2
 317:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 8+8*i] , &readVal); input2[i].min = (int16_t)readVal;
 929              		.loc 1 317 74 discriminator 1 view .LVU235
 930 00dc DFF85491 		ldr	r9, .L69+24
 931 00e0 A71B     		subs	r7, r4, r6
 932 00e2 09EB4707 		add	r7, r9, r7, lsl #1
 933 00e6 3B71     		strb	r3, [r7, #4]
 318:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 9+8*i] , &readVal); input2[i].mid = (int16_t)readVal;
 934              		.loc 1 318 9 is_stmt 1 view .LVU236
 318:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 9+8*i] , &readVal); input2[i].mid = (int16_t)readVal;
 935              		.loc 1 318 41 is_stmt 0 view .LVU237
 936 00e8 06F1010A 		add	r10, r6, #1
 937 00ec 4FEACA03 		lsl	r3, r10, #3
 318:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 9+8*i] , &readVal); input2[i].mid = (int16_t)readVal;
 938              		.loc 1 318 9 view .LVU238
 939 00f0 07A9     		add	r1, sp, #28
 940 00f2 38F81300 		ldrh	r0, [r8, r3, lsl #1]
 941 00f6 FFF7FEFF 		bl	EE_ReadVariable
 942              	.LVL58:
 318:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 9+8*i] , &readVal); input2[i].mid = (int16_t)readVal;
 943              		.loc 1 318 60 is_stmt 1 discriminator 1 view .LVU239
 318:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 9+8*i] , &readVal); input2[i].mid = (int16_t)readVal;
 944              		.loc 1 318 76 is_stmt 0 discriminator 1 view .LVU240
 945 00fa BDF91C30 		ldrsh	r3, [sp, #28]
 318:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 9+8*i] , &readVal); input2[i].mid = (int16_t)readVal;
 946              		.loc 1 318 74 discriminator 1 view .LVU241
 947 00fe FB80     		strh	r3, [r7, #6]	@ movhi
 319:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[10+8*i] , &readVal); input2[i].max = (int16_t)readVal;
 948              		.loc 1 319 9 is_stmt 1 view .LVU242
 319:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[10+8*i] , &readVal); input2[i].max = (int16_t)readVal;
 949              		.loc 1 319 41 is_stmt 0 view .LVU243
 950 0100 04F10903 		add	r3, r4, #9
 319:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[10+8*i] , &readVal); input2[i].max = (int16_t)readVal;
 951              		.loc 1 319 9 view .LVU244
 952 0104 07A9     		add	r1, sp, #28
 953 0106 38F81300 		ldrh	r0, [r8, r3, lsl #1]
 954 010a FFF7FEFF 		bl	EE_ReadVariable
 955              	.LVL59:
 319:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[10+8*i] , &readVal); input2[i].max = (int16_t)readVal;
 956              		.loc 1 319 60 is_stmt 1 discriminator 1 view .LVU245
 319:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[10+8*i] , &readVal); input2[i].max = (int16_t)readVal;
 957              		.loc 1 319 76 is_stmt 0 discriminator 1 view .LVU246
 958 010e BDF91C30 		ldrsh	r3, [sp, #28]
ARM GAS  /tmp/cchLDBog.s 			page 33


 319:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[10+8*i] , &readVal); input2[i].max = (int16_t)readVal;
 959              		.loc 1 319 74 discriminator 1 view .LVU247
 960 0112 3B81     		strh	r3, [r7, #8]	@ movhi
 320:Src/util.c    ****       
 961              		.loc 1 320 9 is_stmt 1 view .LVU248
 320:Src/util.c    ****       
 962              		.loc 1 320 41 is_stmt 0 view .LVU249
 963 0114 04F10A03 		add	r3, r4, #10
 320:Src/util.c    ****       
 964              		.loc 1 320 9 view .LVU250
 965 0118 07A9     		add	r1, sp, #28
 966 011a 38F81300 		ldrh	r0, [r8, r3, lsl #1]
 967 011e FFF7FEFF 		bl	EE_ReadVariable
 968              	.LVL60:
 320:Src/util.c    ****       
 969              		.loc 1 320 60 is_stmt 1 discriminator 1 view .LVU251
 320:Src/util.c    ****       
 970              		.loc 1 320 76 is_stmt 0 discriminator 1 view .LVU252
 971 0122 BDF91C30 		ldrsh	r3, [sp, #28]
 320:Src/util.c    ****       
 972              		.loc 1 320 74 discriminator 1 view .LVU253
 973 0126 7B81     		strh	r3, [r7, #10]	@ movhi
 322:Src/util.c    ****           input1[i].typ, input1[i].min, input1[i].mid, input1[i].max,
 974              		.loc 1 322 9 is_stmt 1 view .LVU254
 323:Src/util.c    ****           input2[i].typ, input2[i].min, input2[i].mid, input2[i].max);
 975              		.loc 1 323 65 is_stmt 0 view .LVU255
 976 0128 B5F90A20 		ldrsh	r2, [r5, #10]
 324:Src/util.c    ****       }
 977              		.loc 1 324 20 view .LVU256
 978 012c 3979     		ldrb	r1, [r7, #4]	@ zero_extendqisi2
 324:Src/util.c    ****       }
 979              		.loc 1 324 35 view .LVU257
 980 012e B7F90600 		ldrsh	r0, [r7, #6]
 324:Src/util.c    ****       }
 981              		.loc 1 324 50 view .LVU258
 982 0132 B7F90840 		ldrsh	r4, [r7, #8]
 322:Src/util.c    ****           input1[i].typ, input1[i].min, input1[i].mid, input1[i].max,
 983              		.loc 1 322 9 view .LVU259
 984 0136 0493     		str	r3, [sp, #16]
 985 0138 0394     		str	r4, [sp, #12]
 986 013a 0290     		str	r0, [sp, #8]
 987 013c 0191     		str	r1, [sp, #4]
 988 013e 0092     		str	r2, [sp]
 989 0140 B5F90830 		ldrsh	r3, [r5, #8]
 990 0144 B5F90620 		ldrsh	r2, [r5, #6]
 991 0148 2979     		ldrb	r1, [r5, #4]	@ zero_extendqisi2
 992 014a 3B48     		ldr	r0, .L69+28
 993 014c FFF7FEFF 		bl	printf
 994              	.LVL61:
 312:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 3+8*i] , &readVal); input1[i].typ = (uint8_t)readVal;
 995              		.loc 1 312 39 is_stmt 1 discriminator 3 view .LVU260
 996 0150 5FFA8AF6 		uxtb	r6, r10
 997              	.LVL62:
 312:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 3+8*i] , &readVal); input1[i].typ = (uint8_t)readVal;
 998              		.loc 1 312 39 is_stmt 0 discriminator 3 view .LVU261
 999 0154 8CE7     		b	.L56
 1000              	.LVL63:
ARM GAS  /tmp/cchLDBog.s 			page 34


 1001              	.L63:
 312:Src/util.c    ****         EE_ReadVariable(VirtAddVarTab[ 3+8*i] , &readVal); input1[i].typ = (uint8_t)readVal;
 1002              		.loc 1 312 39 discriminator 3 view .LVU262
 1003              	.LBE6:
 1004              	.LBB7:
 332:Src/util.c    ****           input1[i].typ = checkInputType(input1[i].min, input1[i].mid, input1[i].max);
 1005              		.loc 1 332 9 is_stmt 1 view .LVU263
 332:Src/util.c    ****           input1[i].typ = checkInputType(input1[i].min, input1[i].mid, input1[i].max);
 1006              		.loc 1 332 22 is_stmt 0 view .LVU264
 1007 0156 2C46     		mov	r4, r5
 1008 0158 C5EBC502 		rsb	r2, r5, r5, lsl #3
 1009 015c 344B     		ldr	r3, .L69+20
 1010 015e 03EB4203 		add	r3, r3, r2, lsl #1
 1011 0162 5B79     		ldrb	r3, [r3, #5]	@ zero_extendqisi2
 332:Src/util.c    ****           input1[i].typ = checkInputType(input1[i].min, input1[i].mid, input1[i].max);
 1012              		.loc 1 332 12 view .LVU265
 1013 0164 032B     		cmp	r3, #3
 1014 0166 3ED0     		beq	.L67
 335:Src/util.c    ****         }
 1015              		.loc 1 335 11 is_stmt 1 view .LVU266
 335:Src/util.c    ****         }
 1016              		.loc 1 335 25 is_stmt 0 view .LVU267
 1017 0168 C5EBC501 		rsb	r1, r5, r5, lsl #3
 1018 016c 304A     		ldr	r2, .L69+20
 1019 016e 02EB4102 		add	r2, r2, r1, lsl #1
 1020 0172 1371     		strb	r3, [r2, #4]
 1021              	.L60:
 337:Src/util.c    ****           input2[i].typ = checkInputType(input2[i].min, input2[i].mid, input2[i].max);
 1022              		.loc 1 337 9 is_stmt 1 view .LVU268
 337:Src/util.c    ****           input2[i].typ = checkInputType(input2[i].min, input2[i].mid, input2[i].max);
 1023              		.loc 1 337 22 is_stmt 0 view .LVU269
 1024 0174 C4EBC402 		rsb	r2, r4, r4, lsl #3
 1025 0178 2E4B     		ldr	r3, .L69+24
 1026 017a 03EB4203 		add	r3, r3, r2, lsl #1
 1027 017e 5B79     		ldrb	r3, [r3, #5]	@ zero_extendqisi2
 337:Src/util.c    ****           input2[i].typ = checkInputType(input2[i].min, input2[i].mid, input2[i].max);
 1028              		.loc 1 337 12 view .LVU270
 1029 0180 032B     		cmp	r3, #3
 1030 0182 3DD0     		beq	.L68
 340:Src/util.c    ****         }
 1031              		.loc 1 340 11 is_stmt 1 view .LVU271
 340:Src/util.c    ****         }
 1032              		.loc 1 340 25 is_stmt 0 view .LVU272
 1033 0184 C4EBC401 		rsb	r1, r4, r4, lsl #3
 1034 0188 2A4A     		ldr	r2, .L69+24
 1035 018a 02EB4102 		add	r2, r2, r1, lsl #1
 1036 018e 1371     		strb	r3, [r2, #4]
 1037              	.L62:
 342:Src/util.c    ****           input1[i].typ, input1[i].min, input1[i].mid, input1[i].max,
 1038              		.loc 1 342 9 is_stmt 1 view .LVU273
 343:Src/util.c    ****           input2[i].typ, input2[i].min, input2[i].mid, input2[i].max);
 1039              		.loc 1 343 20 is_stmt 0 view .LVU274
 1040 0190 C4EBC403 		rsb	r3, r4, r4, lsl #3
 1041 0194 2649     		ldr	r1, .L69+20
 1042 0196 01EB4301 		add	r1, r1, r3, lsl #1
 343:Src/util.c    ****           input2[i].typ, input2[i].min, input2[i].mid, input2[i].max);
 1043              		.loc 1 343 65 view .LVU275
ARM GAS  /tmp/cchLDBog.s 			page 35


 1044 019a B1F90A00 		ldrsh	r0, [r1, #10]
 344:Src/util.c    ****       }
 1045              		.loc 1 344 20 view .LVU276
 1046 019e 254A     		ldr	r2, .L69+24
 1047 01a0 02EB4303 		add	r3, r2, r3, lsl #1
 1048 01a4 1E79     		ldrb	r6, [r3, #4]	@ zero_extendqisi2
 344:Src/util.c    ****       }
 1049              		.loc 1 344 35 view .LVU277
 1050 01a6 B3F90670 		ldrsh	r7, [r3, #6]
 344:Src/util.c    ****       }
 1051              		.loc 1 344 50 view .LVU278
 1052 01aa B3F90830 		ldrsh	r3, [r3, #8]
 344:Src/util.c    ****       }
 1053              		.loc 1 344 65 view .LVU279
 1054 01ae C4EBC404 		rsb	r4, r4, r4, lsl #3
 1055 01b2 02EB4402 		add	r2, r2, r4, lsl #1
 1056 01b6 B2F90A20 		ldrsh	r2, [r2, #10]
 342:Src/util.c    ****           input1[i].typ, input1[i].min, input1[i].mid, input1[i].max,
 1057              		.loc 1 342 9 view .LVU280
 1058 01ba 0492     		str	r2, [sp, #16]
 1059 01bc 0393     		str	r3, [sp, #12]
 1060 01be 0297     		str	r7, [sp, #8]
 1061 01c0 0196     		str	r6, [sp, #4]
 1062 01c2 0090     		str	r0, [sp]
 1063 01c4 B1F90830 		ldrsh	r3, [r1, #8]
 1064 01c8 B1F90620 		ldrsh	r2, [r1, #6]
 1065 01cc 0979     		ldrb	r1, [r1, #4]	@ zero_extendqisi2
 1066 01ce 1A48     		ldr	r0, .L69+28
 1067 01d0 FFF7FEFF 		bl	printf
 1068              	.LVL64:
 331:Src/util.c    ****         if (input1[i].typDef == 3) {  // If Input type defined is 3 (auto), identify the input type
 1069              		.loc 1 331 39 is_stmt 1 discriminator 2 view .LVU281
 1070 01d4 0135     		adds	r5, r5, #1
 1071              	.LVL65:
 331:Src/util.c    ****         if (input1[i].typDef == 3) {  // If Input type defined is 3 (auto), identify the input type
 1072              		.loc 1 331 39 is_stmt 0 discriminator 2 view .LVU282
 1073 01d6 EDB2     		uxtb	r5, r5
 1074              	.LVL66:
 1075              	.L55:
 331:Src/util.c    ****         if (input1[i].typDef == 3) {  // If Input type defined is 3 (auto), identify the input type
 1076              		.loc 1 331 26 is_stmt 1 discriminator 1 view .LVU283
 1077 01d8 002D     		cmp	r5, #0
 1078 01da BCD0     		beq	.L63
 1079              	.LVL67:
 1080              	.L58:
 331:Src/util.c    ****         if (input1[i].typDef == 3) {  // If Input type defined is 3 (auto), identify the input type
 1081              		.loc 1 331 26 is_stmt 0 discriminator 1 view .LVU284
 1082              	.LBE7:
 347:Src/util.c    ****   #endif
 1083              		.loc 1 347 5 is_stmt 1 view .LVU285
 1084 01dc FFF7FEFF 		bl	HAL_FLASH_Lock
 1085              	.LVL68:
 399:Src/util.c    **** 
 1086              		.loc 1 399 1 is_stmt 0 view .LVU286
 1087 01e0 08B0     		add	sp, sp, #32
 1088              	.LCFI8:
 1089              		.cfi_remember_state
ARM GAS  /tmp/cchLDBog.s 			page 36


 1090              		.cfi_def_cfa_offset 32
 1091              		@ sp needed
 1092 01e2 BDE8F087 		pop	{r4, r5, r6, r7, r8, r9, r10, pc}
 1093              	.LVL69:
 1094              	.L67:
 1095              	.LCFI9:
 1096              		.cfi_restore_state
 1097              	.LBB8:
 333:Src/util.c    ****         } else {
 1098              		.loc 1 333 11 is_stmt 1 view .LVU287
 333:Src/util.c    ****         } else {
 1099              		.loc 1 333 27 is_stmt 0 view .LVU288
 1100 01e6 124E     		ldr	r6, .L69+20
 1101 01e8 06EB4206 		add	r6, r6, r2, lsl #1
 1102 01ec B6F90A20 		ldrsh	r2, [r6, #10]
 1103 01f0 B6F90810 		ldrsh	r1, [r6, #8]
 1104 01f4 B6F90600 		ldrsh	r0, [r6, #6]
 1105 01f8 FFF7FEFF 		bl	checkInputType
 1106              	.LVL70:
 333:Src/util.c    ****         } else {
 1107              		.loc 1 333 25 discriminator 1 view .LVU289
 1108 01fc 3071     		strb	r0, [r6, #4]
 1109 01fe B9E7     		b	.L60
 1110              	.L68:
 338:Src/util.c    ****         } else {
 1111              		.loc 1 338 11 is_stmt 1 view .LVU290
 338:Src/util.c    ****         } else {
 1112              		.loc 1 338 27 is_stmt 0 view .LVU291
 1113 0200 0C4E     		ldr	r6, .L69+24
 1114 0202 06EB4206 		add	r6, r6, r2, lsl #1
 1115 0206 B6F90A20 		ldrsh	r2, [r6, #10]
 1116 020a B6F90810 		ldrsh	r1, [r6, #8]
 1117 020e B6F90600 		ldrsh	r0, [r6, #6]
 1118 0212 FFF7FEFF 		bl	checkInputType
 1119              	.LVL71:
 338:Src/util.c    ****         } else {
 1120              		.loc 1 338 25 discriminator 1 view .LVU292
 1121 0216 3071     		strb	r0, [r6, #4]
 1122 0218 BAE7     		b	.L62
 1123              	.L70:
 1124 021a 00BF     		.align	2
 1125              	.L69:
 1126 021c 00000000 		.word	huart3
 1127 0220 00000000 		.word	rx_buffer_R
 1128 0224 00000000 		.word	VirtAddVarTab
 1129 0228 00000000 		.word	rtP_Right
 1130 022c 00000000 		.word	rtP_Left
 1131 0230 00000000 		.word	input1
 1132 0234 00000000 		.word	input2
 1133 0238 00000000 		.word	.LC0
 1134              	.LBE8:
 1135              		.cfi_endproc
 1136              	.LFE68:
 1138              		.section	.text.calcInputCmd,"ax",%progbits
 1139              		.align	1
 1140              		.global	calcInputCmd
 1141              		.syntax unified
ARM GAS  /tmp/cchLDBog.s 			page 37


 1142              		.thumb
 1143              		.thumb_func
 1145              	calcInputCmd:
 1146              	.LVL72:
 1147              	.LFB82:
 798:Src/util.c    **** 
 799:Src/util.c    **** 
 800:Src/util.c    **** 
 801:Src/util.c    **** /* =========================== Input Functions =========================== */
 802:Src/util.c    **** 
 803:Src/util.c    ****  /*
 804:Src/util.c    ****  * Calculate Input Command
 805:Src/util.c    ****  * This function realizes dead-band around 0 and scales the input between [out_min, out_max]
 806:Src/util.c    ****  */
 807:Src/util.c    **** void calcInputCmd(InputStruct *in, int16_t out_min, int16_t out_max) {
 1148              		.loc 1 807 70 is_stmt 1 view -0
 1149              		.cfi_startproc
 1150              		@ args = 0, pretend = 0, frame = 0
 1151              		@ frame_needed = 0, uses_anonymous_args = 0
 808:Src/util.c    ****   switch (in->typ){
 1152              		.loc 1 808 3 view .LVU294
 1153              		.loc 1 808 13 is_stmt 0 view .LVU295
 1154 0000 0379     		ldrb	r3, [r0, #4]	@ zero_extendqisi2
 1155              		.loc 1 808 3 view .LVU296
 1156 0002 012B     		cmp	r3, #1
 1157 0004 04D0     		beq	.L72
 1158 0006 022B     		cmp	r3, #2
 1159 0008 17D0     		beq	.L73
 809:Src/util.c    ****     case 1: // Input is a normal pot
 810:Src/util.c    ****       in->cmd = CLAMP(MAP(in->raw, in->min, in->max, 0, out_max), 0, out_max);
 811:Src/util.c    ****       break;
 812:Src/util.c    ****     case 2: // Input is a mid resting pot
 813:Src/util.c    ****       if( in->raw > in->mid - in->dband && in->raw < in->mid + in->dband ) {
 814:Src/util.c    ****         in->cmd = 0;
 815:Src/util.c    ****       } else if(in->raw > in->mid) {
 816:Src/util.c    ****         in->cmd = CLAMP(MAP(in->raw, in->mid + in->dband, in->max, 0, out_max), 0, out_max);
 817:Src/util.c    ****       } else {
 818:Src/util.c    ****         in->cmd = CLAMP(MAP(in->raw, in->mid - in->dband, in->min, 0, out_min), out_min, 0);
 819:Src/util.c    ****       }
 820:Src/util.c    ****       break;
 821:Src/util.c    ****     default: // Input is ignored
 822:Src/util.c    ****       in->cmd = 0;
 1160              		.loc 1 822 7 is_stmt 1 view .LVU297
 1161              		.loc 1 822 15 is_stmt 0 view .LVU298
 1162 000a 0023     		movs	r3, #0
 1163 000c 4380     		strh	r3, [r0, #2]	@ movhi
 823:Src/util.c    ****       break;
 1164              		.loc 1 823 7 is_stmt 1 view .LVU299
 1165 000e 7047     		bx	lr
 1166              	.L72:
 810:Src/util.c    ****       break;
 1167              		.loc 1 810 7 view .LVU300
 810:Src/util.c    ****       break;
 1168              		.loc 1 810 17 is_stmt 0 view .LVU301
 1169 0010 B0F90030 		ldrsh	r3, [r0]
 1170 0014 B0F906C0 		ldrsh	ip, [r0, #6]
 1171 0018 A3EB0C03 		sub	r3, r3, ip
ARM GAS  /tmp/cchLDBog.s 			page 38


 1172 001c 02FB03F3 		mul	r3, r2, r3
 1173 0020 B0F90A10 		ldrsh	r1, [r0, #10]
 1174              	.LVL73:
 810:Src/util.c    ****       break;
 1175              		.loc 1 810 17 view .LVU302
 1176 0024 A1EB0C01 		sub	r1, r1, ip
 1177 0028 93FBF1F3 		sdiv	r3, r3, r1
 810:Src/util.c    ****       break;
 1178              		.loc 1 810 15 view .LVU303
 1179 002c 9A42     		cmp	r2, r3
 1180 002e 02DB     		blt	.L75
 810:Src/util.c    ****       break;
 1181              		.loc 1 810 17 discriminator 1 view .LVU304
 1182 0030 23EAE373 		bic	r3, r3, r3, asr #31
 810:Src/util.c    ****       break;
 1183              		.loc 1 810 15 discriminator 1 view .LVU305
 1184 0034 1AB2     		sxth	r2, r3
 1185              	.LVL74:
 1186              	.L75:
 810:Src/util.c    ****       break;
 1187              		.loc 1 810 15 discriminator 4 view .LVU306
 1188 0036 4280     		strh	r2, [r0, #2]	@ movhi
 811:Src/util.c    ****     case 2: // Input is a mid resting pot
 1189              		.loc 1 811 7 is_stmt 1 view .LVU307
 1190 0038 7047     		bx	lr
 1191              	.LVL75:
 1192              	.L73:
 807:Src/util.c    ****   switch (in->typ){
 1193              		.loc 1 807 70 is_stmt 0 view .LVU308
 1194 003a 30B5     		push	{r4, r5, lr}
 1195              	.LCFI10:
 1196              		.cfi_def_cfa_offset 12
 1197              		.cfi_offset 4, -12
 1198              		.cfi_offset 5, -8
 1199              		.cfi_offset 14, -4
 813:Src/util.c    ****         in->cmd = 0;
 1200              		.loc 1 813 7 is_stmt 1 view .LVU309
 813:Src/util.c    ****         in->cmd = 0;
 1201              		.loc 1 813 13 is_stmt 0 view .LVU310
 1202 003c B0F90030 		ldrsh	r3, [r0]
 813:Src/util.c    ****         in->cmd = 0;
 1203              		.loc 1 813 23 view .LVU311
 1204 0040 B0F908C0 		ldrsh	ip, [r0, #8]
 813:Src/util.c    ****         in->cmd = 0;
 1205              		.loc 1 813 33 view .LVU312
 1206 0044 B0F90CE0 		ldrsh	lr, [r0, #12]
 813:Src/util.c    ****         in->cmd = 0;
 1207              		.loc 1 813 29 view .LVU313
 1208 0048 ACEB0E04 		sub	r4, ip, lr
 813:Src/util.c    ****         in->cmd = 0;
 1209              		.loc 1 813 9 view .LVU314
 1210 004c A342     		cmp	r3, r4
 1211 004e 06DD     		ble	.L77
 813:Src/util.c    ****         in->cmd = 0;
 1212              		.loc 1 813 62 discriminator 1 view .LVU315
 1213 0050 0CEB0E05 		add	r5, ip, lr
 813:Src/util.c    ****         in->cmd = 0;
ARM GAS  /tmp/cchLDBog.s 			page 39


 1214              		.loc 1 813 41 discriminator 1 view .LVU316
 1215 0054 AB42     		cmp	r3, r5
 1216 0056 02DA     		bge	.L77
 814:Src/util.c    ****       } else if(in->raw > in->mid) {
 1217              		.loc 1 814 9 is_stmt 1 view .LVU317
 814:Src/util.c    ****       } else if(in->raw > in->mid) {
 1218              		.loc 1 814 17 is_stmt 0 view .LVU318
 1219 0058 0023     		movs	r3, #0
 1220 005a 4380     		strh	r3, [r0, #2]	@ movhi
 1221 005c 12E0     		b	.L71
 1222              	.L77:
 815:Src/util.c    ****         in->cmd = CLAMP(MAP(in->raw, in->mid + in->dband, in->max, 0, out_max), 0, out_max);
 1223              		.loc 1 815 14 is_stmt 1 view .LVU319
 815:Src/util.c    ****         in->cmd = CLAMP(MAP(in->raw, in->mid + in->dband, in->max, 0, out_max), 0, out_max);
 1224              		.loc 1 815 16 is_stmt 0 view .LVU320
 1225 005e 6345     		cmp	r3, ip
 1226 0060 11DD     		ble	.L78
 816:Src/util.c    ****       } else {
 1227              		.loc 1 816 9 is_stmt 1 view .LVU321
 816:Src/util.c    ****       } else {
 1228              		.loc 1 816 19 is_stmt 0 view .LVU322
 1229 0062 F444     		add	ip, ip, lr
 1230 0064 A3EB0C03 		sub	r3, r3, ip
 1231 0068 02FB03F3 		mul	r3, r2, r3
 1232 006c B0F90A10 		ldrsh	r1, [r0, #10]
 1233              	.LVL76:
 816:Src/util.c    ****       } else {
 1234              		.loc 1 816 19 view .LVU323
 1235 0070 A1EB0C01 		sub	r1, r1, ip
 1236 0074 93FBF1F3 		sdiv	r3, r3, r1
 816:Src/util.c    ****       } else {
 1237              		.loc 1 816 17 view .LVU324
 1238 0078 9A42     		cmp	r2, r3
 1239 007a 02DB     		blt	.L79
 816:Src/util.c    ****       } else {
 1240              		.loc 1 816 19 discriminator 1 view .LVU325
 1241 007c 23EAE373 		bic	r3, r3, r3, asr #31
 816:Src/util.c    ****       } else {
 1242              		.loc 1 816 17 discriminator 1 view .LVU326
 1243 0080 1AB2     		sxth	r2, r3
 1244              	.LVL77:
 1245              	.L79:
 816:Src/util.c    ****       } else {
 1246              		.loc 1 816 17 discriminator 4 view .LVU327
 1247 0082 4280     		strh	r2, [r0, #2]	@ movhi
 1248              	.L71:
 824:Src/util.c    ****   }
 825:Src/util.c    **** }
 1249              		.loc 1 825 1 view .LVU328
 1250 0084 30BD     		pop	{r4, r5, pc}
 1251              	.LVL78:
 1252              	.L78:
 818:Src/util.c    ****       }
 1253              		.loc 1 818 9 is_stmt 1 view .LVU329
 818:Src/util.c    ****       }
 1254              		.loc 1 818 19 is_stmt 0 view .LVU330
 1255 0086 1B1B     		subs	r3, r3, r4
ARM GAS  /tmp/cchLDBog.s 			page 40


 1256 0088 01FB03F3 		mul	r3, r1, r3
 1257 008c B0F90620 		ldrsh	r2, [r0, #6]
 1258              	.LVL79:
 818:Src/util.c    ****       }
 1259              		.loc 1 818 19 view .LVU331
 1260 0090 121B     		subs	r2, r2, r4
 1261 0092 93FBF2F3 		sdiv	r3, r3, r2
 818:Src/util.c    ****       }
 1262              		.loc 1 818 17 view .LVU332
 1263 0096 002B     		cmp	r3, #0
 1264 0098 02DD     		ble	.L86
 818:Src/util.c    ****       }
 1265              		.loc 1 818 17 discriminator 2 view .LVU333
 1266 009a 0021     		movs	r1, #0
 1267              	.LVL80:
 1268              	.L80:
 818:Src/util.c    ****       }
 1269              		.loc 1 818 17 discriminator 4 view .LVU334
 1270 009c 4180     		strh	r1, [r0, #2]	@ movhi
 1271 009e F1E7     		b	.L71
 1272              	.LVL81:
 1273              	.L86:
 818:Src/util.c    ****       }
 1274              		.loc 1 818 19 discriminator 1 view .LVU335
 1275 00a0 9942     		cmp	r1, r3
 1276 00a2 B8BF     		it	lt
 1277 00a4 1946     		movlt	r1, r3
 1278              	.LVL82:
 818:Src/util.c    ****       }
 1279              		.loc 1 818 17 discriminator 1 view .LVU336
 1280 00a6 09B2     		sxth	r1, r1
 1281 00a8 F8E7     		b	.L80
 1282              		.cfi_endproc
 1283              	.LFE82:
 1285              		.section	.text.readInputRaw,"ax",%progbits
 1286              		.align	1
 1287              		.global	readInputRaw
 1288              		.syntax unified
 1289              		.thumb
 1290              		.thumb_func
 1292              	readInputRaw:
 1293              	.LFB83:
 826:Src/util.c    **** 
 827:Src/util.c    ****  /*
 828:Src/util.c    ****  * Function to read the Input Raw values from various input devices
 829:Src/util.c    ****  */
 830:Src/util.c    **** void readInputRaw(void) {
 1294              		.loc 1 830 25 is_stmt 1 view -0
 1295              		.cfi_startproc
 1296              		@ args = 0, pretend = 0, frame = 0
 1297              		@ frame_needed = 0, uses_anonymous_args = 0
 1298              		@ link register save eliminated.
 831:Src/util.c    ****     #ifdef CONTROL_ADC
 832:Src/util.c    ****     if (inIdx == CONTROL_ADC) {
 833:Src/util.c    ****       #ifdef ADC_ALTERNATE_CONNECT
 834:Src/util.c    ****         input1[inIdx].raw = adc_buffer.l_rx2;
 835:Src/util.c    ****         input2[inIdx].raw = adc_buffer.l_tx2;
ARM GAS  /tmp/cchLDBog.s 			page 41


 836:Src/util.c    ****       #else
 837:Src/util.c    ****         input1[inIdx].raw = adc_buffer.l_tx2;
 838:Src/util.c    ****         input2[inIdx].raw = adc_buffer.l_rx2;
 839:Src/util.c    ****       #endif
 840:Src/util.c    ****     }
 841:Src/util.c    ****     #endif
 842:Src/util.c    **** 
 843:Src/util.c    ****     #if defined(CONTROL_NUNCHUK) || defined(SUPPORT_NUNCHUK)
 844:Src/util.c    ****     if (Nunchuk_Read() == NUNCHUK_CONNECTED) {
 845:Src/util.c    ****       if (inIdx == CONTROL_NUNCHUK) {
 846:Src/util.c    ****         input1[inIdx].raw = (nunchuk_data[0] - 127) * 8; // X axis 0-255
 847:Src/util.c    ****         input2[inIdx].raw = (nunchuk_data[1] - 128) * 8; // Y axis 0-255
 848:Src/util.c    ****       }
 849:Src/util.c    ****       #ifdef SUPPORT_BUTTONS
 850:Src/util.c    ****         button1 = (uint8_t)nunchuk_data[5] & 1;
 851:Src/util.c    ****         button2 = (uint8_t)(nunchuk_data[5] >> 1) & 1;
 852:Src/util.c    ****       #endif
 853:Src/util.c    ****     }
 854:Src/util.c    ****     #endif
 855:Src/util.c    **** 
 856:Src/util.c    ****     #if defined(CONTROL_SERIAL_USART2)
 857:Src/util.c    ****     if (inIdx == CONTROL_SERIAL_USART2) {
 858:Src/util.c    ****       #ifdef CONTROL_IBUS
 859:Src/util.c    ****         for (uint8_t i = 0; i < (IBUS_NUM_CHANNELS * 2); i+=2) {
 860:Src/util.c    ****           ibusL_captured_value[(i/2)] = CLAMP(commandL.channels[i] + (commandL.channels[i+1] << 8) 
 861:Src/util.c    ****         }
 862:Src/util.c    ****         input1[inIdx].raw = (ibusL_captured_value[0] - 500) * 2;
 863:Src/util.c    ****         input2[inIdx].raw = (ibusL_captured_value[1] - 500) * 2; 
 864:Src/util.c    ****       #else
 865:Src/util.c    ****         input1[inIdx].raw = commandL.steer;
 866:Src/util.c    ****         input2[inIdx].raw = commandL.speed;
 867:Src/util.c    ****       #endif
 868:Src/util.c    ****     }
 869:Src/util.c    ****     #endif
 870:Src/util.c    ****     #if defined(CONTROL_SERIAL_USART3)
 871:Src/util.c    ****     if (inIdx == CONTROL_SERIAL_USART3) {
 1299              		.loc 1 871 5 view .LVU338
 1300              		.loc 1 871 15 is_stmt 0 view .LVU339
 1301 0000 094B     		ldr	r3, .L89
 1302 0002 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1303              		.loc 1 871 8 view .LVU340
 1304 0004 7BB9     		cbnz	r3, .L87
 872:Src/util.c    ****       #ifdef CONTROL_IBUS
 873:Src/util.c    ****         for (uint8_t i = 0; i < (IBUS_NUM_CHANNELS * 2); i+=2) {
 874:Src/util.c    ****           ibusR_captured_value[(i/2)] = CLAMP(commandR.channels[i] + (commandR.channels[i+1] << 8) 
 875:Src/util.c    ****         }
 876:Src/util.c    ****         input1[inIdx].raw = (ibusR_captured_value[0] - 500) * 2;
 877:Src/util.c    ****         input2[inIdx].raw = (ibusR_captured_value[1] - 500) * 2; 
 878:Src/util.c    ****       #else
 879:Src/util.c    ****         input1[inIdx].raw = commandR.steer;
 1305              		.loc 1 879 9 is_stmt 1 view .LVU341
 1306              		.loc 1 879 37 is_stmt 0 view .LVU342
 1307 0006 094A     		ldr	r2, .L89+4
 1308 0008 B2F902C0 		ldrsh	ip, [r2, #2]
 1309              		.loc 1 879 27 view .LVU343
 1310 000c C3EBC300 		rsb	r0, r3, r3, lsl #3
 1311 0010 4100     		lsls	r1, r0, #1
ARM GAS  /tmp/cchLDBog.s 			page 42


 1312 0012 0748     		ldr	r0, .L89+8
 1313 0014 20F801C0 		strh	ip, [r0, r1]	@ movhi
 880:Src/util.c    ****         input2[inIdx].raw = commandR.speed;
 1314              		.loc 1 880 9 is_stmt 1 view .LVU344
 1315              		.loc 1 880 37 is_stmt 0 view .LVU345
 1316 0018 B2F90410 		ldrsh	r1, [r2, #4]
 1317              		.loc 1 880 27 view .LVU346
 1318 001c C3EBC303 		rsb	r3, r3, r3, lsl #3
 1319 0020 5A00     		lsls	r2, r3, #1
 1320 0022 044B     		ldr	r3, .L89+12
 1321 0024 9952     		strh	r1, [r3, r2]	@ movhi
 1322              	.L87:
 881:Src/util.c    ****       #endif
 882:Src/util.c    ****     }
 883:Src/util.c    ****     #endif
 884:Src/util.c    **** 
 885:Src/util.c    ****     #if defined(SIDEBOARD_SERIAL_USART2)
 886:Src/util.c    ****     if (inIdx == SIDEBOARD_SERIAL_USART2) {
 887:Src/util.c    ****       input1[inIdx].raw = Sideboard_L.cmd1;
 888:Src/util.c    ****       input2[inIdx].raw = Sideboard_L.cmd2;
 889:Src/util.c    ****     }
 890:Src/util.c    ****     #endif
 891:Src/util.c    ****     #if defined(SIDEBOARD_SERIAL_USART3)
 892:Src/util.c    ****     if (inIdx == SIDEBOARD_SERIAL_USART3) {
 893:Src/util.c    ****       input1[inIdx].raw = Sideboard_R.cmd1;
 894:Src/util.c    ****       input2[inIdx].raw = Sideboard_R.cmd2;
 895:Src/util.c    ****     }
 896:Src/util.c    ****     #endif
 897:Src/util.c    **** 
 898:Src/util.c    ****     #if defined(CONTROL_PPM_LEFT)
 899:Src/util.c    ****     if (inIdx == CONTROL_PPM_LEFT) {
 900:Src/util.c    ****       input1[inIdx].raw = (ppm_captured_value[0] - 500) * 2;
 901:Src/util.c    ****       input2[inIdx].raw = (ppm_captured_value[1] - 500) * 2;
 902:Src/util.c    ****     }
 903:Src/util.c    ****     #endif
 904:Src/util.c    ****     #if defined(CONTROL_PPM_RIGHT)
 905:Src/util.c    ****     if (inIdx == CONTROL_PPM_RIGHT) {
 906:Src/util.c    ****       input1[inIdx].raw = (ppm_captured_value[0] - 500) * 2;
 907:Src/util.c    ****       input2[inIdx].raw = (ppm_captured_value[1] - 500) * 2;
 908:Src/util.c    ****     }
 909:Src/util.c    ****     #endif
 910:Src/util.c    ****     #if (defined(CONTROL_PPM_LEFT) || defined(CONTROL_PPM_RIGHT)) && defined(SUPPORT_BUTTONS)
 911:Src/util.c    ****       button1 = ppm_captured_value[5] > 500;
 912:Src/util.c    ****       button2 = 0;
 913:Src/util.c    ****     #endif
 914:Src/util.c    **** 
 915:Src/util.c    ****     #if defined(CONTROL_PWM_LEFT)
 916:Src/util.c    ****     if (inIdx == CONTROL_PWM_LEFT) {
 917:Src/util.c    ****       input1[inIdx].raw = (pwm_captured_ch1_value - 500) * 2;
 918:Src/util.c    ****       input2[inIdx].raw = (pwm_captured_ch2_value - 500) * 2;
 919:Src/util.c    ****     }
 920:Src/util.c    ****     #endif
 921:Src/util.c    ****     #if defined(CONTROL_PWM_RIGHT)
 922:Src/util.c    ****     if (inIdx == CONTROL_PWM_RIGHT) {
 923:Src/util.c    ****       input1[inIdx].raw = (pwm_captured_ch1_value - 500) * 2;
 924:Src/util.c    ****       input2[inIdx].raw = (pwm_captured_ch2_value - 500) * 2;
 925:Src/util.c    ****     }
ARM GAS  /tmp/cchLDBog.s 			page 43


 926:Src/util.c    ****     #endif
 927:Src/util.c    **** 
 928:Src/util.c    ****     #ifdef VARIANT_TRANSPOTTER
 929:Src/util.c    ****       #ifdef GAMETRAK_CONNECTION_NORMAL
 930:Src/util.c    ****         input1[inIdx].cmd = adc_buffer.l_rx2;
 931:Src/util.c    ****         input2[inIdx].cmd = adc_buffer.l_tx2;
 932:Src/util.c    ****       #endif
 933:Src/util.c    ****       #ifdef GAMETRAK_CONNECTION_ALTERNATE
 934:Src/util.c    ****         input1[inIdx].cmd = adc_buffer.l_tx2;
 935:Src/util.c    ****         input2[inIdx].cmd = adc_buffer.l_rx2;
 936:Src/util.c    ****       #endif
 937:Src/util.c    ****     #endif
 938:Src/util.c    **** }
 1323              		.loc 1 938 1 view .LVU347
 1324 0026 7047     		bx	lr
 1325              	.L90:
 1326              		.align	2
 1327              	.L89:
 1328 0028 00000000 		.word	inIdx
 1329 002c 00000000 		.word	commandR
 1330 0030 00000000 		.word	input1
 1331 0034 00000000 		.word	input2
 1332              		.cfi_endproc
 1333              	.LFE83:
 1335              		.section	.text.handleTimeout,"ax",%progbits
 1336              		.align	1
 1337              		.global	handleTimeout
 1338              		.syntax unified
 1339              		.thumb
 1340              		.thumb_func
 1342              	handleTimeout:
 1343              	.LFB84:
 939:Src/util.c    **** 
 940:Src/util.c    ****  /*
 941:Src/util.c    ****  * Function to handle the ADC, UART and General timeout (Nunchuk, PPM, PWM)
 942:Src/util.c    ****  */
 943:Src/util.c    **** void handleTimeout(void) {
 1344              		.loc 1 943 26 is_stmt 1 view -0
 1345              		.cfi_startproc
 1346              		@ args = 0, pretend = 0, frame = 0
 1347              		@ frame_needed = 0, uses_anonymous_args = 0
 1348 0000 08B5     		push	{r3, lr}
 1349              	.LCFI11:
 1350              		.cfi_def_cfa_offset 8
 1351              		.cfi_offset 3, -8
 1352              		.cfi_offset 14, -4
 944:Src/util.c    ****     #ifdef CONTROL_ADC
 945:Src/util.c    ****     if (inIdx == CONTROL_ADC) {
 946:Src/util.c    ****       // If input1 or Input2 is either below MIN - Threshold or above MAX + Threshold, ADC protecti
 947:Src/util.c    ****       if (IN_RANGE(input1[inIdx].raw, input1[inIdx].min - ADC_PROTECT_THRESH, input1[inIdx].max + A
 948:Src/util.c    ****           IN_RANGE(input2[inIdx].raw, input2[inIdx].min - ADC_PROTECT_THRESH, input2[inIdx].max + A
 949:Src/util.c    ****           timeoutFlgADC = 0;                            // Reset the timeout flag
 950:Src/util.c    ****           timeoutCntADC = 0;                            // Reset the timeout counter
 951:Src/util.c    ****       } else {
 952:Src/util.c    ****         if (timeoutCntADC++ >= ADC_PROTECT_TIMEOUT) {   // Timeout qualification
 953:Src/util.c    ****           timeoutFlgADC = 1;                            // Timeout detected
 954:Src/util.c    ****           timeoutCntADC = ADC_PROTECT_TIMEOUT;          // Limit timout counter value
ARM GAS  /tmp/cchLDBog.s 			page 44


 955:Src/util.c    ****         }
 956:Src/util.c    ****       }
 957:Src/util.c    ****     }
 958:Src/util.c    ****     #endif
 959:Src/util.c    **** 
 960:Src/util.c    ****     #if defined(CONTROL_SERIAL_USART2) || defined(SIDEBOARD_SERIAL_USART2)
 961:Src/util.c    ****       if (timeoutCntSerial_L++ >= SERIAL_TIMEOUT) {     // Timeout qualification
 962:Src/util.c    ****         timeoutFlgSerial_L = 1;                         // Timeout detected
 963:Src/util.c    ****         timeoutCntSerial_L = SERIAL_TIMEOUT;            // Limit timout counter value
 964:Src/util.c    ****         #if defined(DUAL_INPUTS) && ((defined(CONTROL_SERIAL_USART2) && CONTROL_SERIAL_USART2 == 1)
 965:Src/util.c    ****           inIdx = 0;                                    // Switch to Primary input in case of Timeo
 966:Src/util.c    ****         #endif
 967:Src/util.c    ****       } else {                                          // No Timeout
 968:Src/util.c    ****         #if defined(DUAL_INPUTS) && defined(SIDEBOARD_SERIAL_USART2)
 969:Src/util.c    ****           if (Sideboard_L.sensors & SWA_SET) {          // If SWA is set, switch to Sideboard contr
 970:Src/util.c    ****             inIdx = SIDEBOARD_SERIAL_USART2;
 971:Src/util.c    ****           } else {
 972:Src/util.c    ****             inIdx = !SIDEBOARD_SERIAL_USART2;
 973:Src/util.c    ****           }
 974:Src/util.c    ****         #elif defined(DUAL_INPUTS) && (defined(CONTROL_SERIAL_USART2) && CONTROL_SERIAL_USART2 == 1
 975:Src/util.c    ****           inIdx = 1;                                    // Switch to Auxiliary input in case of NO 
 976:Src/util.c    ****         #endif
 977:Src/util.c    ****       }
 978:Src/util.c    ****       #if (defined(CONTROL_SERIAL_USART2) && CONTROL_SERIAL_USART2 == 0) || (defined(SIDEBOARD_SERI
 979:Src/util.c    ****         timeoutFlgSerial = timeoutFlgSerial_L;          // Report Timeout only on the Primary Input
 980:Src/util.c    ****       #endif
 981:Src/util.c    ****     #endif
 982:Src/util.c    **** 
 983:Src/util.c    ****     #if defined(CONTROL_SERIAL_USART3) || defined(SIDEBOARD_SERIAL_USART3)
 984:Src/util.c    ****       if (timeoutCntSerial_R++ >= SERIAL_TIMEOUT) {     // Timeout qualification
 1353              		.loc 1 984 7 view .LVU349
 1354              		.loc 1 984 29 is_stmt 0 view .LVU350
 1355 0002 1E4A     		ldr	r2, .L101
 1356 0004 1388     		ldrh	r3, [r2]
 1357 0006 591C     		adds	r1, r3, #1
 1358 0008 1180     		strh	r1, [r2]	@ movhi
 1359              		.loc 1 984 10 view .LVU351
 1360 000a 9F2B     		cmp	r3, #159
 1361 000c 05D9     		bls	.L92
 985:Src/util.c    ****         timeoutFlgSerial_R = 1;                         // Timeout detected
 1362              		.loc 1 985 9 is_stmt 1 view .LVU352
 1363              		.loc 1 985 28 is_stmt 0 view .LVU353
 1364 000e 1C4B     		ldr	r3, .L101+4
 1365 0010 0122     		movs	r2, #1
 1366 0012 1A70     		strb	r2, [r3]
 986:Src/util.c    ****         timeoutCntSerial_R = SERIAL_TIMEOUT;            // Limit timout counter value
 1367              		.loc 1 986 9 is_stmt 1 view .LVU354
 1368              		.loc 1 986 28 is_stmt 0 view .LVU355
 1369 0014 194B     		ldr	r3, .L101
 1370 0016 A022     		movs	r2, #160
 1371 0018 1A80     		strh	r2, [r3]	@ movhi
 1372              	.L92:
 987:Src/util.c    ****         #if defined(DUAL_INPUTS) && ((defined(CONTROL_SERIAL_USART3) && CONTROL_SERIAL_USART3 == 1)
 988:Src/util.c    ****           inIdx = 0;                                    // Switch to Primary input in case of Timeo
 989:Src/util.c    ****         #endif
 990:Src/util.c    ****       } else {                                          // No Timeout
 991:Src/util.c    ****         #if defined(DUAL_INPUTS) && defined(SIDEBOARD_SERIAL_USART3)
ARM GAS  /tmp/cchLDBog.s 			page 45


 992:Src/util.c    ****           if (Sideboard_R.sensors & SWA_SET) {          // If SWA is set, switch to Sideboard contr
 993:Src/util.c    ****             inIdx = SIDEBOARD_SERIAL_USART3;
 994:Src/util.c    ****           } else {
 995:Src/util.c    ****             inIdx = !SIDEBOARD_SERIAL_USART3;
 996:Src/util.c    ****           }
 997:Src/util.c    ****         #elif defined(DUAL_INPUTS) && (defined(CONTROL_SERIAL_USART3) && CONTROL_SERIAL_USART3 == 1
 998:Src/util.c    ****           inIdx = 1;                                    // Switch to Auxiliary input in case of NO 
 999:Src/util.c    ****         #endif
1000:Src/util.c    ****       }
 1373              		.loc 1 1000 7 is_stmt 1 view .LVU356
1001:Src/util.c    ****       #if (defined(CONTROL_SERIAL_USART3) && CONTROL_SERIAL_USART3 == 0) || (defined(SIDEBOARD_SERI
1002:Src/util.c    ****         timeoutFlgSerial = timeoutFlgSerial_R;          // Report Timeout only on the Primary Input
 1374              		.loc 1 1002 9 view .LVU357
 1375              		.loc 1 1002 26 is_stmt 0 view .LVU358
 1376 001a 194B     		ldr	r3, .L101+4
 1377 001c 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1378 001e 194A     		ldr	r2, .L101+8
 1379 0020 1370     		strb	r3, [r2]
1003:Src/util.c    ****       #endif
1004:Src/util.c    ****     #endif
1005:Src/util.c    **** 
1006:Src/util.c    ****     #if defined(SIDEBOARD_SERIAL_USART2) && defined(SIDEBOARD_SERIAL_USART3)
1007:Src/util.c    ****       timeoutFlgSerial = timeoutFlgSerial_L || timeoutFlgSerial_R;
1008:Src/util.c    ****     #endif
1009:Src/util.c    **** 
1010:Src/util.c    ****     #if defined(CONTROL_NUNCHUK) || defined(SUPPORT_NUNCHUK) || defined(VARIANT_TRANSPOTTER) || \
1011:Src/util.c    ****         defined(CONTROL_PPM_LEFT) || defined(CONTROL_PPM_RIGHT) || defined(CONTROL_PWM_LEFT) || def
1012:Src/util.c    ****       if (timeoutCntGen++ >= TIMEOUT) {                 // Timeout qualification
1013:Src/util.c    ****         #if defined(CONTROL_NUNCHUK) || defined(SUPPORT_NUNCHUK) || defined(VARIANT_TRANSPOTTER) ||
1014:Src/util.c    ****             (defined(CONTROL_PPM_LEFT) && CONTROL_PPM_LEFT == 0) || (defined(CONTROL_PPM_RIGHT) && 
1015:Src/util.c    ****             (defined(CONTROL_PWM_LEFT) && CONTROL_PWM_LEFT == 0) || (defined(CONTROL_PWM_RIGHT) && 
1016:Src/util.c    ****           timeoutFlgGen = 1;                            // Report Timeout only on the Primary Input
1017:Src/util.c    ****           timeoutCntGen = TIMEOUT;
1018:Src/util.c    ****         #endif
1019:Src/util.c    ****         #if defined(DUAL_INPUTS) && ((defined(CONTROL_PPM_LEFT)  && CONTROL_PPM_LEFT == 1) || (defi
1020:Src/util.c    ****                                      (defined(CONTROL_PWM_LEFT)  && CONTROL_PWM_LEFT == 1) || (defi
1021:Src/util.c    ****           inIdx = 0;                                    // Switch to Primary input in case of Timeo
1022:Src/util.c    ****         #endif
1023:Src/util.c    ****       } else {
1024:Src/util.c    ****         #if defined(DUAL_INPUTS) && ((defined(CONTROL_PPM_LEFT)  && CONTROL_PPM_LEFT == 1) || (defi
1025:Src/util.c    ****                                      (defined(CONTROL_PWM_LEFT)  && CONTROL_PWM_LEFT == 1) || (defi
1026:Src/util.c    ****           inIdx = 1;                                    // Switch to Auxiliary input in case of NO 
1027:Src/util.c    ****         #endif
1028:Src/util.c    ****       }
1029:Src/util.c    ****     #endif
1030:Src/util.c    **** 
1031:Src/util.c    ****     // In case of timeout bring the system to a Safe State
1032:Src/util.c    ****     if (timeoutFlgADC || timeoutFlgSerial || timeoutFlgGen) {
 1380              		.loc 1 1032 5 is_stmt 1 view .LVU359
 1381              		.loc 1 1032 9 is_stmt 0 view .LVU360
 1382 0022 194A     		ldr	r2, .L101+12
 1383 0024 1278     		ldrb	r2, [r2]	@ zero_extendqisi2
 1384              		.loc 1 1032 8 view .LVU361
 1385 0026 1AB9     		cbnz	r2, .L93
 1386              		.loc 1 1032 23 discriminator 1 view .LVU362
 1387 0028 13B9     		cbnz	r3, .L93
 1388              		.loc 1 1032 43 discriminator 2 view .LVU363
ARM GAS  /tmp/cchLDBog.s 			page 46


 1389 002a 184B     		ldr	r3, .L101+16
 1390 002c 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1391 002e C3B1     		cbz	r3, .L94
 1392              	.L93:
1033:Src/util.c    ****       ctrlModReq  = OPEN_MODE;                                          // Request OPEN_MODE. This 
 1393              		.loc 1 1033 7 is_stmt 1 view .LVU364
 1394              		.loc 1 1033 19 is_stmt 0 view .LVU365
 1395 0030 0022     		movs	r2, #0
 1396 0032 174B     		ldr	r3, .L101+20
 1397 0034 1A70     		strb	r2, [r3]
1034:Src/util.c    ****       input1[inIdx].cmd  = 0;
 1398              		.loc 1 1034 7 is_stmt 1 view .LVU366
 1399              		.loc 1 1034 20 is_stmt 0 view .LVU367
 1400 0036 174B     		ldr	r3, .L101+24
 1401 0038 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1402              		.loc 1 1034 26 view .LVU368
 1403 003a C3EBC301 		rsb	r1, r3, r3, lsl #3
 1404 003e 4800     		lsls	r0, r1, #1
 1405 0040 1549     		ldr	r1, .L101+28
 1406 0042 0144     		add	r1, r1, r0
 1407 0044 4A80     		strh	r2, [r1, #2]	@ movhi
1035:Src/util.c    ****       input2[inIdx].cmd  = 0;
 1408              		.loc 1 1035 7 is_stmt 1 view .LVU369
 1409              		.loc 1 1035 26 is_stmt 0 view .LVU370
 1410 0046 154B     		ldr	r3, .L101+32
 1411 0048 0344     		add	r3, r3, r0
 1412 004a 5A80     		strh	r2, [r3, #2]	@ movhi
 1413              	.L95:
1036:Src/util.c    ****     } else {
1037:Src/util.c    ****       ctrlModReq  = ctrlModReqRaw;                                      // Follow the Mode request
1038:Src/util.c    ****     }
1039:Src/util.c    **** 
1040:Src/util.c    ****     // Beep in case of Input index change
1041:Src/util.c    ****     if (inIdx && !inIdx_prev) {                                         // rising edge
 1414              		.loc 1 1041 5 is_stmt 1 view .LVU371
 1415              		.loc 1 1041 9 is_stmt 0 view .LVU372
 1416 004c 114B     		ldr	r3, .L101+24
 1417 004e 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1418              		.loc 1 1041 8 view .LVU373
 1419 0050 13B1     		cbz	r3, .L96
 1420              		.loc 1 1041 18 discriminator 1 view .LVU374
 1421 0052 134A     		ldr	r2, .L101+36
 1422 0054 1278     		ldrb	r2, [r2]	@ zero_extendqisi2
 1423              		.loc 1 1041 15 discriminator 1 view .LVU375
 1424 0056 4AB1     		cbz	r2, .L99
 1425              	.L96:
1042:Src/util.c    ****       beepShort(8);
1043:Src/util.c    ****     } else if (!inIdx && inIdx_prev) {                                  // falling edge
 1426              		.loc 1 1043 12 is_stmt 1 view .LVU376
 1427              		.loc 1 1043 15 is_stmt 0 view .LVU377
 1428 0058 13B9     		cbnz	r3, .L91
 1429              		.loc 1 1043 23 discriminator 1 view .LVU378
 1430 005a 114B     		ldr	r3, .L101+36
 1431 005c 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1432 005e 4BB9     		cbnz	r3, .L100
 1433              	.L91:
1044:Src/util.c    ****       beepShort(18);
ARM GAS  /tmp/cchLDBog.s 			page 47


1045:Src/util.c    ****     }
1046:Src/util.c    **** }
 1434              		.loc 1 1046 1 view .LVU379
 1435 0060 08BD     		pop	{r3, pc}
 1436              	.L94:
1037:Src/util.c    ****     }
 1437              		.loc 1 1037 7 is_stmt 1 view .LVU380
1037:Src/util.c    ****     }
 1438              		.loc 1 1037 19 is_stmt 0 view .LVU381
 1439 0062 104B     		ldr	r3, .L101+40
 1440 0064 1A78     		ldrb	r2, [r3]	@ zero_extendqisi2
 1441 0066 0A4B     		ldr	r3, .L101+20
 1442 0068 1A70     		strb	r2, [r3]
 1443 006a EFE7     		b	.L95
 1444              	.L99:
1042:Src/util.c    ****       beepShort(8);
 1445              		.loc 1 1042 7 is_stmt 1 view .LVU382
 1446 006c 0820     		movs	r0, #8
 1447 006e FFF7FEFF 		bl	beepShort
 1448              	.LVL83:
 1449 0072 F5E7     		b	.L91
 1450              	.L100:
1044:Src/util.c    ****       beepShort(18);
 1451              		.loc 1 1044 7 view .LVU383
 1452 0074 1220     		movs	r0, #18
 1453 0076 FFF7FEFF 		bl	beepShort
 1454              	.LVL84:
 1455              		.loc 1 1046 1 is_stmt 0 view .LVU384
 1456 007a F1E7     		b	.L91
 1457              	.L102:
 1458              		.align	2
 1459              	.L101:
 1460 007c 00000000 		.word	timeoutCntSerial_R
 1461 0080 00000000 		.word	timeoutFlgSerial_R
 1462 0084 00000000 		.word	timeoutFlgSerial
 1463 0088 00000000 		.word	timeoutFlgADC
 1464 008c 00000000 		.word	timeoutFlgGen
 1465 0090 00000000 		.word	ctrlModReq
 1466 0094 00000000 		.word	inIdx
 1467 0098 00000000 		.word	input1
 1468 009c 00000000 		.word	input2
 1469 00a0 00000000 		.word	inIdx_prev
 1470 00a4 00000000 		.word	ctrlModReqRaw
 1471              		.cfi_endproc
 1472              	.LFE84:
 1474              		.section	.text.readCommand,"ax",%progbits
 1475              		.align	1
 1476              		.global	readCommand
 1477              		.syntax unified
 1478              		.thumb
 1479              		.thumb_func
 1481              	readCommand:
 1482              	.LFB85:
1047:Src/util.c    **** 
1048:Src/util.c    ****  /*
1049:Src/util.c    ****  * Function to calculate the command to the motors. This function also manages:
1050:Src/util.c    ****  * - timeout detection
ARM GAS  /tmp/cchLDBog.s 			page 48


1051:Src/util.c    ****  * - MIN/MAX limitations and deadband
1052:Src/util.c    ****  */
1053:Src/util.c    **** void readCommand(void) {
 1483              		.loc 1 1053 24 is_stmt 1 view -0
 1484              		.cfi_startproc
 1485              		@ args = 0, pretend = 0, frame = 0
 1486              		@ frame_needed = 0, uses_anonymous_args = 0
 1487 0000 70B5     		push	{r4, r5, r6, lr}
 1488              	.LCFI12:
 1489              		.cfi_def_cfa_offset 16
 1490              		.cfi_offset 4, -16
 1491              		.cfi_offset 5, -12
 1492              		.cfi_offset 6, -8
 1493              		.cfi_offset 14, -4
1054:Src/util.c    ****     readInputRaw();
 1494              		.loc 1 1054 5 view .LVU386
 1495 0002 FFF7FEFF 		bl	readInputRaw
 1496              	.LVL85:
1055:Src/util.c    **** 
1056:Src/util.c    ****     #if !defined(VARIANT_HOVERBOARD) && !defined(VARIANT_TRANSPOTTER)
1057:Src/util.c    ****       calcInputCmd(&input1[inIdx], INPUT_MIN, INPUT_MAX);
 1497              		.loc 1 1057 7 view .LVU387
 1498              		.loc 1 1057 27 is_stmt 0 view .LVU388
 1499 0006 0F4E     		ldr	r6, .L105
 1500 0008 3378     		ldrb	r3, [r6]	@ zero_extendqisi2
 1501              		.loc 1 1057 7 view .LVU389
 1502 000a 0F4D     		ldr	r5, .L105+4
 1503 000c 0F4C     		ldr	r4, .L105+8
 1504 000e C3EBC303 		rsb	r3, r3, r3, lsl #3
 1505 0012 5800     		lsls	r0, r3, #1
 1506 0014 B5F90020 		ldrsh	r2, [r5]
 1507 0018 B4F90010 		ldrsh	r1, [r4]
 1508 001c 0C4B     		ldr	r3, .L105+12
 1509 001e 1844     		add	r0, r0, r3
 1510 0020 FFF7FEFF 		bl	calcInputCmd
 1511              	.LVL86:
1058:Src/util.c    ****       #if !defined(VARIANT_SKATEBOARD)
1059:Src/util.c    ****         calcInputCmd(&input2[inIdx], INPUT_MIN, INPUT_MAX);
 1512              		.loc 1 1059 9 is_stmt 1 view .LVU390
 1513              		.loc 1 1059 29 is_stmt 0 view .LVU391
 1514 0024 3378     		ldrb	r3, [r6]	@ zero_extendqisi2
 1515              		.loc 1 1059 9 view .LVU392
 1516 0026 C3EBC303 		rsb	r3, r3, r3, lsl #3
 1517 002a 5800     		lsls	r0, r3, #1
 1518 002c B5F90020 		ldrsh	r2, [r5]
 1519 0030 B4F90010 		ldrsh	r1, [r4]
 1520 0034 074B     		ldr	r3, .L105+16
 1521 0036 1844     		add	r0, r0, r3
 1522 0038 FFF7FEFF 		bl	calcInputCmd
 1523              	.LVL87:
1060:Src/util.c    ****       #else
1061:Src/util.c    ****         calcInputCmd(&input2[inIdx], INPUT_BRK, INPUT_MAX);
1062:Src/util.c    ****       #endif
1063:Src/util.c    ****     #endif
1064:Src/util.c    **** 
1065:Src/util.c    ****     handleTimeout();
 1524              		.loc 1 1065 5 is_stmt 1 view .LVU393
ARM GAS  /tmp/cchLDBog.s 			page 49


 1525 003c FFF7FEFF 		bl	handleTimeout
 1526              	.LVL88:
1066:Src/util.c    **** 
1067:Src/util.c    ****     #ifdef VARIANT_HOVERCAR
1068:Src/util.c    ****     if (inIdx == CONTROL_ADC) {
1069:Src/util.c    ****       brakePressed = (uint8_t)(input1[inIdx].cmd > 50);
1070:Src/util.c    ****     }
1071:Src/util.c    ****     else {
1072:Src/util.c    ****       brakePressed = (uint8_t)(input2[inIdx].cmd < -50);
1073:Src/util.c    ****     }
1074:Src/util.c    ****     #endif
1075:Src/util.c    **** 
1076:Src/util.c    ****     #if defined(SUPPORT_BUTTONS_LEFT) || defined(SUPPORT_BUTTONS_RIGHT)
1077:Src/util.c    ****       button1 = !HAL_GPIO_ReadPin(BUTTON1_PORT, BUTTON1_PIN);
1078:Src/util.c    ****       button2 = !HAL_GPIO_ReadPin(BUTTON2_PORT, BUTTON2_PIN);
1079:Src/util.c    ****     #endif
1080:Src/util.c    **** 
1081:Src/util.c    ****     #if defined(CRUISE_CONTROL_SUPPORT) && (defined(SUPPORT_BUTTONS) || defined(SUPPORT_BUTTONS_LEF
1082:Src/util.c    ****         cruiseControl(button1);                                           // Cruise control activat
1083:Src/util.c    ****     #endif
1084:Src/util.c    **** }
 1527              		.loc 1 1084 1 is_stmt 0 view .LVU394
 1528 0040 70BD     		pop	{r4, r5, r6, pc}
 1529              	.L106:
 1530 0042 00BF     		.align	2
 1531              	.L105:
 1532 0044 00000000 		.word	inIdx
 1533 0048 00000000 		.word	INPUT_MAX
 1534 004c 00000000 		.word	INPUT_MIN
 1535 0050 00000000 		.word	input1
 1536 0054 00000000 		.word	input2
 1537              		.cfi_endproc
 1538              	.LFE85:
 1540              		.section	.text.usart2_rx_check,"ax",%progbits
 1541              		.align	1
 1542              		.global	usart2_rx_check
 1543              		.syntax unified
 1544              		.thumb
 1545              		.thumb_func
 1547              	usart2_rx_check:
 1548              	.LFB86:
1085:Src/util.c    **** 
1086:Src/util.c    **** 
1087:Src/util.c    **** /*
1088:Src/util.c    ****  * Check for new data received on USART2 with DMA: refactored function from https://github.com/MaJe
1089:Src/util.c    ****  * - this function is called for every USART IDLE line detection, in the USART interrupt handler
1090:Src/util.c    ****  */
1091:Src/util.c    **** void usart2_rx_check(void)
1092:Src/util.c    **** {
 1549              		.loc 1 1092 1 is_stmt 1 view -0
 1550              		.cfi_startproc
 1551              		@ args = 0, pretend = 0, frame = 0
 1552              		@ frame_needed = 0, uses_anonymous_args = 0
 1553              		@ link register save eliminated.
1093:Src/util.c    ****   #if defined(DEBUG_SERIAL_USART2) || defined(CONTROL_SERIAL_USART2) || defined(SIDEBOARD_SERIAL_US
1094:Src/util.c    ****   static uint32_t old_pos;
1095:Src/util.c    ****   uint32_t pos;
ARM GAS  /tmp/cchLDBog.s 			page 50


1096:Src/util.c    ****   pos = rx_buffer_L_len - __HAL_DMA_GET_COUNTER(huart2.hdmarx);         // Calculate current positi
1097:Src/util.c    ****   #endif
1098:Src/util.c    **** 
1099:Src/util.c    ****   #if defined(DEBUG_SERIAL_USART2)
1100:Src/util.c    ****   uint8_t ptr_debug[SERIAL_BUFFER_SIZE];
1101:Src/util.c    ****   if (pos != old_pos) {                                                 // Check change in received
1102:Src/util.c    ****     if (pos > old_pos) {                                                // "Linear" buffer mode: ch
1103:Src/util.c    ****       usart_process_debug(&rx_buffer_L[old_pos], pos - old_pos);        // Process data
1104:Src/util.c    ****     } else {                                                            // "Overflow" buffer mode
1105:Src/util.c    ****       memcpy(&ptr_debug[0], &rx_buffer_L[old_pos], rx_buffer_L_len - old_pos);    // First copy dat
1106:Src/util.c    ****       if (pos > 0) {                                                    // Check and continue with 
1107:Src/util.c    ****         memcpy(&ptr_debug[rx_buffer_L_len - old_pos], &rx_buffer_L[0], pos);                       
1108:Src/util.c    ****       }
1109:Src/util.c    ****       usart_process_debug(ptr_debug, rx_buffer_L_len - old_pos + pos);        // Process data
1110:Src/util.c    ****     }
1111:Src/util.c    ****   }
1112:Src/util.c    ****   #endif // DEBUG_SERIAL_USART2
1113:Src/util.c    **** 
1114:Src/util.c    ****   #ifdef CONTROL_SERIAL_USART2
1115:Src/util.c    ****   uint8_t *ptr;	
1116:Src/util.c    ****   if (pos != old_pos) {                                                 // Check change in received
1117:Src/util.c    ****     ptr = (uint8_t *)&commandL_raw;                                     // Initialize the pointer w
1118:Src/util.c    ****     if (pos > old_pos && (pos - old_pos) == commandL_len) {             // "Linear" buffer mode: ch
1119:Src/util.c    ****       memcpy(ptr, &rx_buffer_L[old_pos], commandL_len);                 // Copy data. This is possi
1120:Src/util.c    ****       usart_process_command(&commandL_raw, &commandL, 2);               // Process data
1121:Src/util.c    ****     } else if ((rx_buffer_L_len - old_pos + pos) == commandL_len) {     // "Overflow" buffer mode: 
1122:Src/util.c    ****       memcpy(ptr, &rx_buffer_L[old_pos], rx_buffer_L_len - old_pos);    // First copy data from the
1123:Src/util.c    ****       if (pos > 0) {                                                    // Check and continue with 
1124:Src/util.c    ****         ptr += rx_buffer_L_len - old_pos;                               // Move to correct position
1125:Src/util.c    ****         memcpy(ptr, &rx_buffer_L[0], pos);                              // Copy remaining data
1126:Src/util.c    ****       }
1127:Src/util.c    ****       usart_process_command(&commandL_raw, &commandL, 2);               // Process data
1128:Src/util.c    ****     }
1129:Src/util.c    ****   }
1130:Src/util.c    ****   #endif // CONTROL_SERIAL_USART2
1131:Src/util.c    **** 
1132:Src/util.c    ****   #ifdef SIDEBOARD_SERIAL_USART2
1133:Src/util.c    ****   uint8_t *ptr;	
1134:Src/util.c    ****   if (pos != old_pos) {                                                 // Check change in received
1135:Src/util.c    ****     ptr = (uint8_t *)&Sideboard_L_raw;                                  // Initialize the pointer w
1136:Src/util.c    ****     if (pos > old_pos && (pos - old_pos) == Sideboard_L_len) {          // "Linear" buffer mode: ch
1137:Src/util.c    ****       memcpy(ptr, &rx_buffer_L[old_pos], Sideboard_L_len);              // Copy data. This is possi
1138:Src/util.c    ****       usart_process_sideboard(&Sideboard_L_raw, &Sideboard_L, 2);       // Process data
1139:Src/util.c    ****     } else if ((rx_buffer_L_len - old_pos + pos) == Sideboard_L_len) {  // "Overflow" buffer mode: 
1140:Src/util.c    ****       memcpy(ptr, &rx_buffer_L[old_pos], rx_buffer_L_len - old_pos);    // First copy data from the
1141:Src/util.c    ****       if (pos > 0) {                                                    // Check and continue with 
1142:Src/util.c    ****         ptr += rx_buffer_L_len - old_pos;                               // Move to correct position
1143:Src/util.c    ****         memcpy(ptr, &rx_buffer_L[0], pos);                              // Copy remaining data
1144:Src/util.c    ****       }
1145:Src/util.c    ****       usart_process_sideboard(&Sideboard_L_raw, &Sideboard_L, 2);       // Process data
1146:Src/util.c    ****     }
1147:Src/util.c    ****   }
1148:Src/util.c    ****   #endif // SIDEBOARD_SERIAL_USART2
1149:Src/util.c    **** 
1150:Src/util.c    ****   #if defined(DEBUG_SERIAL_USART2) || defined(CONTROL_SERIAL_USART2) || defined(SIDEBOARD_SERIAL_US
1151:Src/util.c    ****   old_pos = pos;                                                        // Update old position
1152:Src/util.c    ****   if (old_pos == rx_buffer_L_len) {                                     // Check and manually updat
ARM GAS  /tmp/cchLDBog.s 			page 51


1153:Src/util.c    ****     old_pos = 0;
1154:Src/util.c    ****   }
1155:Src/util.c    **** 	#endif
1156:Src/util.c    **** }
 1554              		.loc 1 1156 1 view .LVU396
 1555 0000 7047     		bx	lr
 1556              		.cfi_endproc
 1557              	.LFE86:
 1559              		.section	.text.usart_process_command,"ax",%progbits
 1560              		.align	1
 1561              		.global	usart_process_command
 1562              		.syntax unified
 1563              		.thumb
 1564              		.thumb_func
 1566              	usart_process_command:
 1567              	.LVL89:
 1568              	.LFB88:
1157:Src/util.c    **** 
1158:Src/util.c    **** 
1159:Src/util.c    **** /*
1160:Src/util.c    ****  * Check for new data received on USART3 with DMA: refactored function from https://github.com/MaJe
1161:Src/util.c    ****  * - this function is called for every USART IDLE line detection, in the USART interrupt handler
1162:Src/util.c    ****  */
1163:Src/util.c    **** void usart3_rx_check(void)
1164:Src/util.c    **** {
1165:Src/util.c    ****   #if defined(DEBUG_SERIAL_USART3) || defined(CONTROL_SERIAL_USART3) || defined(SIDEBOARD_SERIAL_US
1166:Src/util.c    ****   static uint32_t old_pos;
1167:Src/util.c    ****   uint32_t pos;  
1168:Src/util.c    ****   pos = rx_buffer_R_len - __HAL_DMA_GET_COUNTER(huart3.hdmarx);         // Calculate current positi
1169:Src/util.c    ****   #endif
1170:Src/util.c    **** 
1171:Src/util.c    ****   #if defined(DEBUG_SERIAL_USART3)
1172:Src/util.c    ****   uint8_t ptr_debug[SERIAL_BUFFER_SIZE];
1173:Src/util.c    **** 
1174:Src/util.c    ****   if (pos != old_pos) {                                                 // Check change in received
1175:Src/util.c    ****     if (pos > old_pos) {                                                // "Linear" buffer mode: ch
1176:Src/util.c    ****       usart_process_debug(&rx_buffer_R[old_pos], pos - old_pos);        // Process data
1177:Src/util.c    ****     } else {                                                            // "Overflow" buffer mode
1178:Src/util.c    ****       memcpy(&ptr_debug[0], &rx_buffer_R[old_pos], rx_buffer_R_len - old_pos);    // First copy dat
1179:Src/util.c    ****       if (pos > 0) {                                                    // Check and continue with 
1180:Src/util.c    ****         memcpy(&ptr_debug[rx_buffer_R_len - old_pos], &rx_buffer_R[0], pos);                       
1181:Src/util.c    ****       }
1182:Src/util.c    ****       usart_process_debug(ptr_debug, rx_buffer_R_len - old_pos + pos);        // Process data
1183:Src/util.c    ****     }
1184:Src/util.c    ****   }
1185:Src/util.c    ****   #endif // DEBUG_SERIAL_USART3
1186:Src/util.c    **** 
1187:Src/util.c    ****   #ifdef CONTROL_SERIAL_USART3
1188:Src/util.c    ****   uint8_t *ptr;
1189:Src/util.c    ****   if (pos != old_pos) {                                                 // Check change in received
1190:Src/util.c    ****     ptr = (uint8_t *)&commandR_raw;                                     // Initialize the pointer w
1191:Src/util.c    ****     if (pos > old_pos && (pos - old_pos) == commandR_len) {             // "Linear" buffer mode: ch
1192:Src/util.c    ****       memcpy(ptr, &rx_buffer_R[old_pos], commandR_len);                 // Copy data. This is possi
1193:Src/util.c    ****       usart_process_command(&commandR_raw, &commandR, 3);               // Process data
1194:Src/util.c    ****     } else if ((rx_buffer_R_len - old_pos + pos) == commandR_len) {     // "Overflow" buffer mode: 
1195:Src/util.c    ****       memcpy(ptr, &rx_buffer_R[old_pos], rx_buffer_R_len - old_pos);    // First copy data from the
1196:Src/util.c    ****       if (pos > 0) {                                                    // Check and continue with 
ARM GAS  /tmp/cchLDBog.s 			page 52


1197:Src/util.c    ****         ptr += rx_buffer_R_len - old_pos;                               // Move to correct position
1198:Src/util.c    ****         memcpy(ptr, &rx_buffer_R[0], pos);                              // Copy remaining data
1199:Src/util.c    ****       }
1200:Src/util.c    ****       usart_process_command(&commandR_raw, &commandR, 3);               // Process data
1201:Src/util.c    ****     }
1202:Src/util.c    ****   }
1203:Src/util.c    ****   #endif // CONTROL_SERIAL_USART3
1204:Src/util.c    **** 
1205:Src/util.c    ****   #ifdef SIDEBOARD_SERIAL_USART3
1206:Src/util.c    ****   uint8_t *ptr;
1207:Src/util.c    ****   if (pos != old_pos) {                                                 // Check change in received
1208:Src/util.c    ****     ptr = (uint8_t *)&Sideboard_R_raw;                                  // Initialize the pointer w
1209:Src/util.c    ****     if (pos > old_pos && (pos - old_pos) == Sideboard_R_len) {          // "Linear" buffer mode: ch
1210:Src/util.c    ****       memcpy(ptr, &rx_buffer_R[old_pos], Sideboard_R_len);              // Copy data. This is possi
1211:Src/util.c    ****       usart_process_sideboard(&Sideboard_R_raw, &Sideboard_R, 3);       // Process data
1212:Src/util.c    ****     } else if ((rx_buffer_R_len - old_pos + pos) == Sideboard_R_len) {  // "Overflow" buffer mode: 
1213:Src/util.c    ****       memcpy(ptr, &rx_buffer_R[old_pos], rx_buffer_R_len - old_pos);    // First copy data from the
1214:Src/util.c    ****       if (pos > 0) {                                                    // Check and continue with 
1215:Src/util.c    ****         ptr += rx_buffer_R_len - old_pos;                               // Move to correct position
1216:Src/util.c    ****         memcpy(ptr, &rx_buffer_R[0], pos);                              // Copy remaining data
1217:Src/util.c    ****       }
1218:Src/util.c    ****       usart_process_sideboard(&Sideboard_R_raw, &Sideboard_R, 3);       // Process data
1219:Src/util.c    ****     }
1220:Src/util.c    ****   }
1221:Src/util.c    ****   #endif // SIDEBOARD_SERIAL_USART3
1222:Src/util.c    **** 
1223:Src/util.c    ****   #if defined(DEBUG_SERIAL_USART3) || defined(CONTROL_SERIAL_USART3) || defined(SIDEBOARD_SERIAL_US
1224:Src/util.c    ****   old_pos = pos;                                                        // Update old position
1225:Src/util.c    ****   if (old_pos == rx_buffer_R_len) {                                     // Check and manually updat
1226:Src/util.c    ****     old_pos = 0;
1227:Src/util.c    ****   }
1228:Src/util.c    ****   #endif
1229:Src/util.c    **** }
1230:Src/util.c    **** 
1231:Src/util.c    **** /*
1232:Src/util.c    ****  * Process Rx debug user command input
1233:Src/util.c    ****  */
1234:Src/util.c    **** #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
1235:Src/util.c    **** void usart_process_debug(uint8_t *userCommand, uint32_t len)
1236:Src/util.c    **** {
1237:Src/util.c    ****   #ifdef DEBUG_SERIAL_PROTOCOL
1238:Src/util.c    ****     handle_input(userCommand, len);
1239:Src/util.c    ****   #endif
1240:Src/util.c    **** }
1241:Src/util.c    **** 
1242:Src/util.c    **** #endif // SERIAL_DEBUG
1243:Src/util.c    **** 
1244:Src/util.c    **** /*
1245:Src/util.c    ****  * Process command Rx data
1246:Src/util.c    ****  * - if the command_in data is valid (correct START_FRAME and checksum) copy the command_in to comm
1247:Src/util.c    ****  */
1248:Src/util.c    **** #if defined(CONTROL_SERIAL_USART2) || defined(CONTROL_SERIAL_USART3)
1249:Src/util.c    **** void usart_process_command(SerialCommand *command_in, SerialCommand *command_out, uint8_t usart_idx
1250:Src/util.c    **** {
 1569              		.loc 1 1250 1 view -0
 1570              		.cfi_startproc
 1571              		@ args = 0, pretend = 0, frame = 0
ARM GAS  /tmp/cchLDBog.s 			page 53


 1572              		@ frame_needed = 0, uses_anonymous_args = 0
 1573              		@ link register save eliminated.
1251:Src/util.c    ****   #ifdef CONTROL_IBUS
1252:Src/util.c    ****     uint16_t ibus_chksum;
1253:Src/util.c    ****     if (command_in->start == IBUS_LENGTH && command_in->type == IBUS_COMMAND) {
1254:Src/util.c    ****       ibus_chksum = 0xFFFF - IBUS_LENGTH - IBUS_COMMAND;
1255:Src/util.c    ****       for (uint8_t i = 0; i < (IBUS_NUM_CHANNELS * 2); i++) {
1256:Src/util.c    ****         ibus_chksum -= command_in->channels[i];
1257:Src/util.c    ****       }
1258:Src/util.c    ****       if (ibus_chksum == (uint16_t)((command_in->checksumh << 8) + command_in->checksuml)) {
1259:Src/util.c    ****         *command_out = *command_in;
1260:Src/util.c    ****         if (usart_idx == 2) {             // Sideboard USART2
1261:Src/util.c    ****           #ifdef CONTROL_SERIAL_USART2
1262:Src/util.c    ****           timeoutFlgSerial_L = 0;         // Clear timeout flag
1263:Src/util.c    ****           timeoutCntSerial_L = 0;         // Reset timeout counter
1264:Src/util.c    ****           #endif
1265:Src/util.c    ****         } else if (usart_idx == 3) {      // Sideboard USART3
1266:Src/util.c    ****           #ifdef CONTROL_SERIAL_USART3
1267:Src/util.c    ****           timeoutFlgSerial_R = 0;         // Clear timeout flag
1268:Src/util.c    ****           timeoutCntSerial_R = 0;         // Reset timeout counter
1269:Src/util.c    ****           #endif
1270:Src/util.c    ****         }
1271:Src/util.c    ****       }
1272:Src/util.c    ****     }
1273:Src/util.c    ****   #else
1274:Src/util.c    ****   uint16_t checksum;
 1574              		.loc 1 1274 3 view .LVU398
1275:Src/util.c    ****   if (command_in->start == SERIAL_START_FRAME) {
 1575              		.loc 1 1275 3 view .LVU399
 1576              		.loc 1 1275 17 is_stmt 0 view .LVU400
 1577 0000 0388     		ldrh	r3, [r0]
 1578              		.loc 1 1275 6 view .LVU401
 1579 0002 4AF6CD3C 		movw	ip, #43981
 1580 0006 6345     		cmp	r3, ip
 1581 0008 00D0     		beq	.L110
 1582              	.LVL90:
 1583              	.L108:
1276:Src/util.c    ****     checksum = (uint16_t)(command_in->start ^ command_in->steer ^ command_in->speed);
1277:Src/util.c    ****     if (command_in->checksum == checksum) {
1278:Src/util.c    ****       *command_out = *command_in;
1279:Src/util.c    ****       if (usart_idx == 2) {             // Sideboard USART2
1280:Src/util.c    ****         #ifdef CONTROL_SERIAL_USART2
1281:Src/util.c    ****         timeoutFlgSerial_L = 0;         // Clear timeout flag
1282:Src/util.c    ****         timeoutCntSerial_L = 0;         // Reset timeout counter
1283:Src/util.c    ****         #endif
1284:Src/util.c    ****       } else if (usart_idx == 3) {      // Sideboard USART3
1285:Src/util.c    ****         #ifdef CONTROL_SERIAL_USART3
1286:Src/util.c    ****         timeoutFlgSerial_R = 0;         // Clear timeout flag
1287:Src/util.c    ****         timeoutCntSerial_R = 0;         // Reset timeout counter
1288:Src/util.c    ****         #endif
1289:Src/util.c    ****       }
1290:Src/util.c    ****     }
1291:Src/util.c    ****   }
1292:Src/util.c    ****   #endif
1293:Src/util.c    **** }
 1584              		.loc 1 1293 1 view .LVU402
 1585 000a 7047     		bx	lr
ARM GAS  /tmp/cchLDBog.s 			page 54


 1586              	.LVL91:
 1587              	.L110:
1276:Src/util.c    ****     checksum = (uint16_t)(command_in->start ^ command_in->steer ^ command_in->speed);
 1588              		.loc 1 1276 5 is_stmt 1 view .LVU403
1276:Src/util.c    ****     checksum = (uint16_t)(command_in->start ^ command_in->steer ^ command_in->speed);
 1589              		.loc 1 1276 37 is_stmt 0 view .LVU404
 1590 000c 1BB2     		sxth	r3, r3
1276:Src/util.c    ****     checksum = (uint16_t)(command_in->start ^ command_in->steer ^ command_in->speed);
 1591              		.loc 1 1276 57 view .LVU405
 1592 000e B0F902C0 		ldrsh	ip, [r0, #2]
1276:Src/util.c    ****     checksum = (uint16_t)(command_in->start ^ command_in->steer ^ command_in->speed);
 1593              		.loc 1 1276 45 view .LVU406
 1594 0012 83EA0C03 		eor	r3, r3, ip
1276:Src/util.c    ****     checksum = (uint16_t)(command_in->start ^ command_in->steer ^ command_in->speed);
 1595              		.loc 1 1276 77 view .LVU407
 1596 0016 B0F904C0 		ldrsh	ip, [r0, #4]
1276:Src/util.c    ****     checksum = (uint16_t)(command_in->start ^ command_in->steer ^ command_in->speed);
 1597              		.loc 1 1276 65 view .LVU408
 1598 001a 83EA0C03 		eor	r3, r3, ip
1276:Src/util.c    ****     checksum = (uint16_t)(command_in->start ^ command_in->steer ^ command_in->speed);
 1599              		.loc 1 1276 14 view .LVU409
 1600 001e 9BB2     		uxth	r3, r3
 1601              	.LVL92:
1277:Src/util.c    ****       *command_out = *command_in;
 1602              		.loc 1 1277 5 is_stmt 1 view .LVU410
1277:Src/util.c    ****       *command_out = *command_in;
 1603              		.loc 1 1277 19 is_stmt 0 view .LVU411
 1604 0020 B0F806C0 		ldrh	ip, [r0, #6]
1277:Src/util.c    ****       *command_out = *command_in;
 1605              		.loc 1 1277 8 view .LVU412
 1606 0024 9C45     		cmp	ip, r3
 1607 0026 F0D1     		bne	.L108
1278:Src/util.c    ****       if (usart_idx == 2) {             // Sideboard USART2
 1608              		.loc 1 1278 7 is_stmt 1 view .LVU413
1278:Src/util.c    ****       if (usart_idx == 2) {             // Sideboard USART2
 1609              		.loc 1 1278 20 is_stmt 0 view .LVU414
 1610 0028 D0F800C0 		ldr	ip, [r0]	@ unaligned
 1611 002c 4368     		ldr	r3, [r0, #4]	@ unaligned
 1612              	.LVL93:
1278:Src/util.c    ****       if (usart_idx == 2) {             // Sideboard USART2
 1613              		.loc 1 1278 20 view .LVU415
 1614 002e C1F800C0 		str	ip, [r1]	@ unaligned
 1615 0032 4B60     		str	r3, [r1, #4]	@ unaligned
1279:Src/util.c    ****         #ifdef CONTROL_SERIAL_USART2
 1616              		.loc 1 1279 7 is_stmt 1 view .LVU416
1279:Src/util.c    ****         #ifdef CONTROL_SERIAL_USART2
 1617              		.loc 1 1279 10 is_stmt 0 view .LVU417
 1618 0034 022A     		cmp	r2, #2
 1619 0036 E8D0     		beq	.L108
1284:Src/util.c    ****         #ifdef CONTROL_SERIAL_USART3
 1620              		.loc 1 1284 14 is_stmt 1 view .LVU418
1284:Src/util.c    ****         #ifdef CONTROL_SERIAL_USART3
 1621              		.loc 1 1284 17 is_stmt 0 view .LVU419
 1622 0038 032A     		cmp	r2, #3
 1623 003a E6D1     		bne	.L108
1286:Src/util.c    ****         timeoutCntSerial_R = 0;         // Reset timeout counter
 1624              		.loc 1 1286 9 is_stmt 1 view .LVU420
ARM GAS  /tmp/cchLDBog.s 			page 55


1286:Src/util.c    ****         timeoutCntSerial_R = 0;         // Reset timeout counter
 1625              		.loc 1 1286 28 is_stmt 0 view .LVU421
 1626 003c 0023     		movs	r3, #0
 1627 003e 024A     		ldr	r2, .L111
 1628              	.LVL94:
1286:Src/util.c    ****         timeoutCntSerial_R = 0;         // Reset timeout counter
 1629              		.loc 1 1286 28 view .LVU422
 1630 0040 1370     		strb	r3, [r2]
1287:Src/util.c    ****         #endif
 1631              		.loc 1 1287 9 is_stmt 1 view .LVU423
1287:Src/util.c    ****         #endif
 1632              		.loc 1 1287 28 is_stmt 0 view .LVU424
 1633 0042 024A     		ldr	r2, .L111+4
 1634 0044 1380     		strh	r3, [r2]	@ movhi
 1635              		.loc 1 1293 1 view .LVU425
 1636 0046 E0E7     		b	.L108
 1637              	.L112:
 1638              		.align	2
 1639              	.L111:
 1640 0048 00000000 		.word	timeoutFlgSerial_R
 1641 004c 00000000 		.word	timeoutCntSerial_R
 1642              		.cfi_endproc
 1643              	.LFE88:
 1645              		.section	.text.usart3_rx_check,"ax",%progbits
 1646              		.align	1
 1647              		.global	usart3_rx_check
 1648              		.syntax unified
 1649              		.thumb
 1650              		.thumb_func
 1652              	usart3_rx_check:
 1653              	.LFB87:
1164:Src/util.c    ****   #if defined(DEBUG_SERIAL_USART3) || defined(CONTROL_SERIAL_USART3) || defined(SIDEBOARD_SERIAL_US
 1654              		.loc 1 1164 1 is_stmt 1 view -0
 1655              		.cfi_startproc
 1656              		@ args = 0, pretend = 0, frame = 0
 1657              		@ frame_needed = 0, uses_anonymous_args = 0
 1658 0000 38B5     		push	{r3, r4, r5, lr}
 1659              	.LCFI13:
 1660              		.cfi_def_cfa_offset 16
 1661              		.cfi_offset 3, -16
 1662              		.cfi_offset 4, -12
 1663              		.cfi_offset 5, -8
 1664              		.cfi_offset 14, -4
1166:Src/util.c    ****   uint32_t pos;  
 1665              		.loc 1 1166 3 view .LVU427
1167:Src/util.c    ****   pos = rx_buffer_R_len - __HAL_DMA_GET_COUNTER(huart3.hdmarx);         // Calculate current positi
 1666              		.loc 1 1167 3 view .LVU428
1168:Src/util.c    ****   #endif
 1667              		.loc 1 1168 3 view .LVU429
1168:Src/util.c    ****   #endif
 1668              		.loc 1 1168 27 is_stmt 0 view .LVU430
 1669 0002 1F4B     		ldr	r3, .L123
 1670 0004 5B6B     		ldr	r3, [r3, #52]
 1671 0006 1B68     		ldr	r3, [r3]
 1672 0008 5C68     		ldr	r4, [r3, #4]
1168:Src/util.c    ****   #endif
 1673              		.loc 1 1168 7 view .LVU431
ARM GAS  /tmp/cchLDBog.s 			page 56


 1674 000a C4F14004 		rsb	r4, r4, #64
 1675              	.LVL95:
1188:Src/util.c    ****   if (pos != old_pos) {                                                 // Check change in received
 1676              		.loc 1 1188 3 is_stmt 1 view .LVU432
1189:Src/util.c    ****     ptr = (uint8_t *)&commandR_raw;                                     // Initialize the pointer w
 1677              		.loc 1 1189 3 view .LVU433
1189:Src/util.c    ****     ptr = (uint8_t *)&commandR_raw;                                     // Initialize the pointer w
 1678              		.loc 1 1189 11 is_stmt 0 view .LVU434
 1679 000e 1D4B     		ldr	r3, .L123+4
 1680 0010 1B68     		ldr	r3, [r3]
1189:Src/util.c    ****     ptr = (uint8_t *)&commandR_raw;                                     // Initialize the pointer w
 1681              		.loc 1 1189 6 view .LVU435
 1682 0012 A342     		cmp	r3, r4
 1683 0014 08D0     		beq	.L114
1190:Src/util.c    ****     if (pos > old_pos && (pos - old_pos) == commandR_len) {             // "Linear" buffer mode: ch
 1684              		.loc 1 1190 5 is_stmt 1 view .LVU436
 1685              	.LVL96:
1191:Src/util.c    ****       memcpy(ptr, &rx_buffer_R[old_pos], commandR_len);                 // Copy data. This is possi
 1686              		.loc 1 1191 5 view .LVU437
1191:Src/util.c    ****       memcpy(ptr, &rx_buffer_R[old_pos], commandR_len);                 // Copy data. This is possi
 1687              		.loc 1 1191 8 is_stmt 0 view .LVU438
 1688 0016 02D2     		bcs	.L115
1191:Src/util.c    ****       memcpy(ptr, &rx_buffer_R[old_pos], commandR_len);                 // Copy data. This is possi
 1689              		.loc 1 1191 31 discriminator 1 view .LVU439
 1690 0018 E21A     		subs	r2, r4, r3
1191:Src/util.c    ****       memcpy(ptr, &rx_buffer_R[old_pos], commandR_len);                 // Copy data. This is possi
 1691              		.loc 1 1191 23 discriminator 1 view .LVU440
 1692 001a 082A     		cmp	r2, #8
 1693 001c 09D0     		beq	.L119
 1694              	.L115:
1194:Src/util.c    ****       memcpy(ptr, &rx_buffer_R[old_pos], rx_buffer_R_len - old_pos);    // First copy data from the
 1695              		.loc 1 1194 12 is_stmt 1 view .LVU441
1194:Src/util.c    ****       memcpy(ptr, &rx_buffer_R[old_pos], rx_buffer_R_len - old_pos);    // First copy data from the
 1696              		.loc 1 1194 33 is_stmt 0 view .LVU442
 1697 001e C3F14005 		rsb	r5, r3, #64
1194:Src/util.c    ****       memcpy(ptr, &rx_buffer_R[old_pos], rx_buffer_R_len - old_pos);    // First copy data from the
 1698              		.loc 1 1194 43 view .LVU443
 1699 0022 2A19     		adds	r2, r5, r4
1194:Src/util.c    ****       memcpy(ptr, &rx_buffer_R[old_pos], rx_buffer_R_len - old_pos);    // First copy data from the
 1700              		.loc 1 1194 15 view .LVU444
 1701 0024 082A     		cmp	r2, #8
 1702 0026 13D0     		beq	.L120
 1703              	.LVL97:
 1704              	.L114:
1224:Src/util.c    ****   if (old_pos == rx_buffer_R_len) {                                     // Check and manually updat
 1705              		.loc 1 1224 3 is_stmt 1 view .LVU445
1224:Src/util.c    ****   if (old_pos == rx_buffer_R_len) {                                     // Check and manually updat
 1706              		.loc 1 1224 11 is_stmt 0 view .LVU446
 1707 0028 164B     		ldr	r3, .L123+4
 1708 002a 1C60     		str	r4, [r3]
1225:Src/util.c    ****     old_pos = 0;
 1709              		.loc 1 1225 3 is_stmt 1 view .LVU447
1225:Src/util.c    ****     old_pos = 0;
 1710              		.loc 1 1225 6 is_stmt 0 view .LVU448
 1711 002c 402C     		cmp	r4, #64
 1712 002e 23D0     		beq	.L121
 1713              	.L113:
ARM GAS  /tmp/cchLDBog.s 			page 57


1229:Src/util.c    **** 
 1714              		.loc 1 1229 1 view .LVU449
 1715 0030 38BD     		pop	{r3, r4, r5, pc}
 1716              	.LVL98:
 1717              	.L119:
1192:Src/util.c    ****       usart_process_command(&commandR_raw, &commandR, 3);               // Process data
 1718              		.loc 1 1192 7 is_stmt 1 view .LVU450
1192:Src/util.c    ****       usart_process_command(&commandR_raw, &commandR, 3);               // Process data
 1719              		.loc 1 1192 19 is_stmt 0 view .LVU451
 1720 0032 1549     		ldr	r1, .L123+8
 1721 0034 03EB010C 		add	ip, r3, r1
1192:Src/util.c    ****       usart_process_command(&commandR_raw, &commandR, 3);               // Process data
 1722              		.loc 1 1192 7 view .LVU452
 1723 0038 144D     		ldr	r5, .L123+12
 1724 003a 2A46     		mov	r2, r5
 1725 003c C858     		ldr	r0, [r1, r3]	@ unaligned
 1726 003e DCF80410 		ldr	r1, [ip, #4]	@ unaligned
 1727 0042 03C2     		stmia	r2!, {r0, r1}
1193:Src/util.c    ****     } else if ((rx_buffer_R_len - old_pos + pos) == commandR_len) {     // "Overflow" buffer mode: 
 1728              		.loc 1 1193 7 is_stmt 1 view .LVU453
 1729 0044 0322     		movs	r2, #3
 1730 0046 1249     		ldr	r1, .L123+16
 1731 0048 2846     		mov	r0, r5
 1732 004a FFF7FEFF 		bl	usart_process_command
 1733              	.LVL99:
 1734 004e EBE7     		b	.L114
 1735              	.L120:
1195:Src/util.c    ****       if (pos > 0) {                                                    // Check and continue with 
 1736              		.loc 1 1195 7 view .LVU454
 1737 0050 2A46     		mov	r2, r5
 1738 0052 0D49     		ldr	r1, .L123+8
 1739 0054 1944     		add	r1, r1, r3
 1740 0056 0D48     		ldr	r0, .L123+12
 1741 0058 FFF7FEFF 		bl	memcpy
 1742              	.LVL100:
1196:Src/util.c    ****         ptr += rx_buffer_R_len - old_pos;                               // Move to correct position
 1743              		.loc 1 1196 7 view .LVU455
1196:Src/util.c    ****         ptr += rx_buffer_R_len - old_pos;                               // Move to correct position
 1744              		.loc 1 1196 10 is_stmt 0 view .LVU456
 1745 005c 2CB9     		cbnz	r4, .L122
 1746              	.LVL101:
 1747              	.L116:
1200:Src/util.c    ****     }
 1748              		.loc 1 1200 7 is_stmt 1 view .LVU457
 1749 005e 0322     		movs	r2, #3
 1750 0060 0B49     		ldr	r1, .L123+16
 1751 0062 0A48     		ldr	r0, .L123+12
 1752 0064 FFF7FEFF 		bl	usart_process_command
 1753              	.LVL102:
 1754 0068 DEE7     		b	.L114
 1755              	.LVL103:
 1756              	.L122:
1197:Src/util.c    ****         memcpy(ptr, &rx_buffer_R[0], pos);                              // Copy remaining data
 1757              		.loc 1 1197 9 view .LVU458
1198:Src/util.c    ****       }
 1758              		.loc 1 1198 9 view .LVU459
 1759 006a 2246     		mov	r2, r4
ARM GAS  /tmp/cchLDBog.s 			page 58


 1760 006c 0649     		ldr	r1, .L123+8
 1761 006e 0748     		ldr	r0, .L123+12
 1762 0070 2844     		add	r0, r0, r5
 1763              	.LVL104:
1198:Src/util.c    ****       }
 1764              		.loc 1 1198 9 is_stmt 0 view .LVU460
 1765 0072 FFF7FEFF 		bl	memcpy
 1766              	.LVL105:
1198:Src/util.c    ****       }
 1767              		.loc 1 1198 9 view .LVU461
 1768 0076 F2E7     		b	.L116
 1769              	.LVL106:
 1770              	.L121:
1226:Src/util.c    ****   }
 1771              		.loc 1 1226 5 is_stmt 1 view .LVU462
1226:Src/util.c    ****   }
 1772              		.loc 1 1226 13 is_stmt 0 view .LVU463
 1773 0078 0022     		movs	r2, #0
 1774 007a 1A60     		str	r2, [r3]
1229:Src/util.c    **** 
 1775              		.loc 1 1229 1 view .LVU464
 1776 007c D8E7     		b	.L113
 1777              	.L124:
 1778 007e 00BF     		.align	2
 1779              	.L123:
 1780 0080 00000000 		.word	huart3
 1781 0084 00000000 		.word	old_pos.0
 1782 0088 00000000 		.word	rx_buffer_R
 1783 008c 00000000 		.word	commandR_raw
 1784 0090 00000000 		.word	commandR
 1785              		.cfi_endproc
 1786              	.LFE87:
 1788              		.section	.text.sideboardLeds,"ax",%progbits
 1789              		.align	1
 1790              		.global	sideboardLeds
 1791              		.syntax unified
 1792              		.thumb
 1793              		.thumb_func
 1795              	sideboardLeds:
 1796              	.LVL107:
 1797              	.LFB89:
1294:Src/util.c    **** #endif
1295:Src/util.c    **** 
1296:Src/util.c    **** /*
1297:Src/util.c    ****  * Process Sideboard Rx data
1298:Src/util.c    ****  * - if the Sideboard_in data is valid (correct START_FRAME and checksum) copy the Sideboard_in to 
1299:Src/util.c    ****  */
1300:Src/util.c    **** #if defined(SIDEBOARD_SERIAL_USART2) || defined(SIDEBOARD_SERIAL_USART3)
1301:Src/util.c    **** void usart_process_sideboard(SerialSideboard *Sideboard_in, SerialSideboard *Sideboard_out, uint8_t
1302:Src/util.c    **** {
1303:Src/util.c    ****   uint16_t checksum;
1304:Src/util.c    ****   if (Sideboard_in->start == SERIAL_START_FRAME) {
1305:Src/util.c    ****     checksum = (uint16_t)(Sideboard_in->start ^ Sideboard_in->pitch ^ Sideboard_in->dPitch ^ Sidebo
1306:Src/util.c    ****     if (Sideboard_in->checksum == checksum) {
1307:Src/util.c    ****       *Sideboard_out = *Sideboard_in;
1308:Src/util.c    ****       if (usart_idx == 2) {             // Sideboard USART2
1309:Src/util.c    ****         #ifdef SIDEBOARD_SERIAL_USART2
ARM GAS  /tmp/cchLDBog.s 			page 59


1310:Src/util.c    ****         timeoutCntSerial_L  = 0;        // Reset timeout counter
1311:Src/util.c    ****         timeoutFlgSerial_L = 0;         // Clear timeout flag
1312:Src/util.c    ****         #endif
1313:Src/util.c    ****       } else if (usart_idx == 3) {      // Sideboard USART3
1314:Src/util.c    ****         #ifdef SIDEBOARD_SERIAL_USART3
1315:Src/util.c    ****         timeoutCntSerial_R = 0;         // Reset timeout counter
1316:Src/util.c    ****         timeoutFlgSerial_R = 0;         // Clear timeout flag
1317:Src/util.c    ****         #endif
1318:Src/util.c    ****       }
1319:Src/util.c    ****     }
1320:Src/util.c    ****   }
1321:Src/util.c    **** }
1322:Src/util.c    **** #endif
1323:Src/util.c    **** 
1324:Src/util.c    **** 
1325:Src/util.c    **** /* =========================== Sideboard Functions =========================== */
1326:Src/util.c    **** 
1327:Src/util.c    **** /*
1328:Src/util.c    ****  * Sideboard LEDs Handling
1329:Src/util.c    ****  * This function manages the leds behavior connected to the sideboard
1330:Src/util.c    ****  */
1331:Src/util.c    **** void sideboardLeds(uint8_t *leds) {
 1798              		.loc 1 1331 35 is_stmt 1 view -0
 1799              		.cfi_startproc
 1800              		@ args = 0, pretend = 0, frame = 0
 1801              		@ frame_needed = 0, uses_anonymous_args = 0
 1802              		@ link register save eliminated.
1332:Src/util.c    ****   #if defined(SIDEBOARD_SERIAL_USART2) || defined(SIDEBOARD_SERIAL_USART3)
1333:Src/util.c    ****     // Enable flag: use LED4 (bottom Blue)
1334:Src/util.c    ****     // enable == 1, turn on led
1335:Src/util.c    ****     // enable == 0, blink led
1336:Src/util.c    ****     if (enable) {
1337:Src/util.c    ****       *leds |= LED4_SET;
1338:Src/util.c    ****     } else if (!enable && (main_loop_counter % 20 == 0)) {
1339:Src/util.c    ****       *leds ^= LED4_SET;
1340:Src/util.c    ****     }
1341:Src/util.c    **** 
1342:Src/util.c    ****     // Backward Drive: use LED5 (upper Blue)
1343:Src/util.c    ****     // backwardDrive == 1, blink led
1344:Src/util.c    ****     // backwardDrive == 0, turn off led
1345:Src/util.c    ****     if (backwardDrive && (main_loop_counter % 50 == 0)) {
1346:Src/util.c    ****       *leds ^= LED5_SET;
1347:Src/util.c    ****     }
1348:Src/util.c    **** 
1349:Src/util.c    ****     // Brake: use LED5 (upper Blue)
1350:Src/util.c    ****     // brakePressed == 1, turn on led
1351:Src/util.c    ****     // brakePressed == 0, turn off led
1352:Src/util.c    ****     #ifdef VARIANT_HOVERCAR
1353:Src/util.c    ****       if (brakePressed) {
1354:Src/util.c    ****         *leds |= LED5_SET;
1355:Src/util.c    ****       } else if (!brakePressed && !backwardDrive) {
1356:Src/util.c    ****         *leds &= ~LED5_SET;
1357:Src/util.c    ****       }
1358:Src/util.c    ****     #endif
1359:Src/util.c    **** 
1360:Src/util.c    ****     // Battery Level Indicator: use LED1, LED2, LED3
1361:Src/util.c    ****     if (main_loop_counter % BAT_BLINK_INTERVAL == 0) {              //  | RED (LED1) | YELLOW (LED3
ARM GAS  /tmp/cchLDBog.s 			page 60


1362:Src/util.c    ****       if (batVoltage < BAT_DEAD) {                                  //  |     0      |       0     
1363:Src/util.c    ****         *leds &= ~LED1_SET & ~LED3_SET & ~LED2_SET;
1364:Src/util.c    ****       } else if (batVoltage < BAT_LVL1) {                           //  |     B      |       0     
1365:Src/util.c    ****         *leds ^= LED1_SET;
1366:Src/util.c    ****         *leds &= ~LED3_SET & ~LED2_SET;
1367:Src/util.c    ****       } else if (batVoltage < BAT_LVL2) {                           //  |     1      |       0     
1368:Src/util.c    ****         *leds |= LED1_SET;
1369:Src/util.c    ****         *leds &= ~LED3_SET & ~LED2_SET;
1370:Src/util.c    ****       } else if (batVoltage < BAT_LVL3) {                           //  |     0      |       B     
1371:Src/util.c    ****         *leds ^= LED3_SET;
1372:Src/util.c    ****         *leds &= ~LED1_SET & ~LED2_SET;
1373:Src/util.c    ****       } else if (batVoltage < BAT_LVL4) {                           //  |     0      |       1     
1374:Src/util.c    ****         *leds |= LED3_SET;
1375:Src/util.c    ****         *leds &= ~LED1_SET & ~LED2_SET;
1376:Src/util.c    ****       } else if (batVoltage < BAT_LVL5) {                           //  |     0      |       0     
1377:Src/util.c    ****         *leds ^= LED2_SET;
1378:Src/util.c    ****         *leds &= ~LED1_SET & ~LED3_SET;
1379:Src/util.c    ****       } else {                                                      //  |     0      |       0     
1380:Src/util.c    ****         *leds |= LED2_SET;
1381:Src/util.c    ****         *leds &= ~LED1_SET & ~LED3_SET;
1382:Src/util.c    ****       }
1383:Src/util.c    ****     }
1384:Src/util.c    **** 
1385:Src/util.c    ****     // Error handling
1386:Src/util.c    ****     // Critical error:  LED1 on (RED)     + high pitch beep (hadled in main)
1387:Src/util.c    ****     // Soft error:      LED3 on (YELLOW)  + low  pitch beep (hadled in main)
1388:Src/util.c    ****     if (rtY_Left.z_errCode || rtY_Right.z_errCode) {
1389:Src/util.c    ****       *leds |= LED1_SET;
1390:Src/util.c    ****       *leds &= ~LED3_SET & ~LED2_SET;
1391:Src/util.c    ****     }
1392:Src/util.c    ****     if (timeoutFlgADC || timeoutFlgSerial) {
1393:Src/util.c    ****       *leds |= LED3_SET;
1394:Src/util.c    ****       *leds &= ~LED1_SET & ~LED2_SET;
1395:Src/util.c    ****     }
1396:Src/util.c    ****   #endif
1397:Src/util.c    **** }
 1803              		.loc 1 1397 1 view .LVU466
 1804 0000 7047     		bx	lr
 1805              		.cfi_endproc
 1806              	.LFE89:
 1808              		.section	.text.sideboardSensors,"ax",%progbits
 1809              		.align	1
 1810              		.global	sideboardSensors
 1811              		.syntax unified
 1812              		.thumb
 1813              		.thumb_func
 1815              	sideboardSensors:
 1816              	.LVL108:
 1817              	.LFB90:
1398:Src/util.c    **** 
1399:Src/util.c    **** /*
1400:Src/util.c    ****  * Sideboard Sensor Handling
1401:Src/util.c    ****  * This function manages the sideboards photo sensors.
1402:Src/util.c    ****  * In non-hoverboard variants, the sensors are used as push buttons.
1403:Src/util.c    ****  */
1404:Src/util.c    **** void sideboardSensors(uint8_t sensors) {
 1818              		.loc 1 1404 40 view -0
ARM GAS  /tmp/cchLDBog.s 			page 61


 1819              		.cfi_startproc
 1820              		@ args = 0, pretend = 0, frame = 0
 1821              		@ frame_needed = 0, uses_anonymous_args = 0
 1822              		@ link register save eliminated.
1405:Src/util.c    ****   #if !defined(VARIANT_HOVERBOARD) && (defined(SIDEBOARD_SERIAL_USART2) || defined(SIDEBOARD_SERIAL
1406:Src/util.c    ****     static uint8_t sensor1_index;                                 // holds the press index number f
1407:Src/util.c    ****     static uint8_t sensor1_prev,  sensor2_prev;
1408:Src/util.c    ****     uint8_t sensor1_trig = 0, sensor2_trig = 0;
1409:Src/util.c    ****     #if defined(SIDEBOARD_SERIAL_USART2)
1410:Src/util.c    ****     uint8_t  sideboardIdx = SIDEBOARD_SERIAL_USART2;
1411:Src/util.c    ****     uint16_t sideboardSns = Sideboard_L.sensors;
1412:Src/util.c    ****     #else
1413:Src/util.c    ****     uint8_t  sideboardIdx = SIDEBOARD_SERIAL_USART3;
1414:Src/util.c    ****     uint16_t sideboardSns = Sideboard_R.sensors;
1415:Src/util.c    ****     #endif
1416:Src/util.c    **** 
1417:Src/util.c    ****     if (inIdx == sideboardIdx) {                                  // Use Sideboard data
1418:Src/util.c    ****       sensor1_index = 2 + ((sideboardSns & SWB_SET) >> 9);        // SWB on RC transmitter is used 
1419:Src/util.c    ****       if (sensor1_index == 2) {                                   // FOC control Type
1420:Src/util.c    ****         sensor1_index = (sideboardSns & SWC_SET) >> 11;           // SWC on RC transmitter is used 
1421:Src/util.c    ****       }
1422:Src/util.c    ****       sensor1_trig  = sensor1_index != sensor1_prev;              // rising or falling edge change 
1423:Src/util.c    ****       if (inIdx != inIdx_prev) {                                  // Force one update at Input idx 
1424:Src/util.c    ****         sensor1_trig  = 1;
1425:Src/util.c    ****       }
1426:Src/util.c    ****       sensor1_prev  = sensor1_index;
1427:Src/util.c    ****     } else {                                                      // Use Optical switches
1428:Src/util.c    ****       sensor1_trig  = (sensors & SENSOR1_SET) && !sensor1_prev;   // rising edge detection
1429:Src/util.c    ****       sensor1_prev  =  sensors & SENSOR1_SET;
1430:Src/util.c    ****     }
1431:Src/util.c    **** 
1432:Src/util.c    ****     // Control MODE and Control Type Handling
1433:Src/util.c    ****     if (sensor1_trig) {
1434:Src/util.c    ****       switch (sensor1_index) {
1435:Src/util.c    ****         case 0:     // FOC VOLTAGE
1436:Src/util.c    ****           rtP_Left.z_ctrlTypSel = rtP_Right.z_ctrlTypSel = FOC_CTRL;
1437:Src/util.c    ****           ctrlModReqRaw         = VLT_MODE;
1438:Src/util.c    ****           break;
1439:Src/util.c    ****         case 1:     // FOC SPEED
1440:Src/util.c    ****           rtP_Left.z_ctrlTypSel = rtP_Right.z_ctrlTypSel = FOC_CTRL;
1441:Src/util.c    ****           ctrlModReqRaw         = SPD_MODE;
1442:Src/util.c    ****           break;
1443:Src/util.c    ****         case 2:     // FOC TORQUE
1444:Src/util.c    ****           rtP_Left.z_ctrlTypSel = rtP_Right.z_ctrlTypSel = FOC_CTRL;
1445:Src/util.c    ****           ctrlModReqRaw         = TRQ_MODE;
1446:Src/util.c    ****           break;
1447:Src/util.c    ****         case 3:     // SINUSOIDAL
1448:Src/util.c    ****           rtP_Left.z_ctrlTypSel = rtP_Right.z_ctrlTypSel = SIN_CTRL;
1449:Src/util.c    ****           break;
1450:Src/util.c    ****         case 4:     // COMMUTATION
1451:Src/util.c    ****           rtP_Left.z_ctrlTypSel = rtP_Right.z_ctrlTypSel = COM_CTRL;
1452:Src/util.c    ****           break;
1453:Src/util.c    ****       }
1454:Src/util.c    ****       if (inIdx == inIdx_prev) { beepShortMany(sensor1_index + 1, 1); }
1455:Src/util.c    ****       if (++sensor1_index > 4) { sensor1_index = 0; }
1456:Src/util.c    ****     }
1457:Src/util.c    **** 
ARM GAS  /tmp/cchLDBog.s 			page 62


1458:Src/util.c    ****                                                              // Field Weakening Activation/Deactiva
1459:Src/util.c    ****       static uint8_t  sensor2_index = 1;                          // holds the press index number f
1460:Src/util.c    **** 
1461:Src/util.c    ****       // Override in case the Sideboard control is Active
1462:Src/util.c    ****       if (inIdx == sideboardIdx) {                                // Use Sideboard data
1463:Src/util.c    ****         sensor2_index = (sideboardSns & SWD_SET) >> 13;           // SWD on RC transmitter is used 
1464:Src/util.c    ****         sensor2_trig  = sensor2_index != sensor2_prev;            // rising or falling edge change 
1465:Src/util.c    ****         if (inIdx != inIdx_prev) {                                // Force one update at Input idx 
1466:Src/util.c    ****           sensor2_trig  = 1;
1467:Src/util.c    ****         }
1468:Src/util.c    ****         sensor2_prev  = sensor2_index;
1469:Src/util.c    ****       }else{
1470:Src/util.c    ****         sensor2_trig  = (sensors & SENSOR2_SET) && !sensor2_prev;   // rising edge detection
1471:Src/util.c    ****         sensor2_prev  =  sensors & SENSOR2_SET;
1472:Src/util.c    ****       }
1473:Src/util.c    **** 
1474:Src/util.c    ****       #ifdef CRUISE_CONTROL_SUPPORT                                 // Cruise Control Activation/De
1475:Src/util.c    ****         if (sensor2_trig) {
1476:Src/util.c    ****           cruiseControl(sensor2_trig);
1477:Src/util.c    ****         }
1478:Src/util.c    ****       #else
1479:Src/util.c    ****         if (sensor2_trig) {
1480:Src/util.c    ****           switch (sensor2_index) {
1481:Src/util.c    ****             case 0:     // FW Disabled
1482:Src/util.c    ****               rtP_Left.b_fieldWeakEna  = 0; 
1483:Src/util.c    ****               rtP_Right.b_fieldWeakEna = 0;
1484:Src/util.c    ****               Input_Lim_Init();
1485:Src/util.c    ****               break;
1486:Src/util.c    ****             case 1:     // FW Enabled
1487:Src/util.c    ****               rtP_Left.b_fieldWeakEna  = 1; 
1488:Src/util.c    ****               rtP_Right.b_fieldWeakEna = 1;
1489:Src/util.c    ****               Input_Lim_Init();
1490:Src/util.c    ****               break; 
1491:Src/util.c    ****           }
1492:Src/util.c    ****           if (inIdx == inIdx_prev) { beepShortMany(sensor2_index + 1, 1); }
1493:Src/util.c    ****           if (++sensor2_index > 1) { sensor2_index = 0; }
1494:Src/util.c    ****         }
1495:Src/util.c    ****       #endif  // CRUISE_CONTROL_SUPPORT
1496:Src/util.c    ****   #endif
1497:Src/util.c    **** }
 1823              		.loc 1 1497 1 view .LVU468
 1824 0000 7047     		bx	lr
 1825              		.cfi_endproc
 1826              	.LFE90:
 1828              		.section	.text.saveConfig,"ax",%progbits
 1829              		.align	1
 1830              		.global	saveConfig
 1831              		.syntax unified
 1832              		.thumb
 1833              		.thumb_func
 1835              	saveConfig:
 1836              	.LFB91:
1498:Src/util.c    **** 
1499:Src/util.c    **** 
1500:Src/util.c    **** 
1501:Src/util.c    **** /* =========================== Poweroff Functions =========================== */
1502:Src/util.c    **** 
ARM GAS  /tmp/cchLDBog.s 			page 63


1503:Src/util.c    ****  /*
1504:Src/util.c    ****  * Save Configuration to Flash
1505:Src/util.c    ****  * This function makes sure data is not lost after power-off
1506:Src/util.c    ****  */
1507:Src/util.c    **** void saveConfig() {
 1837              		.loc 1 1507 19 view -0
 1838              		.cfi_startproc
 1839              		@ args = 0, pretend = 0, frame = 0
 1840              		@ frame_needed = 0, uses_anonymous_args = 0
 1841 0000 2DE9F843 		push	{r3, r4, r5, r6, r7, r8, r9, lr}
 1842              	.LCFI14:
 1843              		.cfi_def_cfa_offset 32
 1844              		.cfi_offset 3, -32
 1845              		.cfi_offset 4, -28
 1846              		.cfi_offset 5, -24
 1847              		.cfi_offset 6, -20
 1848              		.cfi_offset 7, -16
 1849              		.cfi_offset 8, -12
 1850              		.cfi_offset 9, -8
 1851              		.cfi_offset 14, -4
1508:Src/util.c    ****   #ifdef VARIANT_TRANSPOTTER
1509:Src/util.c    ****     if (saveValue_valid) {
1510:Src/util.c    ****       HAL_FLASH_Unlock();
1511:Src/util.c    ****       EE_WriteVariable(VirtAddVarTab[0], saveValue);
1512:Src/util.c    ****       HAL_FLASH_Lock();
1513:Src/util.c    ****     }
1514:Src/util.c    ****   #endif
1515:Src/util.c    ****   #if !defined(VARIANT_HOVERBOARD) && !defined(VARIANT_TRANSPOTTER)
1516:Src/util.c    ****     if (inp_cal_valid || cur_spd_valid) {
 1852              		.loc 1 1516 5 view .LVU470
 1853              		.loc 1 1516 9 is_stmt 0 view .LVU471
 1854 0004 374B     		ldr	r3, .L133
 1855 0006 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1856              		.loc 1 1516 8 view .LVU472
 1857 0008 13B9     		cbnz	r3, .L128
 1858              		.loc 1 1516 23 discriminator 1 view .LVU473
 1859 000a 374B     		ldr	r3, .L133+4
 1860 000c 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1861 000e C3B1     		cbz	r3, .L127
 1862              	.L128:
1517:Src/util.c    ****       #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
1518:Src/util.c    ****         printf("Saving configuration to EEprom\r\n");
1519:Src/util.c    ****       #endif
1520:Src/util.c    **** 
1521:Src/util.c    ****       HAL_FLASH_Unlock();
 1863              		.loc 1 1521 7 is_stmt 1 view .LVU474
 1864 0010 FFF7FEFF 		bl	HAL_FLASH_Unlock
 1865              	.LVL109:
1522:Src/util.c    ****       EE_WriteVariable(VirtAddVarTab[0] , (uint16_t)FLASH_WRITE_KEY);
 1866              		.loc 1 1522 7 view .LVU475
 1867 0014 354C     		ldr	r4, .L133+8
 1868 0016 41F20201 		movw	r1, #4098
 1869 001a 2088     		ldrh	r0, [r4]
 1870 001c FFF7FEFF 		bl	EE_WriteVariable
 1871              	.LVL110:
1523:Src/util.c    ****       EE_WriteVariable(VirtAddVarTab[1] , (uint16_t)rtP_Left.i_max);
 1872              		.loc 1 1523 7 view .LVU476
ARM GAS  /tmp/cchLDBog.s 			page 64


 1873              		.loc 1 1523 61 is_stmt 0 view .LVU477
 1874 0020 334D     		ldr	r5, .L133+12
 1875 0022 B5F9CE10 		ldrsh	r1, [r5, #206]
 1876              		.loc 1 1523 7 view .LVU478
 1877 0026 89B2     		uxth	r1, r1
 1878 0028 6088     		ldrh	r0, [r4, #2]
 1879 002a FFF7FEFF 		bl	EE_WriteVariable
 1880              	.LVL111:
1524:Src/util.c    ****       EE_WriteVariable(VirtAddVarTab[2] , (uint16_t)rtP_Left.n_max);
 1881              		.loc 1 1524 7 is_stmt 1 view .LVU479
 1882              		.loc 1 1524 61 is_stmt 0 view .LVU480
 1883 002e B5F9DA10 		ldrsh	r1, [r5, #218]
 1884              		.loc 1 1524 7 view .LVU481
 1885 0032 89B2     		uxth	r1, r1
 1886 0034 A088     		ldrh	r0, [r4, #4]
 1887 0036 FFF7FEFF 		bl	EE_WriteVariable
 1888              	.LVL112:
1525:Src/util.c    ****       for (uint8_t i=0; i<INPUTS_NR; i++) {
 1889              		.loc 1 1525 7 is_stmt 1 view .LVU482
 1890              	.LBB9:
 1891              		.loc 1 1525 12 view .LVU483
 1892              		.loc 1 1525 20 is_stmt 0 view .LVU484
 1893 003a 0025     		movs	r5, #0
 1894              	.LVL113:
 1895              	.L130:
 1896              		.loc 1 1525 26 is_stmt 1 discriminator 1 view .LVU485
 1897 003c 1DB1     		cbz	r5, .L131
 1898              	.LBE9:
1526:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 3+8*i] , (uint16_t)input1[i].typ);
1527:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 4+8*i] , (uint16_t)input1[i].min);
1528:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 5+8*i] , (uint16_t)input1[i].mid);
1529:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 6+8*i] , (uint16_t)input1[i].max);
1530:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 7+8*i] , (uint16_t)input2[i].typ);
1531:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 8+8*i] , (uint16_t)input2[i].min);
1532:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 9+8*i] , (uint16_t)input2[i].mid);
1533:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[10+8*i] , (uint16_t)input2[i].max);
1534:Src/util.c    ****       }
1535:Src/util.c    ****       HAL_FLASH_Lock();
 1899              		.loc 1 1535 7 view .LVU486
 1900 003e FFF7FEFF 		bl	HAL_FLASH_Lock
 1901              	.LVL114:
 1902              	.L127:
1536:Src/util.c    ****     }
1537:Src/util.c    ****   #endif 
1538:Src/util.c    **** }
 1903              		.loc 1 1538 1 is_stmt 0 view .LVU487
 1904 0042 BDE8F883 		pop	{r3, r4, r5, r6, r7, r8, r9, pc}
 1905              	.LVL115:
 1906              	.L131:
 1907              	.LBB10:
1526:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 3+8*i] , (uint16_t)input1[i].typ);
 1908              		.loc 1 1526 9 is_stmt 1 view .LVU488
1526:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 3+8*i] , (uint16_t)input1[i].typ);
 1909              		.loc 1 1526 44 is_stmt 0 view .LVU489
 1910 0046 EC00     		lsls	r4, r5, #3
1526:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 3+8*i] , (uint16_t)input1[i].typ);
 1911              		.loc 1 1526 42 view .LVU490
ARM GAS  /tmp/cchLDBog.s 			page 65


 1912 0048 E01C     		adds	r0, r4, #3
1526:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 3+8*i] , (uint16_t)input1[i].typ);
 1913              		.loc 1 1526 69 view .LVU491
 1914 004a 621B     		subs	r2, r4, r5
 1915 004c 5300     		lsls	r3, r2, #1
 1916 004e 294F     		ldr	r7, .L133+16
 1917 0050 1F44     		add	r7, r7, r3
1526:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 3+8*i] , (uint16_t)input1[i].typ);
 1918              		.loc 1 1526 9 view .LVU492
 1919 0052 264E     		ldr	r6, .L133+8
 1920 0054 3979     		ldrb	r1, [r7, #4]	@ zero_extendqisi2
 1921 0056 36F81000 		ldrh	r0, [r6, r0, lsl #1]
 1922 005a FFF7FEFF 		bl	EE_WriteVariable
 1923              	.LVL116:
1527:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 5+8*i] , (uint16_t)input1[i].mid);
 1924              		.loc 1 1527 9 is_stmt 1 view .LVU493
1527:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 5+8*i] , (uint16_t)input1[i].mid);
 1925              		.loc 1 1527 42 is_stmt 0 view .LVU494
 1926 005e 231D     		adds	r3, r4, #4
1527:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 5+8*i] , (uint16_t)input1[i].mid);
 1927              		.loc 1 1527 69 view .LVU495
 1928 0060 B7F90610 		ldrsh	r1, [r7, #6]
1527:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 5+8*i] , (uint16_t)input1[i].mid);
 1929              		.loc 1 1527 9 view .LVU496
 1930 0064 89B2     		uxth	r1, r1
 1931 0066 36F81300 		ldrh	r0, [r6, r3, lsl #1]
 1932 006a FFF7FEFF 		bl	EE_WriteVariable
 1933              	.LVL117:
1528:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 6+8*i] , (uint16_t)input1[i].max);
 1934              		.loc 1 1528 9 is_stmt 1 view .LVU497
1528:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 6+8*i] , (uint16_t)input1[i].max);
 1935              		.loc 1 1528 42 is_stmt 0 view .LVU498
 1936 006e 631D     		adds	r3, r4, #5
1528:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 6+8*i] , (uint16_t)input1[i].max);
 1937              		.loc 1 1528 69 view .LVU499
 1938 0070 B7F90810 		ldrsh	r1, [r7, #8]
1528:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 6+8*i] , (uint16_t)input1[i].max);
 1939              		.loc 1 1528 9 view .LVU500
 1940 0074 89B2     		uxth	r1, r1
 1941 0076 36F81300 		ldrh	r0, [r6, r3, lsl #1]
 1942 007a FFF7FEFF 		bl	EE_WriteVariable
 1943              	.LVL118:
1529:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 7+8*i] , (uint16_t)input2[i].typ);
 1944              		.loc 1 1529 9 is_stmt 1 view .LVU501
1529:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 7+8*i] , (uint16_t)input2[i].typ);
 1945              		.loc 1 1529 42 is_stmt 0 view .LVU502
 1946 007e A31D     		adds	r3, r4, #6
1529:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 7+8*i] , (uint16_t)input2[i].typ);
 1947              		.loc 1 1529 69 view .LVU503
 1948 0080 B7F90A10 		ldrsh	r1, [r7, #10]
1529:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 7+8*i] , (uint16_t)input2[i].typ);
 1949              		.loc 1 1529 9 view .LVU504
 1950 0084 89B2     		uxth	r1, r1
 1951 0086 36F81300 		ldrh	r0, [r6, r3, lsl #1]
 1952 008a FFF7FEFF 		bl	EE_WriteVariable
 1953              	.LVL119:
1530:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 8+8*i] , (uint16_t)input2[i].min);
ARM GAS  /tmp/cchLDBog.s 			page 66


 1954              		.loc 1 1530 9 is_stmt 1 view .LVU505
1530:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 8+8*i] , (uint16_t)input2[i].min);
 1955              		.loc 1 1530 42 is_stmt 0 view .LVU506
 1956 008e E21D     		adds	r2, r4, #7
1530:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 8+8*i] , (uint16_t)input2[i].min);
 1957              		.loc 1 1530 69 view .LVU507
 1958 0090 DFF86480 		ldr	r8, .L133+20
 1959 0094 631B     		subs	r3, r4, r5
 1960 0096 5F00     		lsls	r7, r3, #1
 1961 0098 4744     		add	r7, r7, r8
1530:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 8+8*i] , (uint16_t)input2[i].min);
 1962              		.loc 1 1530 9 view .LVU508
 1963 009a 3979     		ldrb	r1, [r7, #4]	@ zero_extendqisi2
 1964 009c 36F81200 		ldrh	r0, [r6, r2, lsl #1]
 1965 00a0 FFF7FEFF 		bl	EE_WriteVariable
 1966              	.LVL120:
1531:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 9+8*i] , (uint16_t)input2[i].mid);
 1967              		.loc 1 1531 9 is_stmt 1 view .LVU509
1531:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 9+8*i] , (uint16_t)input2[i].mid);
 1968              		.loc 1 1531 42 is_stmt 0 view .LVU510
 1969 00a4 05F10109 		add	r9, r5, #1
 1970 00a8 4FEAC903 		lsl	r3, r9, #3
1531:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 9+8*i] , (uint16_t)input2[i].mid);
 1971              		.loc 1 1531 69 view .LVU511
 1972 00ac B7F90610 		ldrsh	r1, [r7, #6]
1531:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 9+8*i] , (uint16_t)input2[i].mid);
 1973              		.loc 1 1531 9 view .LVU512
 1974 00b0 89B2     		uxth	r1, r1
 1975 00b2 36F81300 		ldrh	r0, [r6, r3, lsl #1]
 1976 00b6 FFF7FEFF 		bl	EE_WriteVariable
 1977              	.LVL121:
1532:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[10+8*i] , (uint16_t)input2[i].max);
 1978              		.loc 1 1532 9 is_stmt 1 view .LVU513
1532:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[10+8*i] , (uint16_t)input2[i].max);
 1979              		.loc 1 1532 42 is_stmt 0 view .LVU514
 1980 00ba 04F10903 		add	r3, r4, #9
1532:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[10+8*i] , (uint16_t)input2[i].max);
 1981              		.loc 1 1532 69 view .LVU515
 1982 00be B7F90810 		ldrsh	r1, [r7, #8]
1532:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[10+8*i] , (uint16_t)input2[i].max);
 1983              		.loc 1 1532 9 view .LVU516
 1984 00c2 89B2     		uxth	r1, r1
 1985 00c4 36F81300 		ldrh	r0, [r6, r3, lsl #1]
 1986 00c8 FFF7FEFF 		bl	EE_WriteVariable
 1987              	.LVL122:
1533:Src/util.c    ****       }
 1988              		.loc 1 1533 9 is_stmt 1 view .LVU517
1533:Src/util.c    ****       }
 1989              		.loc 1 1533 42 is_stmt 0 view .LVU518
 1990 00cc 04F10A02 		add	r2, r4, #10
1533:Src/util.c    ****       }
 1991              		.loc 1 1533 69 view .LVU519
 1992 00d0 B7F90A10 		ldrsh	r1, [r7, #10]
1533:Src/util.c    ****       }
 1993              		.loc 1 1533 9 view .LVU520
 1994 00d4 89B2     		uxth	r1, r1
 1995 00d6 36F81200 		ldrh	r0, [r6, r2, lsl #1]
ARM GAS  /tmp/cchLDBog.s 			page 67


 1996 00da FFF7FEFF 		bl	EE_WriteVariable
 1997              	.LVL123:
1525:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 3+8*i] , (uint16_t)input1[i].typ);
 1998              		.loc 1 1525 39 is_stmt 1 discriminator 3 view .LVU521
 1999 00de 5FFA89F5 		uxtb	r5, r9
 2000              	.LVL124:
1525:Src/util.c    ****         EE_WriteVariable(VirtAddVarTab[ 3+8*i] , (uint16_t)input1[i].typ);
 2001              		.loc 1 1525 39 is_stmt 0 discriminator 3 view .LVU522
 2002 00e2 ABE7     		b	.L130
 2003              	.L134:
 2004              		.align	2
 2005              	.L133:
 2006 00e4 00000000 		.word	inp_cal_valid
 2007 00e8 00000000 		.word	cur_spd_valid
 2008 00ec 00000000 		.word	VirtAddVarTab
 2009 00f0 00000000 		.word	rtP_Left
 2010 00f4 00000000 		.word	input1
 2011 00f8 00000000 		.word	input2
 2012              	.LBE10:
 2013              		.cfi_endproc
 2014              	.LFE91:
 2016              		.section	.text.poweroff,"ax",%progbits
 2017              		.align	1
 2018              		.global	poweroff
 2019              		.syntax unified
 2020              		.thumb
 2021              		.thumb_func
 2023              	poweroff:
 2024              	.LFB92:
1539:Src/util.c    **** 
1540:Src/util.c    **** 
1541:Src/util.c    **** void poweroff(void) {
 2025              		.loc 1 1541 21 is_stmt 1 view -0
 2026              		.cfi_startproc
 2027              		@ args = 0, pretend = 0, frame = 0
 2028              		@ frame_needed = 0, uses_anonymous_args = 0
 2029 0000 10B5     		push	{r4, lr}
 2030              	.LCFI15:
 2031              		.cfi_def_cfa_offset 8
 2032              		.cfi_offset 4, -8
 2033              		.cfi_offset 14, -4
1542:Src/util.c    ****   enable = 0;
 2034              		.loc 1 1542 3 view .LVU524
 2035              		.loc 1 1542 10 is_stmt 0 view .LVU525
 2036 0002 0024     		movs	r4, #0
 2037 0004 0B4B     		ldr	r3, .L140
 2038 0006 1C70     		strb	r4, [r3]
1543:Src/util.c    ****   #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
1544:Src/util.c    ****   printf("-- Motors disabled --\r\n");
1545:Src/util.c    ****   #endif
1546:Src/util.c    ****   buzzerCount = 0;  // prevent interraction with beep counter
 2039              		.loc 1 1546 3 is_stmt 1 view .LVU526
 2040              		.loc 1 1546 15 is_stmt 0 view .LVU527
 2041 0008 0B4B     		ldr	r3, .L140+4
 2042 000a 1C70     		strb	r4, [r3]
1547:Src/util.c    ****   buzzerPattern = 0;
 2043              		.loc 1 1547 3 is_stmt 1 view .LVU528
ARM GAS  /tmp/cchLDBog.s 			page 68


 2044              		.loc 1 1547 17 is_stmt 0 view .LVU529
 2045 000c 0B4B     		ldr	r3, .L140+8
 2046 000e 1C70     		strb	r4, [r3]
1548:Src/util.c    ****   for (int i = 0; i < 8; i++) {
 2047              		.loc 1 1548 3 is_stmt 1 view .LVU530
 2048              	.LBB11:
 2049              		.loc 1 1548 8 view .LVU531
 2050              	.LVL125:
 2051              		.loc 1 1548 3 is_stmt 0 view .LVU532
 2052 0010 05E0     		b	.L136
 2053              	.LVL126:
 2054              	.L137:
1549:Src/util.c    ****     buzzerFreq = (uint8_t)i;
 2055              		.loc 1 1549 5 is_stmt 1 view .LVU533
 2056              		.loc 1 1549 16 is_stmt 0 view .LVU534
 2057 0012 0B4B     		ldr	r3, .L140+12
 2058 0014 1C70     		strb	r4, [r3]
1550:Src/util.c    ****     HAL_Delay(100);
 2059              		.loc 1 1550 5 is_stmt 1 view .LVU535
 2060 0016 6420     		movs	r0, #100
 2061 0018 FFF7FEFF 		bl	HAL_Delay
 2062              	.LVL127:
1548:Src/util.c    ****   for (int i = 0; i < 8; i++) {
 2063              		.loc 1 1548 27 discriminator 3 view .LVU536
 2064 001c 0134     		adds	r4, r4, #1
 2065              	.LVL128:
 2066              	.L136:
1548:Src/util.c    ****   for (int i = 0; i < 8; i++) {
 2067              		.loc 1 1548 21 discriminator 1 view .LVU537
 2068 001e 072C     		cmp	r4, #7
 2069 0020 F7DD     		ble	.L137
 2070              	.LBE11:
1551:Src/util.c    ****   }
1552:Src/util.c    ****   saveConfig();
 2071              		.loc 1 1552 3 view .LVU538
 2072 0022 FFF7FEFF 		bl	saveConfig
 2073              	.LVL129:
1553:Src/util.c    ****   HAL_GPIO_WritePin(OFF_PORT, OFF_PIN, GPIO_PIN_RESET);
 2074              		.loc 1 1553 3 view .LVU539
 2075 0026 0022     		movs	r2, #0
 2076 0028 2021     		movs	r1, #32
 2077 002a 0648     		ldr	r0, .L140+16
 2078 002c FFF7FEFF 		bl	HAL_GPIO_WritePin
 2079              	.LVL130:
 2080              	.L138:
1554:Src/util.c    ****   while(1) {}
 2081              		.loc 1 1554 3 view .LVU540
 2082              		.loc 1 1554 13 view .LVU541
 2083              		.loc 1 1554 8 view .LVU542
 2084 0030 FEE7     		b	.L138
 2085              	.L141:
 2086 0032 00BF     		.align	2
 2087              	.L140:
 2088 0034 00000000 		.word	enable
 2089 0038 00000000 		.word	buzzerCount
 2090 003c 00000000 		.word	buzzerPattern
 2091 0040 00000000 		.word	buzzerFreq
ARM GAS  /tmp/cchLDBog.s 			page 69


 2092 0044 00080140 		.word	1073809408
 2093              		.cfi_endproc
 2094              	.LFE92:
 2096              		.section	.text.filtLowPass32,"ax",%progbits
 2097              		.align	1
 2098              		.global	filtLowPass32
 2099              		.syntax unified
 2100              		.thumb
 2101              		.thumb_func
 2103              	filtLowPass32:
 2104              	.LVL131:
 2105              	.LFB94:
1555:Src/util.c    **** }
1556:Src/util.c    **** 
1557:Src/util.c    **** 
1558:Src/util.c    **** void poweroffPressCheck(void) {
1559:Src/util.c    ****   #if !defined(VARIANT_HOVERBOARD) && !defined(VARIANT_TRANSPOTTER)
1560:Src/util.c    ****     if(HAL_GPIO_ReadPin(BUTTON_PORT, BUTTON_PIN)) {
1561:Src/util.c    ****       uint16_t cnt_press = 0;
1562:Src/util.c    ****       while(HAL_GPIO_ReadPin(BUTTON_PORT, BUTTON_PIN)) {
1563:Src/util.c    ****         HAL_Delay(10);
1564:Src/util.c    ****         if (cnt_press++ == 5 * 100) { beepShort(5); }
1565:Src/util.c    ****       }
1566:Src/util.c    **** 
1567:Src/util.c    ****       if (cnt_press > 8) enable = 0;
1568:Src/util.c    **** 
1569:Src/util.c    ****       if (cnt_press >= 5 * 100) {                         // Check if press is more than 5 sec
1570:Src/util.c    ****         HAL_Delay(1000);
1571:Src/util.c    ****         if (HAL_GPIO_ReadPin(BUTTON_PORT, BUTTON_PIN)) {  // Double press: Adjust Max Current, Max 
1572:Src/util.c    ****           while(HAL_GPIO_ReadPin(BUTTON_PORT, BUTTON_PIN)) { HAL_Delay(10); }
1573:Src/util.c    ****           beepLong(8);
1574:Src/util.c    ****           updateCurSpdLim();
1575:Src/util.c    ****           beepShort(5);
1576:Src/util.c    ****         } else {                                          // Long press: Calibrate ADC Limits
1577:Src/util.c    ****           #ifdef AUTO_CALIBRATION_ENA
1578:Src/util.c    ****           beepLong(16); 
1579:Src/util.c    ****           adcCalibLim();
1580:Src/util.c    ****           beepShort(5);
1581:Src/util.c    ****           #endif
1582:Src/util.c    ****         }
1583:Src/util.c    ****       } else if (cnt_press > 8) {                         // Short press: power off (80 ms debounce
1584:Src/util.c    ****         #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
1585:Src/util.c    ****           printf("Powering off, button has been pressed\r\n");
1586:Src/util.c    ****         #endif
1587:Src/util.c    ****       poweroff();
1588:Src/util.c    ****       }
1589:Src/util.c    ****     }
1590:Src/util.c    ****   #elif defined(VARIANT_TRANSPOTTER)
1591:Src/util.c    ****     if(HAL_GPIO_ReadPin(BUTTON_PORT, BUTTON_PIN)) {
1592:Src/util.c    ****       enable = 0;
1593:Src/util.c    ****       while(HAL_GPIO_ReadPin(BUTTON_PORT, BUTTON_PIN)) { HAL_Delay(10); }
1594:Src/util.c    ****       beepShort(5);
1595:Src/util.c    ****       HAL_Delay(300);
1596:Src/util.c    ****       if (HAL_GPIO_ReadPin(BUTTON_PORT, BUTTON_PIN)) {
1597:Src/util.c    ****         while(HAL_GPIO_ReadPin(BUTTON_PORT, BUTTON_PIN)) { HAL_Delay(10); }
1598:Src/util.c    ****         beepLong(5);
1599:Src/util.c    ****         HAL_Delay(350);
ARM GAS  /tmp/cchLDBog.s 			page 70


1600:Src/util.c    ****         poweroff();
1601:Src/util.c    ****       } else {
1602:Src/util.c    ****         setDistance += 0.25;
1603:Src/util.c    ****         if (setDistance > 2.6) {
1604:Src/util.c    ****           setDistance = 0.5;
1605:Src/util.c    ****         }
1606:Src/util.c    ****         beepShort(setDistance / 0.25);
1607:Src/util.c    ****         saveValue = setDistance * 1000;
1608:Src/util.c    ****         saveValue_valid = 1;
1609:Src/util.c    ****       }
1610:Src/util.c    ****     }
1611:Src/util.c    ****   #else
1612:Src/util.c    ****     if (HAL_GPIO_ReadPin(BUTTON_PORT, BUTTON_PIN)) {
1613:Src/util.c    ****       enable = 0;                                             // disable motors
1614:Src/util.c    ****       while (HAL_GPIO_ReadPin(BUTTON_PORT, BUTTON_PIN)) {}    // wait until button is released
1615:Src/util.c    ****       poweroff();                                             // release power-latch
1616:Src/util.c    ****     }
1617:Src/util.c    ****   #endif
1618:Src/util.c    **** }
1619:Src/util.c    **** 
1620:Src/util.c    **** 
1621:Src/util.c    **** 
1622:Src/util.c    **** /* =========================== Filtering Functions =========================== */
1623:Src/util.c    **** 
1624:Src/util.c    ****   /* Low pass filter fixed-point 32 bits: fixdt(1,32,16)
1625:Src/util.c    ****   * Max:  32767.99998474121
1626:Src/util.c    ****   * Min: -32768
1627:Src/util.c    ****   * Res:  1.52587890625e-05
1628:Src/util.c    ****   * 
1629:Src/util.c    ****   * Inputs:       u     = int16 or int32
1630:Src/util.c    ****   * Outputs:      y     = fixdt(1,32,16)
1631:Src/util.c    ****   * Parameters:   coef  = fixdt(0,16,16) = [0,65535U]
1632:Src/util.c    ****   * 
1633:Src/util.c    ****   * Example: 
1634:Src/util.c    ****   * If coef = 0.8 (in floating point), then coef = 0.8 * 2^16 = 52429 (in fixed-point)
1635:Src/util.c    ****   * filtLowPass16(u, 52429, &y);
1636:Src/util.c    ****   * yint = (int16_t)(y >> 16); // the integer output is the fixed-point ouput shifted by 16 bits
1637:Src/util.c    ****   */
1638:Src/util.c    **** void filtLowPass32(int32_t u, uint16_t coef, int32_t *y) {
 2106              		.loc 1 1638 58 view -0
 2107              		.cfi_startproc
 2108              		@ args = 0, pretend = 0, frame = 0
 2109              		@ frame_needed = 0, uses_anonymous_args = 0
 2110              		@ link register save eliminated.
 2111              		.loc 1 1638 58 is_stmt 0 view .LVU544
 2112 0000 10B4     		push	{r4}
 2113              	.LCFI16:
 2114              		.cfi_def_cfa_offset 4
 2115              		.cfi_offset 4, -4
1639:Src/util.c    ****   int64_t tmp;  
 2116              		.loc 1 1639 3 is_stmt 1 view .LVU545
1640:Src/util.c    ****   tmp = ((int64_t)((u << 4) - (*y >> 12)) * coef) >> 4;
 2117              		.loc 1 1640 3 view .LVU546
 2118              		.loc 1 1640 32 is_stmt 0 view .LVU547
 2119 0002 1468     		ldr	r4, [r2]
 2120              		.loc 1 1640 35 view .LVU548
 2121 0004 2313     		asrs	r3, r4, #12
ARM GAS  /tmp/cchLDBog.s 			page 71


 2122              		.loc 1 1640 29 view .LVU549
 2123 0006 C3EB0013 		rsb	r3, r3, r0, lsl #4
 2124              		.loc 1 1640 10 view .LVU550
 2125 000a 4FEAE37C 		asr	ip, r3, #31
 2126              		.loc 1 1640 43 view .LVU551
 2127 000e A1FB0330 		umull	r3, r0, r1, r3
 2128              	.LVL132:
 2129              		.loc 1 1640 43 view .LVU552
 2130 0012 01FB0C01 		mla	r1, r1, ip, r0
 2131              	.LVL133:
 2132              		.loc 1 1640 7 view .LVU553
 2133 0016 1B09     		lsrs	r3, r3, #4
 2134 0018 43EA0173 		orr	r3, r3, r1, lsl #28
 2135 001c 0911     		asrs	r1, r1, #4
 2136              	.LVL134:
1641:Src/util.c    ****   tmp = CLAMP(tmp, -2147483648LL, 2147483647LL);  // Overflow protection: 2147483647LL = 2^31 - 1
 2137              		.loc 1 1641 3 is_stmt 1 view .LVU554
 2138              		.loc 1 1641 9 is_stmt 0 view .LVU555
 2139 001e B3F1004F 		cmp	r3, #-2147483648
 2140 0022 71F10000 		sbcs	r0, r1, #0
 2141 0026 08DA     		bge	.L145
 2142              		.loc 1 1641 9 discriminator 1 view .LVU556
 2143 0028 1846     		mov	r0, r3
 2144 002a B3F1004F 		cmp	r3, #-2147483648
 2145 002e 71F1FF31 		sbcs	r1, r1, #-1
 2146              	.LVL135:
 2147              		.loc 1 1641 9 discriminator 1 view .LVU557
 2148 0032 04DA     		bge	.L143
 2149 0034 4FF00040 		mov	r0, #-2147483648
 2150 0038 01E0     		b	.L143
 2151              	.LVL136:
 2152              	.L145:
 2153              		.loc 1 1641 9 discriminator 2 view .LVU558
 2154 003a 6FF00040 		mvn	r0, #-2147483648
 2155              	.LVL137:
 2156              	.L143:
1642:Src/util.c    ****   *y = (int32_t)tmp + (*y);
 2157              		.loc 1 1642 3 is_stmt 1 view .LVU559
 2158              		.loc 1 1642 21 is_stmt 0 view .LVU560
 2159 003e 0444     		add	r4, r4, r0
 2160              		.loc 1 1642 6 view .LVU561
 2161 0040 1460     		str	r4, [r2]
1643:Src/util.c    **** }
 2162              		.loc 1 1643 1 view .LVU562
 2163 0042 10BC     		pop	{r4}
 2164              	.LCFI17:
 2165              		.cfi_restore 4
 2166              		.cfi_def_cfa_offset 0
 2167 0044 7047     		bx	lr
 2168              		.cfi_endproc
 2169              	.LFE94:
 2171              		.section	.text.adcCalibLim,"ax",%progbits
 2172              		.align	1
 2173              		.global	adcCalibLim
 2174              		.syntax unified
 2175              		.thumb
 2176              		.thumb_func
ARM GAS  /tmp/cchLDBog.s 			page 72


 2178              	adcCalibLim:
 2179              	.LFB76:
 500:Src/util.c    **** #ifdef AUTO_CALIBRATION_ENA
 2180              		.loc 1 500 24 is_stmt 1 view -0
 2181              		.cfi_startproc
 2182              		@ args = 0, pretend = 0, frame = 8
 2183              		@ frame_needed = 0, uses_anonymous_args = 0
 2184 0000 2DE9F04F 		push	{r4, r5, r6, r7, r8, r9, r10, fp, lr}
 2185              	.LCFI18:
 2186              		.cfi_def_cfa_offset 36
 2187              		.cfi_offset 4, -36
 2188              		.cfi_offset 5, -32
 2189              		.cfi_offset 6, -28
 2190              		.cfi_offset 7, -24
 2191              		.cfi_offset 8, -20
 2192              		.cfi_offset 9, -16
 2193              		.cfi_offset 10, -12
 2194              		.cfi_offset 11, -8
 2195              		.cfi_offset 14, -4
 2196 0004 83B0     		sub	sp, sp, #12
 2197              	.LCFI19:
 2198              		.cfi_def_cfa_offset 48
 502:Src/util.c    ****   if (speedAvgAbs > 5) {    // do not enter this mode if motors are spinning
 2199              		.loc 1 502 3 view .LVU564
 2200 0006 FFF7FEFF 		bl	calcAvgSpeed
 2201              	.LVL138:
 503:Src/util.c    ****     return;
 2202              		.loc 1 503 3 view .LVU565
 503:Src/util.c    ****     return;
 2203              		.loc 1 503 19 is_stmt 0 view .LVU566
 2204 000a 514B     		ldr	r3, .L161
 2205 000c B3F90030 		ldrsh	r3, [r3]
 503:Src/util.c    ****     return;
 2206              		.loc 1 503 6 view .LVU567
 2207 0010 052B     		cmp	r3, #5
 2208 0012 02DD     		ble	.L160
 2209              	.L147:
 604:Src/util.c    ****  /*
 2210              		.loc 1 604 1 view .LVU568
 2211 0014 03B0     		add	sp, sp, #12
 2212              	.LCFI20:
 2213              		.cfi_remember_state
 2214              		.cfi_def_cfa_offset 36
 2215              		@ sp needed
 2216 0016 BDE8F08F 		pop	{r4, r5, r6, r7, r8, r9, r10, fp, pc}
 2217              	.L160:
 2218              	.LCFI21:
 2219              		.cfi_restore_state
 513:Src/util.c    ****   // Inititalization: MIN = a high value, MAX = a low value
 2220              		.loc 1 513 3 is_stmt 1 view .LVU569
 2221 001a FFF7FEFF 		bl	readInputRaw
 2222              	.LVL139:
 515:Src/util.c    ****   int32_t  input2_fixdt = input2[inIdx].raw << 16;
 2223              		.loc 1 515 3 view .LVU570
 515:Src/util.c    ****   int32_t  input2_fixdt = input2[inIdx].raw << 16;
 2224              		.loc 1 515 40 is_stmt 0 view .LVU571
 2225 001e 4D4B     		ldr	r3, .L161+4
ARM GAS  /tmp/cchLDBog.s 			page 73


 2226 0020 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 2227 0022 C3EBC301 		rsb	r1, r3, r3, lsl #3
 2228 0026 4C4A     		ldr	r2, .L161+8
 2229 0028 32F91120 		ldrsh	r2, [r2, r1, lsl #1]
 515:Src/util.c    ****   int32_t  input2_fixdt = input2[inIdx].raw << 16;
 2230              		.loc 1 515 45 view .LVU572
 2231 002c 1204     		lsls	r2, r2, #16
 515:Src/util.c    ****   int32_t  input2_fixdt = input2[inIdx].raw << 16;
 2232              		.loc 1 515 12 view .LVU573
 2233 002e 0192     		str	r2, [sp, #4]
 516:Src/util.c    ****   int16_t  INPUT1_MIN_temp = MAX_int16_T;
 2234              		.loc 1 516 3 is_stmt 1 view .LVU574
 516:Src/util.c    ****   int16_t  INPUT1_MIN_temp = MAX_int16_T;
 2235              		.loc 1 516 40 is_stmt 0 view .LVU575
 2236 0030 4A4A     		ldr	r2, .L161+12
 2237 0032 32F91130 		ldrsh	r3, [r2, r1, lsl #1]
 516:Src/util.c    ****   int16_t  INPUT1_MIN_temp = MAX_int16_T;
 2238              		.loc 1 516 45 view .LVU576
 2239 0036 1B04     		lsls	r3, r3, #16
 516:Src/util.c    ****   int16_t  INPUT1_MIN_temp = MAX_int16_T;
 2240              		.loc 1 516 12 view .LVU577
 2241 0038 0093     		str	r3, [sp]
 517:Src/util.c    ****   int16_t  INPUT1_MID_temp = 0;
 2242              		.loc 1 517 3 is_stmt 1 view .LVU578
 2243              	.LVL140:
 518:Src/util.c    ****   int16_t  INPUT1_MAX_temp = MIN_int16_T;
 2244              		.loc 1 518 3 view .LVU579
 519:Src/util.c    ****   int16_t  INPUT2_MIN_temp = MAX_int16_T;
 2245              		.loc 1 519 3 view .LVU580
 520:Src/util.c    ****   int16_t  INPUT2_MID_temp = 0;
 2246              		.loc 1 520 3 view .LVU581
 521:Src/util.c    ****   int16_t  INPUT2_MAX_temp = MIN_int16_T;
 2247              		.loc 1 521 3 view .LVU582
 522:Src/util.c    ****   int16_t  input_margin    = 0;
 2248              		.loc 1 522 3 view .LVU583
 523:Src/util.c    ****   uint16_t input_cal_timeout = 0;
 2249              		.loc 1 523 3 view .LVU584
 524:Src/util.c    ****   
 2250              		.loc 1 524 3 view .LVU585
 533:Src/util.c    ****     readInputRaw();
 2251              		.loc 1 533 3 view .LVU586
 524:Src/util.c    ****   
 2252              		.loc 1 524 12 is_stmt 0 view .LVU587
 2253 003a 4FF00009 		mov	r9, #0
 522:Src/util.c    ****   int16_t  input_margin    = 0;
 2254              		.loc 1 522 12 view .LVU588
 2255 003e 484D     		ldr	r5, .L161+16
 521:Src/util.c    ****   int16_t  INPUT2_MAX_temp = MIN_int16_T;
 2256              		.loc 1 521 12 view .LVU589
 2257 0040 CA46     		mov	r10, r9
 520:Src/util.c    ****   int16_t  INPUT2_MID_temp = 0;
 2258              		.loc 1 520 12 view .LVU590
 2259 0042 47F6FF76 		movw	r6, #32767
 519:Src/util.c    ****   int16_t  INPUT2_MIN_temp = MAX_int16_T;
 2260              		.loc 1 519 12 view .LVU591
 2261 0046 2F46     		mov	r7, r5
 518:Src/util.c    ****   int16_t  INPUT1_MAX_temp = MIN_int16_T;
ARM GAS  /tmp/cchLDBog.s 			page 74


 2262              		.loc 1 518 12 view .LVU592
 2263 0048 CB46     		mov	fp, r9
 517:Src/util.c    ****   int16_t  INPUT1_MID_temp = 0;
 2264              		.loc 1 517 12 view .LVU593
 2265 004a B046     		mov	r8, r6
 533:Src/util.c    ****     readInputRaw();
 2266              		.loc 1 533 9 view .LVU594
 2267 004c 2FE0     		b	.L150
 2268              	.LVL141:
 2269              	.L152:
 534:Src/util.c    ****     filtLowPass32(input1[inIdx].raw, FILTER, &input1_fixdt);
 2270              		.loc 1 534 5 is_stmt 1 view .LVU595
 2271 004e FFF7FEFF 		bl	readInputRaw
 2272              	.LVL142:
 535:Src/util.c    ****     filtLowPass32(input2[inIdx].raw, FILTER, &input2_fixdt);
 2273              		.loc 1 535 5 view .LVU596
 535:Src/util.c    ****     filtLowPass32(input2[inIdx].raw, FILTER, &input2_fixdt);
 2274              		.loc 1 535 32 is_stmt 0 view .LVU597
 2275 0052 DFF80091 		ldr	r9, .L161+4
 2276 0056 99F80030 		ldrb	r3, [r9]	@ zero_extendqisi2
 2277 005a C3EBC303 		rsb	r3, r3, r3, lsl #3
 535:Src/util.c    ****     filtLowPass32(input2[inIdx].raw, FILTER, &input2_fixdt);
 2278              		.loc 1 535 5 view .LVU598
 2279 005e 01AA     		add	r2, sp, #4
 2280 0060 41F69911 		movw	r1, #6553
 2281 0064 3C48     		ldr	r0, .L161+8
 2282 0066 30F91300 		ldrsh	r0, [r0, r3, lsl #1]
 2283 006a FFF7FEFF 		bl	filtLowPass32
 2284              	.LVL143:
 536:Src/util.c    ****     
 2285              		.loc 1 536 5 is_stmt 1 view .LVU599
 536:Src/util.c    ****     
 2286              		.loc 1 536 32 is_stmt 0 view .LVU600
 2287 006e 99F80030 		ldrb	r3, [r9]	@ zero_extendqisi2
 2288 0072 C3EBC303 		rsb	r3, r3, r3, lsl #3
 536:Src/util.c    ****     
 2289              		.loc 1 536 5 view .LVU601
 2290 0076 6A46     		mov	r2, sp
 2291 0078 41F69911 		movw	r1, #6553
 2292 007c 3748     		ldr	r0, .L161+12
 2293 007e 30F91300 		ldrsh	r0, [r0, r3, lsl #1]
 2294 0082 FFF7FEFF 		bl	filtLowPass32
 2295              	.LVL144:
 538:Src/util.c    ****     INPUT2_MID_temp = (int16_t)(input2_fixdt >> 16);// CLAMP(input2_fixdt >> 16, INPUT2_MIN, INPUT2
 2296              		.loc 1 538 5 is_stmt 1 view .LVU602
 538:Src/util.c    ****     INPUT2_MID_temp = (int16_t)(input2_fixdt >> 16);// CLAMP(input2_fixdt >> 16, INPUT2_MIN, INPUT2
 2297              		.loc 1 538 21 is_stmt 0 view .LVU603
 2298 0086 BDF906B0 		ldrsh	fp, [sp, #6]
 2299              	.LVL145:
 539:Src/util.c    ****     INPUT1_MIN_temp = MIN(INPUT1_MIN_temp, INPUT1_MID_temp);
 2300              		.loc 1 539 5 is_stmt 1 view .LVU604
 539:Src/util.c    ****     INPUT1_MIN_temp = MIN(INPUT1_MIN_temp, INPUT1_MID_temp);
 2301              		.loc 1 539 21 is_stmt 0 view .LVU605
 2302 008a BDF902A0 		ldrsh	r10, [sp, #2]
 2303              	.LVL146:
 540:Src/util.c    ****     INPUT1_MAX_temp = MAX(INPUT1_MAX_temp, INPUT1_MID_temp);
 2304              		.loc 1 540 5 is_stmt 1 view .LVU606
ARM GAS  /tmp/cchLDBog.s 			page 75


 540:Src/util.c    ****     INPUT1_MAX_temp = MAX(INPUT1_MAX_temp, INPUT1_MID_temp);
 2305              		.loc 1 540 21 is_stmt 0 view .LVU607
 2306 008e D845     		cmp	r8, fp
 2307 0090 A8BF     		it	ge
 2308 0092 D846     		movge	r8, fp
 2309              	.LVL147:
 541:Src/util.c    ****     INPUT2_MIN_temp = MIN(INPUT2_MIN_temp, INPUT2_MID_temp);
 2310              		.loc 1 541 5 is_stmt 1 view .LVU608
 541:Src/util.c    ****     INPUT2_MIN_temp = MIN(INPUT2_MIN_temp, INPUT2_MID_temp);
 2311              		.loc 1 541 21 is_stmt 0 view .LVU609
 2312 0094 5F45     		cmp	r7, fp
 2313 0096 B8BF     		it	lt
 2314 0098 5F46     		movlt	r7, fp
 2315              	.LVL148:
 542:Src/util.c    ****     INPUT2_MAX_temp = MAX(INPUT2_MAX_temp, INPUT2_MID_temp);
 2316              		.loc 1 542 5 is_stmt 1 view .LVU610
 542:Src/util.c    ****     INPUT2_MAX_temp = MAX(INPUT2_MAX_temp, INPUT2_MID_temp);
 2317              		.loc 1 542 21 is_stmt 0 view .LVU611
 2318 009a 5645     		cmp	r6, r10
 2319 009c A8BF     		it	ge
 2320 009e 5646     		movge	r6, r10
 2321              	.LVL149:
 543:Src/util.c    ****     HAL_Delay(5);
 2322              		.loc 1 543 5 is_stmt 1 view .LVU612
 543:Src/util.c    ****     HAL_Delay(5);
 2323              		.loc 1 543 21 is_stmt 0 view .LVU613
 2324 00a0 5545     		cmp	r5, r10
 2325 00a2 B8BF     		it	lt
 2326 00a4 5546     		movlt	r5, r10
 2327              	.LVL150:
 544:Src/util.c    ****   }
 2328              		.loc 1 544 5 is_stmt 1 view .LVU614
 2329 00a6 0520     		movs	r0, #5
 2330 00a8 FFF7FEFF 		bl	HAL_Delay
 2331              	.LVL151:
 533:Src/util.c    ****     readInputRaw();
 2332              		.loc 1 533 73 is_stmt 0 discriminator 1 view .LVU615
 2333 00ac A146     		mov	r9, r4
 2334              	.LVL152:
 2335              	.L150:
 533:Src/util.c    ****     readInputRaw();
 2336              		.loc 1 533 53 is_stmt 1 view .LVU616
 533:Src/util.c    ****     readInputRaw();
 2337              		.loc 1 533 11 is_stmt 0 view .LVU617
 2338 00ae 0221     		movs	r1, #2
 2339 00b0 2C48     		ldr	r0, .L161+20
 2340 00b2 FFF7FEFF 		bl	HAL_GPIO_ReadPin
 2341              	.LVL153:
 533:Src/util.c    ****     readInputRaw();
 2342              		.loc 1 533 53 discriminator 1 view .LVU618
 2343 00b6 28B9     		cbnz	r0, .L151
 533:Src/util.c    ****     readInputRaw();
 2344              		.loc 1 533 73 discriminator 1 view .LVU619
 2345 00b8 09F10104 		add	r4, r9, #1
 2346 00bc A4B2     		uxth	r4, r4
 2347              	.LVL154:
 533:Src/util.c    ****     readInputRaw();
ARM GAS  /tmp/cchLDBog.s 			page 76


 2348              		.loc 1 533 53 discriminator 1 view .LVU620
 2349 00be B9F57A6F 		cmp	r9, #4000
 2350 00c2 C4D3     		bcc	.L152
 2351              	.LVL155:
 2352              	.L151:
 550:Src/util.c    ****   if (input1TypTemp == input1[inIdx].typDef || input1[inIdx].typDef == 3) {  // Accept calibration 
 2353              		.loc 1 550 3 is_stmt 1 view .LVU621
 550:Src/util.c    ****   if (input1TypTemp == input1[inIdx].typDef || input1[inIdx].typDef == 3) {  // Accept calibration 
 2354              		.loc 1 550 27 is_stmt 0 view .LVU622
 2355 00c4 3A46     		mov	r2, r7
 2356 00c6 5946     		mov	r1, fp
 2357 00c8 4046     		mov	r0, r8
 2358 00ca FFF7FEFF 		bl	checkInputType
 2359              	.LVL156:
 550:Src/util.c    ****   if (input1TypTemp == input1[inIdx].typDef || input1[inIdx].typDef == 3) {  // Accept calibration 
 2360              		.loc 1 550 11 discriminator 1 view .LVU623
 2361 00ce 5FFA80F9 		uxtb	r9, r0
 2362              	.LVL157:
 551:Src/util.c    ****     #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 2363              		.loc 1 551 3 is_stmt 1 view .LVU624
 551:Src/util.c    ****     #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 2364              		.loc 1 551 37 is_stmt 0 view .LVU625
 2365 00d2 204B     		ldr	r3, .L161+4
 2366 00d4 1C78     		ldrb	r4, [r3]	@ zero_extendqisi2
 2367 00d6 C4EBC402 		rsb	r2, r4, r4, lsl #3
 2368 00da 1F4B     		ldr	r3, .L161+8
 2369 00dc 03EB4203 		add	r3, r3, r2, lsl #1
 2370 00e0 5B79     		ldrb	r3, [r3, #5]	@ zero_extendqisi2
 551:Src/util.c    ****     #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 2371              		.loc 1 551 6 view .LVU626
 2372 00e2 4B45     		cmp	r3, r9
 2373 00e4 03D0     		beq	.L153
 551:Src/util.c    ****     #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 2374              		.loc 1 551 45 discriminator 1 view .LVU627
 2375 00e6 032B     		cmp	r3, #3
 2376 00e8 01D0     		beq	.L153
 556:Src/util.c    ****     #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 2377              		.loc 1 556 19 view .LVU628
 2378 00ea 4FF00009 		mov	r9, #0
 2379              	.LVL158:
 2380              	.L153:
 565:Src/util.c    ****   if (input2TypTemp == input2[inIdx].typDef || input2[inIdx].typDef == 3) {  // Accept calibration 
 2381              		.loc 1 565 3 is_stmt 1 view .LVU629
 565:Src/util.c    ****   if (input2TypTemp == input2[inIdx].typDef || input2[inIdx].typDef == 3) {  // Accept calibration 
 2382              		.loc 1 565 27 is_stmt 0 view .LVU630
 2383 00ee 2A46     		mov	r2, r5
 2384 00f0 5146     		mov	r1, r10
 2385 00f2 3046     		mov	r0, r6
 2386 00f4 FFF7FEFF 		bl	checkInputType
 2387              	.LVL159:
 565:Src/util.c    ****   if (input2TypTemp == input2[inIdx].typDef || input2[inIdx].typDef == 3) {  // Accept calibration 
 2388              		.loc 1 565 11 discriminator 1 view .LVU631
 2389 00f8 C0B2     		uxtb	r0, r0
 2390              	.LVL160:
 566:Src/util.c    ****     #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 2391              		.loc 1 566 3 is_stmt 1 view .LVU632
 566:Src/util.c    ****     #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
ARM GAS  /tmp/cchLDBog.s 			page 77


 2392              		.loc 1 566 37 is_stmt 0 view .LVU633
 2393 00fa C4EBC402 		rsb	r2, r4, r4, lsl #3
 2394 00fe 174B     		ldr	r3, .L161+12
 2395 0100 03EB4203 		add	r3, r3, r2, lsl #1
 2396 0104 5B79     		ldrb	r3, [r3, #5]	@ zero_extendqisi2
 566:Src/util.c    ****     #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 2397              		.loc 1 566 6 view .LVU634
 2398 0106 8342     		cmp	r3, r0
 2399 0108 02D0     		beq	.L154
 566:Src/util.c    ****     #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 2400              		.loc 1 566 45 discriminator 1 view .LVU635
 2401 010a 032B     		cmp	r3, #3
 2402 010c 00D0     		beq	.L154
 571:Src/util.c    ****     #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 2403              		.loc 1 571 19 view .LVU636
 2404 010e 0020     		movs	r0, #0
 2405              	.LVL161:
 2406              	.L154:
 579:Src/util.c    ****     input1[inIdx].typ = input1TypTemp;
 2407              		.loc 1 579 3 is_stmt 1 view .LVU637
 579:Src/util.c    ****     input1[inIdx].typ = input1TypTemp;
 2408              		.loc 1 579 6 is_stmt 0 view .LVU638
 2409 0110 B9F1000F 		cmp	r9, #0
 2410 0114 02D1     		bne	.L155
 579:Src/util.c    ****     input1[inIdx].typ = input1TypTemp;
 2411              		.loc 1 579 26 discriminator 1 view .LVU639
 2412 0116 0028     		cmp	r0, #0
 2413 0118 3FF47CAF 		beq	.L147
 2414              	.L155:
 580:Src/util.c    ****     input1[inIdx].min = INPUT1_MIN_temp + input_margin;
 2415              		.loc 1 580 5 is_stmt 1 view .LVU640
 580:Src/util.c    ****     input1[inIdx].min = INPUT1_MIN_temp + input_margin;
 2416              		.loc 1 580 23 is_stmt 0 view .LVU641
 2417 011c C4EBC402 		rsb	r2, r4, r4, lsl #3
 2418 0120 0D4B     		ldr	r3, .L161+8
 2419 0122 03EB4203 		add	r3, r3, r2, lsl #1
 2420 0126 83F80490 		strb	r9, [r3, #4]
 581:Src/util.c    ****     input1[inIdx].mid = INPUT1_MID_temp;
 2421              		.loc 1 581 5 is_stmt 1 view .LVU642
 581:Src/util.c    ****     input1[inIdx].mid = INPUT1_MID_temp;
 2422              		.loc 1 581 23 is_stmt 0 view .LVU643
 2423 012a A3F80680 		strh	r8, [r3, #6]	@ movhi
 582:Src/util.c    ****     input1[inIdx].max = INPUT1_MAX_temp - input_margin;
 2424              		.loc 1 582 5 is_stmt 1 view .LVU644
 582:Src/util.c    ****     input1[inIdx].max = INPUT1_MAX_temp - input_margin;
 2425              		.loc 1 582 23 is_stmt 0 view .LVU645
 2426 012e A3F808B0 		strh	fp, [r3, #8]	@ movhi
 583:Src/util.c    **** 
 2427              		.loc 1 583 5 is_stmt 1 view .LVU646
 583:Src/util.c    **** 
 2428              		.loc 1 583 23 is_stmt 0 view .LVU647
 2429 0132 5F81     		strh	r7, [r3, #10]	@ movhi
 585:Src/util.c    ****     input2[inIdx].min = INPUT2_MIN_temp + input_margin;
 2430              		.loc 1 585 5 is_stmt 1 view .LVU648
 585:Src/util.c    ****     input2[inIdx].min = INPUT2_MIN_temp + input_margin;
 2431              		.loc 1 585 23 is_stmt 0 view .LVU649
 2432 0134 094A     		ldr	r2, .L161+12
ARM GAS  /tmp/cchLDBog.s 			page 78


 2433 0136 C4EBC403 		rsb	r3, r4, r4, lsl #3
 2434 013a 02EB4303 		add	r3, r2, r3, lsl #1
 2435 013e 1871     		strb	r0, [r3, #4]
 586:Src/util.c    ****     input2[inIdx].mid = INPUT2_MID_temp;
 2436              		.loc 1 586 5 is_stmt 1 view .LVU650
 586:Src/util.c    ****     input2[inIdx].mid = INPUT2_MID_temp;
 2437              		.loc 1 586 23 is_stmt 0 view .LVU651
 2438 0140 DE80     		strh	r6, [r3, #6]	@ movhi
 587:Src/util.c    ****     input2[inIdx].max = INPUT2_MAX_temp - input_margin;
 2439              		.loc 1 587 5 is_stmt 1 view .LVU652
 587:Src/util.c    ****     input2[inIdx].max = INPUT2_MAX_temp - input_margin;
 2440              		.loc 1 587 23 is_stmt 0 view .LVU653
 2441 0142 A3F808A0 		strh	r10, [r3, #8]	@ movhi
 588:Src/util.c    **** 
 2442              		.loc 1 588 5 is_stmt 1 view .LVU654
 588:Src/util.c    **** 
 2443              		.loc 1 588 23 is_stmt 0 view .LVU655
 2444 0146 5D81     		strh	r5, [r3, #10]	@ movhi
 590:Src/util.c    ****     #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 2445              		.loc 1 590 5 is_stmt 1 view .LVU656
 590:Src/util.c    ****     #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 2446              		.loc 1 590 19 is_stmt 0 view .LVU657
 2447 0148 074B     		ldr	r3, .L161+24
 2448 014a 0122     		movs	r2, #1
 2449 014c 1A70     		strb	r2, [r3]
 2450 014e 61E7     		b	.L147
 2451              	.L162:
 2452              		.align	2
 2453              	.L161:
 2454 0150 00000000 		.word	speedAvgAbs
 2455 0154 00000000 		.word	inIdx
 2456 0158 00000000 		.word	input1
 2457 015c 00000000 		.word	input2
 2458 0160 0080FFFF 		.word	-32768
 2459 0164 00080140 		.word	1073809408
 2460 0168 00000000 		.word	inp_cal_valid
 2461              		.cfi_endproc
 2462              	.LFE76:
 2464              		.section	.text.updateCurSpdLim,"ax",%progbits
 2465              		.align	1
 2466              		.global	updateCurSpdLim
 2467              		.syntax unified
 2468              		.thumb
 2469              		.thumb_func
 2471              	updateCurSpdLim:
 2472              	.LFB77:
 612:Src/util.c    ****   calcAvgSpeed();
 2473              		.loc 1 612 28 is_stmt 1 view -0
 2474              		.cfi_startproc
 2475              		@ args = 0, pretend = 0, frame = 8
 2476              		@ frame_needed = 0, uses_anonymous_args = 0
 2477 0000 30B5     		push	{r4, r5, lr}
 2478              	.LCFI22:
 2479              		.cfi_def_cfa_offset 12
 2480              		.cfi_offset 4, -12
 2481              		.cfi_offset 5, -8
 2482              		.cfi_offset 14, -4
ARM GAS  /tmp/cchLDBog.s 			page 79


 2483 0002 83B0     		sub	sp, sp, #12
 2484              	.LCFI23:
 2485              		.cfi_def_cfa_offset 24
 613:Src/util.c    ****   if (speedAvgAbs > 5) {    // do not enter this mode if motors are spinning
 2486              		.loc 1 613 3 view .LVU659
 2487 0004 FFF7FEFF 		bl	calcAvgSpeed
 2488              	.LVL162:
 614:Src/util.c    ****     return;
 2489              		.loc 1 614 3 view .LVU660
 614:Src/util.c    ****     return;
 2490              		.loc 1 614 19 is_stmt 0 view .LVU661
 2491 0008 514B     		ldr	r3, .L176
 2492 000a B3F90030 		ldrsh	r3, [r3]
 614:Src/util.c    ****     return;
 2493              		.loc 1 614 6 view .LVU662
 2494 000e 052B     		cmp	r3, #5
 2495 0010 00F39680 		bgt	.L163
 624:Src/util.c    ****   int32_t  input2_fixdt = input2[inIdx].raw << 16;
 2496              		.loc 1 624 3 is_stmt 1 view .LVU663
 624:Src/util.c    ****   int32_t  input2_fixdt = input2[inIdx].raw << 16;
 2497              		.loc 1 624 40 is_stmt 0 view .LVU664
 2498 0014 4F4B     		ldr	r3, .L176+4
 2499 0016 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 2500 0018 C3EBC301 		rsb	r1, r3, r3, lsl #3
 2501 001c 4E4A     		ldr	r2, .L176+8
 2502 001e 32F91120 		ldrsh	r2, [r2, r1, lsl #1]
 624:Src/util.c    ****   int32_t  input2_fixdt = input2[inIdx].raw << 16;
 2503              		.loc 1 624 45 view .LVU665
 2504 0022 1204     		lsls	r2, r2, #16
 624:Src/util.c    ****   int32_t  input2_fixdt = input2[inIdx].raw << 16;
 2505              		.loc 1 624 12 view .LVU666
 2506 0024 0192     		str	r2, [sp, #4]
 625:Src/util.c    ****   uint16_t cur_factor;    // fixdt(0,16,16)
 2507              		.loc 1 625 3 is_stmt 1 view .LVU667
 625:Src/util.c    ****   uint16_t cur_factor;    // fixdt(0,16,16)
 2508              		.loc 1 625 40 is_stmt 0 view .LVU668
 2509 0026 4D4A     		ldr	r2, .L176+12
 2510 0028 32F91130 		ldrsh	r3, [r2, r1, lsl #1]
 625:Src/util.c    ****   uint16_t cur_factor;    // fixdt(0,16,16)
 2511              		.loc 1 625 45 view .LVU669
 2512 002c 1B04     		lsls	r3, r3, #16
 625:Src/util.c    ****   uint16_t cur_factor;    // fixdt(0,16,16)
 2513              		.loc 1 625 12 view .LVU670
 2514 002e 0093     		str	r3, [sp]
 626:Src/util.c    ****   uint16_t spd_factor;    // fixdt(0,16,16)
 2515              		.loc 1 626 3 is_stmt 1 view .LVU671
 627:Src/util.c    ****   uint16_t cur_spd_timeout = 0;
 2516              		.loc 1 627 3 view .LVU672
 628:Src/util.c    ****   cur_spd_valid = 0;
 2517              		.loc 1 628 3 view .LVU673
 2518              	.LVL163:
 629:Src/util.c    **** 
 2519              		.loc 1 629 3 view .LVU674
 629:Src/util.c    **** 
 2520              		.loc 1 629 17 is_stmt 0 view .LVU675
 2521 0030 0024     		movs	r4, #0
 2522 0032 4B4B     		ldr	r3, .L176+16
ARM GAS  /tmp/cchLDBog.s 			page 80


 2523 0034 1C70     		strb	r4, [r3]
 632:Src/util.c    ****     readInputRaw();
 2524              		.loc 1 632 3 is_stmt 1 view .LVU676
 632:Src/util.c    ****     readInputRaw();
 2525              		.loc 1 632 9 is_stmt 0 view .LVU677
 2526 0036 1CE0     		b	.L166
 2527              	.LVL164:
 2528              	.L168:
 633:Src/util.c    ****     filtLowPass32(input1[inIdx].raw, FILTER, &input1_fixdt);
 2529              		.loc 1 633 5 is_stmt 1 view .LVU678
 2530 0038 FFF7FEFF 		bl	readInputRaw
 2531              	.LVL165:
 634:Src/util.c    ****     filtLowPass32(input2[inIdx].raw, FILTER, &input2_fixdt);
 2532              		.loc 1 634 5 view .LVU679
 634:Src/util.c    ****     filtLowPass32(input2[inIdx].raw, FILTER, &input2_fixdt);
 2533              		.loc 1 634 32 is_stmt 0 view .LVU680
 2534 003c 454C     		ldr	r4, .L176+4
 2535 003e 2378     		ldrb	r3, [r4]	@ zero_extendqisi2
 2536 0040 C3EBC303 		rsb	r3, r3, r3, lsl #3
 634:Src/util.c    ****     filtLowPass32(input2[inIdx].raw, FILTER, &input2_fixdt);
 2537              		.loc 1 634 5 view .LVU681
 2538 0044 01AA     		add	r2, sp, #4
 2539 0046 41F69911 		movw	r1, #6553
 2540 004a 4348     		ldr	r0, .L176+8
 2541 004c 30F91300 		ldrsh	r0, [r0, r3, lsl #1]
 2542 0050 FFF7FEFF 		bl	filtLowPass32
 2543              	.LVL166:
 635:Src/util.c    ****     HAL_Delay(5);
 2544              		.loc 1 635 5 is_stmt 1 view .LVU682
 635:Src/util.c    ****     HAL_Delay(5);
 2545              		.loc 1 635 32 is_stmt 0 view .LVU683
 2546 0054 2378     		ldrb	r3, [r4]	@ zero_extendqisi2
 2547 0056 C3EBC303 		rsb	r3, r3, r3, lsl #3
 635:Src/util.c    ****     HAL_Delay(5);
 2548              		.loc 1 635 5 view .LVU684
 2549 005a 6A46     		mov	r2, sp
 2550 005c 41F69911 		movw	r1, #6553
 2551 0060 3E48     		ldr	r0, .L176+12
 2552 0062 30F91300 		ldrsh	r0, [r0, r3, lsl #1]
 2553 0066 FFF7FEFF 		bl	filtLowPass32
 2554              	.LVL167:
 636:Src/util.c    ****   }
 2555              		.loc 1 636 5 is_stmt 1 view .LVU685
 2556 006a 0520     		movs	r0, #5
 2557 006c FFF7FEFF 		bl	HAL_Delay
 2558              	.LVL168:
 632:Src/util.c    ****     readInputRaw();
 2559              		.loc 1 632 71 is_stmt 0 discriminator 1 view .LVU686
 2560 0070 2C46     		mov	r4, r5
 2561              	.LVL169:
 2562              	.L166:
 632:Src/util.c    ****     readInputRaw();
 2563              		.loc 1 632 53 is_stmt 1 view .LVU687
 632:Src/util.c    ****     readInputRaw();
 2564              		.loc 1 632 11 is_stmt 0 view .LVU688
 2565 0072 0221     		movs	r1, #2
 2566 0074 3B48     		ldr	r0, .L176+20
ARM GAS  /tmp/cchLDBog.s 			page 81


 2567 0076 FFF7FEFF 		bl	HAL_GPIO_ReadPin
 2568              	.LVL170:
 632:Src/util.c    ****     readInputRaw();
 2569              		.loc 1 632 53 discriminator 1 view .LVU689
 2570 007a 20B9     		cbnz	r0, .L167
 632:Src/util.c    ****     readInputRaw();
 2571              		.loc 1 632 71 discriminator 1 view .LVU690
 2572 007c 631C     		adds	r3, r4, #1
 2573 007e 9DB2     		uxth	r5, r3
 2574              	.LVL171:
 632:Src/util.c    ****     readInputRaw();
 2575              		.loc 1 632 53 discriminator 1 view .LVU691
 2576 0080 B4F5FA6F 		cmp	r4, #2000
 2577 0084 D8D3     		bcc	.L168
 2578              	.LVL172:
 2579              	.L167:
 639:Src/util.c    ****   spd_factor = CLAMP((input2_fixdt - (input2[inIdx].min << 16)) / (input2[inIdx].max - input2[inIdx
 2580              		.loc 1 639 3 is_stmt 1 view .LVU692
 639:Src/util.c    ****   spd_factor = CLAMP((input2_fixdt - (input2[inIdx].min << 16)) / (input2[inIdx].max - input2[inIdx
 2581              		.loc 1 639 16 is_stmt 0 view .LVU693
 2582 0086 334B     		ldr	r3, .L176+4
 2583 0088 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 2584 008a C3EBC302 		rsb	r2, r3, r3, lsl #3
 2585 008e 3249     		ldr	r1, .L176+8
 2586 0090 01EB4201 		add	r1, r1, r2, lsl #1
 2587 0094 B1F90600 		ldrsh	r0, [r1, #6]
 2588 0098 019A     		ldr	r2, [sp, #4]
 2589 009a A2EB0042 		sub	r2, r2, r0, lsl #16
 2590 009e B1F90A10 		ldrsh	r1, [r1, #10]
 2591 00a2 091A     		subs	r1, r1, r0
 2592 00a4 92FBF1F2 		sdiv	r2, r2, r1
 639:Src/util.c    ****   spd_factor = CLAMP((input2_fixdt - (input2[inIdx].min << 16)) / (input2[inIdx].max - input2[inIdx
 2593              		.loc 1 639 14 view .LVU694
 2594 00a8 B2F5803F 		cmp	r2, #65536
 2595 00ac 4ADA     		bge	.L173
 639:Src/util.c    ****   spd_factor = CLAMP((input2_fixdt - (input2[inIdx].min << 16)) / (input2[inIdx].max - input2[inIdx
 2596              		.loc 1 639 16 discriminator 1 view .LVU695
 2597 00ae 41F69911 		movw	r1, #6553
 2598 00b2 8A42     		cmp	r2, r1
 2599 00b4 B8BF     		it	lt
 2600 00b6 0A46     		movlt	r2, r1
 639:Src/util.c    ****   spd_factor = CLAMP((input2_fixdt - (input2[inIdx].min << 16)) / (input2[inIdx].max - input2[inIdx
 2601              		.loc 1 639 14 discriminator 1 view .LVU696
 2602 00b8 90B2     		uxth	r0, r2
 2603              	.L169:
 2604              	.LVL173:
 640:Src/util.c    ****       
 2605              		.loc 1 640 3 is_stmt 1 view .LVU697
 640:Src/util.c    ****       
 2606              		.loc 1 640 16 is_stmt 0 view .LVU698
 2607 00ba C3EBC302 		rsb	r2, r3, r3, lsl #3
 2608 00be 2749     		ldr	r1, .L176+12
 2609 00c0 01EB4201 		add	r1, r1, r2, lsl #1
 2610 00c4 B1F90640 		ldrsh	r4, [r1, #6]
 2611 00c8 009A     		ldr	r2, [sp]
 2612 00ca A2EB0442 		sub	r2, r2, r4, lsl #16
 2613 00ce B1F90A10 		ldrsh	r1, [r1, #10]
ARM GAS  /tmp/cchLDBog.s 			page 82


 2614 00d2 091B     		subs	r1, r1, r4
 2615 00d4 92FBF1F2 		sdiv	r2, r2, r1
 640:Src/util.c    ****       
 2616              		.loc 1 640 14 view .LVU699
 2617 00d8 B2F5803F 		cmp	r2, #65536
 2618 00dc 35DA     		bge	.L174
 640:Src/util.c    ****       
 2619              		.loc 1 640 16 discriminator 1 view .LVU700
 2620 00de 40F6CC41 		movw	r1, #3276
 2621 00e2 8A42     		cmp	r2, r1
 2622 00e4 B8BF     		it	lt
 2623 00e6 0A46     		movlt	r2, r1
 640:Src/util.c    ****       
 2624              		.loc 1 640 14 discriminator 1 view .LVU701
 2625 00e8 91B2     		uxth	r1, r2
 2626              	.L170:
 2627              	.LVL174:
 642:Src/util.c    ****     // Update current limit
 2628              		.loc 1 642 3 is_stmt 1 view .LVU702
 642:Src/util.c    ****     // Update current limit
 2629              		.loc 1 642 20 is_stmt 0 view .LVU703
 2630 00ea C3EBC304 		rsb	r4, r3, r3, lsl #3
 2631 00ee 1A4A     		ldr	r2, .L176+8
 2632 00f0 02EB4402 		add	r2, r2, r4, lsl #1
 2633 00f4 1279     		ldrb	r2, [r2, #4]	@ zero_extendqisi2
 642:Src/util.c    ****     // Update current limit
 2634              		.loc 1 642 6 view .LVU704
 2635 00f6 6AB1     		cbz	r2, .L171
 644:Src/util.c    ****     cur_spd_valid   = 1;  // Mark update to be saved in Flash at shutdown
 2636              		.loc 1 644 5 is_stmt 1 view .LVU705
 644:Src/util.c    ****     cur_spd_valid   = 1;  // Mark update to be saved in Flash at shutdown
 2637              		.loc 1 644 75 is_stmt 0 view .LVU706
 2638 00f8 40F2EE22 		movw	r2, #750
 2639 00fc 00FB02F2 		mul	r2, r0, r2
 644:Src/util.c    ****     cur_spd_valid   = 1;  // Mark update to be saved in Flash at shutdown
 2640              		.loc 1 644 41 view .LVU707
 2641 0100 1213     		asrs	r2, r2, #12
 644:Src/util.c    ****     cur_spd_valid   = 1;  // Mark update to be saved in Flash at shutdown
 2642              		.loc 1 644 39 view .LVU708
 2643 0102 1948     		ldr	r0, .L176+24
 2644              	.LVL175:
 644:Src/util.c    ****     cur_spd_valid   = 1;  // Mark update to be saved in Flash at shutdown
 2645              		.loc 1 644 39 view .LVU709
 2646 0104 A0F8CE20 		strh	r2, [r0, #206]	@ movhi
 644:Src/util.c    ****     cur_spd_valid   = 1;  // Mark update to be saved in Flash at shutdown
 2647              		.loc 1 644 20 view .LVU710
 2648 0108 1848     		ldr	r0, .L176+28
 2649 010a A0F8CE20 		strh	r2, [r0, #206]	@ movhi
 645:Src/util.c    ****   }
 2650              		.loc 1 645 5 is_stmt 1 view .LVU711
 645:Src/util.c    ****   }
 2651              		.loc 1 645 21 is_stmt 0 view .LVU712
 2652 010e 144A     		ldr	r2, .L176+16
 2653 0110 0120     		movs	r0, #1
 2654 0112 1070     		strb	r0, [r2]
 2655              	.L171:
 648:Src/util.c    ****     // Update speed limit
ARM GAS  /tmp/cchLDBog.s 			page 83


 2656              		.loc 1 648 3 is_stmt 1 view .LVU713
 648:Src/util.c    ****     // Update speed limit
 2657              		.loc 1 648 20 is_stmt 0 view .LVU714
 2658 0114 C3EBC303 		rsb	r3, r3, r3, lsl #3
 2659 0118 104A     		ldr	r2, .L176+12
 2660 011a 02EB4303 		add	r3, r2, r3, lsl #1
 2661 011e 1B79     		ldrb	r3, [r3, #4]	@ zero_extendqisi2
 648:Src/util.c    ****     // Update speed limit
 2662              		.loc 1 648 6 view .LVU715
 2663 0120 73B1     		cbz	r3, .L163
 650:Src/util.c    ****     cur_spd_valid  += 2;  // Mark update to be saved in Flash at shutdown
 2664              		.loc 1 650 5 is_stmt 1 view .LVU716
 650:Src/util.c    ****     cur_spd_valid  += 2;  // Mark update to be saved in Flash at shutdown
 2665              		.loc 1 650 62 is_stmt 0 view .LVU717
 2666 0122 4FF47A73 		mov	r3, #1000
 2667 0126 03FB01F2 		mul	r2, r3, r1
 650:Src/util.c    ****     cur_spd_valid  += 2;  // Mark update to be saved in Flash at shutdown
 2668              		.loc 1 650 41 view .LVU718
 2669 012a 1313     		asrs	r3, r2, #12
 650:Src/util.c    ****     cur_spd_valid  += 2;  // Mark update to be saved in Flash at shutdown
 2670              		.loc 1 650 39 view .LVU719
 2671 012c 0E4A     		ldr	r2, .L176+24
 2672 012e A2F8DA30 		strh	r3, [r2, #218]	@ movhi
 650:Src/util.c    ****     cur_spd_valid  += 2;  // Mark update to be saved in Flash at shutdown
 2673              		.loc 1 650 20 view .LVU720
 2674 0132 0E4A     		ldr	r2, .L176+28
 2675 0134 A2F8DA30 		strh	r3, [r2, #218]	@ movhi
 651:Src/util.c    ****   }
 2676              		.loc 1 651 5 is_stmt 1 view .LVU721
 651:Src/util.c    ****   }
 2677              		.loc 1 651 20 is_stmt 0 view .LVU722
 2678 0138 094A     		ldr	r2, .L176+16
 2679 013a 1378     		ldrb	r3, [r2]	@ zero_extendqisi2
 2680 013c 0233     		adds	r3, r3, #2
 2681 013e 1370     		strb	r3, [r2]
 2682              	.LVL176:
 2683              	.L163:
 661:Src/util.c    **** 
 2684              		.loc 1 661 1 view .LVU723
 2685 0140 03B0     		add	sp, sp, #12
 2686              	.LCFI24:
 2687              		.cfi_remember_state
 2688              		.cfi_def_cfa_offset 12
 2689              		@ sp needed
 2690 0142 30BD     		pop	{r4, r5, pc}
 2691              	.L173:
 2692              	.LCFI25:
 2693              		.cfi_restore_state
 639:Src/util.c    ****   spd_factor = CLAMP((input2_fixdt - (input2[inIdx].min << 16)) / (input2[inIdx].max - input2[inIdx
 2694              		.loc 1 639 14 discriminator 2 view .LVU724
 2695 0144 4FF6FF70 		movw	r0, #65535
 2696 0148 B7E7     		b	.L169
 2697              	.LVL177:
 2698              	.L174:
 640:Src/util.c    ****       
 2699              		.loc 1 640 14 discriminator 2 view .LVU725
 2700 014a 4FF6FF71 		movw	r1, #65535
ARM GAS  /tmp/cchLDBog.s 			page 84


 2701 014e CCE7     		b	.L170
 2702              	.L177:
 2703              		.align	2
 2704              	.L176:
 2705 0150 00000000 		.word	speedAvgAbs
 2706 0154 00000000 		.word	inIdx
 2707 0158 00000000 		.word	input1
 2708 015c 00000000 		.word	input2
 2709 0160 00000000 		.word	cur_spd_valid
 2710 0164 00080140 		.word	1073809408
 2711 0168 00000000 		.word	rtP_Right
 2712 016c 00000000 		.word	rtP_Left
 2713              		.cfi_endproc
 2714              	.LFE77:
 2716              		.section	.text.poweroffPressCheck,"ax",%progbits
 2717              		.align	1
 2718              		.global	poweroffPressCheck
 2719              		.syntax unified
 2720              		.thumb
 2721              		.thumb_func
 2723              	poweroffPressCheck:
 2724              	.LFB93:
1558:Src/util.c    ****   #if !defined(VARIANT_HOVERBOARD) && !defined(VARIANT_TRANSPOTTER)
 2725              		.loc 1 1558 31 is_stmt 1 view -0
 2726              		.cfi_startproc
 2727              		@ args = 0, pretend = 0, frame = 0
 2728              		@ frame_needed = 0, uses_anonymous_args = 0
 2729 0000 38B5     		push	{r3, r4, r5, lr}
 2730              	.LCFI26:
 2731              		.cfi_def_cfa_offset 16
 2732              		.cfi_offset 3, -16
 2733              		.cfi_offset 4, -12
 2734              		.cfi_offset 5, -8
 2735              		.cfi_offset 14, -4
1560:Src/util.c    ****       uint16_t cnt_press = 0;
 2736              		.loc 1 1560 5 view .LVU727
1560:Src/util.c    ****       uint16_t cnt_press = 0;
 2737              		.loc 1 1560 8 is_stmt 0 view .LVU728
 2738 0002 0221     		movs	r1, #2
 2739 0004 2448     		ldr	r0, .L192
 2740 0006 FFF7FEFF 		bl	HAL_GPIO_ReadPin
 2741              	.LVL178:
1560:Src/util.c    ****       uint16_t cnt_press = 0;
 2742              		.loc 1 1560 7 discriminator 1 view .LVU729
 2743 000a 90B9     		cbnz	r0, .L187
 2744              	.L178:
1618:Src/util.c    **** 
 2745              		.loc 1 1618 1 view .LVU730
 2746 000c 38BD     		pop	{r3, r4, r5, pc}
 2747              	.LVL179:
 2748              	.L181:
1558:Src/util.c    ****   #if !defined(VARIANT_HOVERBOARD) && !defined(VARIANT_TRANSPOTTER)
 2749              		.loc 1 1558 31 view .LVU731
 2750 000e 2546     		mov	r5, r4
 2751              	.LVL180:
 2752              	.L179:
 2753              	.LBB12:
ARM GAS  /tmp/cchLDBog.s 			page 85


1562:Src/util.c    ****         HAL_Delay(10);
 2754              		.loc 1 1562 13 is_stmt 1 view .LVU732
 2755 0010 0221     		movs	r1, #2
 2756 0012 2148     		ldr	r0, .L192
 2757 0014 FFF7FEFF 		bl	HAL_GPIO_ReadPin
 2758              	.LVL181:
1562:Src/util.c    ****         HAL_Delay(10);
 2759              		.loc 1 1562 13 is_stmt 0 discriminator 1 view .LVU733
 2760 0018 68B1     		cbz	r0, .L190
1563:Src/util.c    ****         if (cnt_press++ == 5 * 100) { beepShort(5); }
 2761              		.loc 1 1563 9 is_stmt 1 view .LVU734
 2762 001a 0A20     		movs	r0, #10
 2763 001c FFF7FEFF 		bl	HAL_Delay
 2764              	.LVL182:
1564:Src/util.c    ****       }
 2765              		.loc 1 1564 9 view .LVU735
1564:Src/util.c    ****       }
 2766              		.loc 1 1564 22 is_stmt 0 view .LVU736
 2767 0020 6C1C     		adds	r4, r5, #1
 2768 0022 A4B2     		uxth	r4, r4
 2769              	.LVL183:
1564:Src/util.c    ****       }
 2770              		.loc 1 1564 12 view .LVU737
 2771 0024 B5F5FA7F 		cmp	r5, #500
 2772 0028 F1D1     		bne	.L181
1564:Src/util.c    ****       }
 2773              		.loc 1 1564 39 is_stmt 1 discriminator 1 view .LVU738
 2774 002a 0520     		movs	r0, #5
 2775 002c FFF7FEFF 		bl	beepShort
 2776              	.LVL184:
 2777 0030 EDE7     		b	.L181
 2778              	.LVL185:
 2779              	.L187:
1561:Src/util.c    ****       while(HAL_GPIO_ReadPin(BUTTON_PORT, BUTTON_PIN)) {
 2780              		.loc 1 1561 16 is_stmt 0 view .LVU739
 2781 0032 0025     		movs	r5, #0
 2782 0034 ECE7     		b	.L179
 2783              	.LVL186:
 2784              	.L190:
1567:Src/util.c    **** 
 2785              		.loc 1 1567 7 is_stmt 1 view .LVU740
1567:Src/util.c    **** 
 2786              		.loc 1 1567 10 is_stmt 0 view .LVU741
 2787 0036 082D     		cmp	r5, #8
 2788 0038 05D9     		bls	.L183
1567:Src/util.c    **** 
 2789              		.loc 1 1567 26 is_stmt 1 discriminator 1 view .LVU742
1567:Src/util.c    **** 
 2790              		.loc 1 1567 33 is_stmt 0 discriminator 1 view .LVU743
 2791 003a 184B     		ldr	r3, .L192+4
 2792 003c 0022     		movs	r2, #0
 2793 003e 1A70     		strb	r2, [r3]
1569:Src/util.c    ****         HAL_Delay(1000);
 2794              		.loc 1 1569 7 is_stmt 1 view .LVU744
1569:Src/util.c    ****         HAL_Delay(1000);
 2795              		.loc 1 1569 10 is_stmt 0 view .LVU745
 2796 0040 B5F5FA7F 		cmp	r5, #500
ARM GAS  /tmp/cchLDBog.s 			page 86


 2797 0044 03D2     		bcs	.L191
 2798              	.L183:
1583:Src/util.c    ****         #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 2799              		.loc 1 1583 14 is_stmt 1 view .LVU746
1583:Src/util.c    ****         #if defined(DEBUG_SERIAL_USART2) || defined(DEBUG_SERIAL_USART3)
 2800              		.loc 1 1583 17 is_stmt 0 view .LVU747
 2801 0046 082D     		cmp	r5, #8
 2802 0048 E0D9     		bls	.L178
1587:Src/util.c    ****       }
 2803              		.loc 1 1587 7 is_stmt 1 view .LVU748
 2804 004a FFF7FEFF 		bl	poweroff
 2805              	.LVL187:
 2806              	.L191:
1570:Src/util.c    ****         if (HAL_GPIO_ReadPin(BUTTON_PORT, BUTTON_PIN)) {  // Double press: Adjust Max Current, Max 
 2807              		.loc 1 1570 9 view .LVU749
 2808 004e 4FF47A70 		mov	r0, #1000
 2809 0052 FFF7FEFF 		bl	HAL_Delay
 2810              	.LVL188:
1571:Src/util.c    ****           while(HAL_GPIO_ReadPin(BUTTON_PORT, BUTTON_PIN)) { HAL_Delay(10); }
 2811              		.loc 1 1571 9 view .LVU750
1571:Src/util.c    ****           while(HAL_GPIO_ReadPin(BUTTON_PORT, BUTTON_PIN)) { HAL_Delay(10); }
 2812              		.loc 1 1571 13 is_stmt 0 view .LVU751
 2813 0056 0221     		movs	r1, #2
 2814 0058 0F48     		ldr	r0, .L192
 2815 005a FFF7FEFF 		bl	HAL_GPIO_ReadPin
 2816              	.LVL189:
1571:Src/util.c    ****           while(HAL_GPIO_ReadPin(BUTTON_PORT, BUTTON_PIN)) { HAL_Delay(10); }
 2817              		.loc 1 1571 12 discriminator 1 view .LVU752
 2818 005e 58B9     		cbnz	r0, .L184
1578:Src/util.c    ****           adcCalibLim();
 2819              		.loc 1 1578 11 is_stmt 1 view .LVU753
 2820 0060 1020     		movs	r0, #16
 2821 0062 FFF7FEFF 		bl	beepLong
 2822              	.LVL190:
1579:Src/util.c    ****           beepShort(5);
 2823              		.loc 1 1579 11 view .LVU754
 2824 0066 FFF7FEFF 		bl	adcCalibLim
 2825              	.LVL191:
1580:Src/util.c    ****           #endif
 2826              		.loc 1 1580 11 view .LVU755
 2827 006a 0520     		movs	r0, #5
 2828 006c FFF7FEFF 		bl	beepShort
 2829              	.LVL192:
 2830 0070 CCE7     		b	.L178
 2831              	.L186:
1572:Src/util.c    ****           beepLong(8);
 2832              		.loc 1 1572 62 discriminator 2 view .LVU756
 2833 0072 0A20     		movs	r0, #10
 2834 0074 FFF7FEFF 		bl	HAL_Delay
 2835              	.LVL193:
 2836              	.L184:
1572:Src/util.c    ****           beepLong(8);
 2837              		.loc 1 1572 17 discriminator 1 view .LVU757
 2838 0078 0221     		movs	r1, #2
 2839 007a 0748     		ldr	r0, .L192
 2840 007c FFF7FEFF 		bl	HAL_GPIO_ReadPin
 2841              	.LVL194:
ARM GAS  /tmp/cchLDBog.s 			page 87


 2842 0080 0028     		cmp	r0, #0
 2843 0082 F6D1     		bne	.L186
1573:Src/util.c    ****           updateCurSpdLim();
 2844              		.loc 1 1573 11 view .LVU758
 2845 0084 0820     		movs	r0, #8
 2846 0086 FFF7FEFF 		bl	beepLong
 2847              	.LVL195:
1574:Src/util.c    ****           beepShort(5);
 2848              		.loc 1 1574 11 view .LVU759
 2849 008a FFF7FEFF 		bl	updateCurSpdLim
 2850              	.LVL196:
1575:Src/util.c    ****         } else {                                          // Long press: Calibrate ADC Limits
 2851              		.loc 1 1575 11 view .LVU760
 2852 008e 0520     		movs	r0, #5
 2853 0090 FFF7FEFF 		bl	beepShort
 2854              	.LVL197:
 2855 0094 BAE7     		b	.L178
 2856              	.L193:
 2857 0096 00BF     		.align	2
 2858              	.L192:
 2859 0098 00080140 		.word	1073809408
 2860 009c 00000000 		.word	enable
 2861              	.LBE12:
 2862              		.cfi_endproc
 2863              	.LFE93:
 2865              		.section	.text.rateLimiter16,"ax",%progbits
 2866              		.align	1
 2867              		.global	rateLimiter16
 2868              		.syntax unified
 2869              		.thumb
 2870              		.thumb_func
 2872              	rateLimiter16:
 2873              	.LVL198:
 2874              	.LFB95:
1644:Src/util.c    ****   // Old filter
1645:Src/util.c    ****   // Inputs:       u     = int16
1646:Src/util.c    ****   // Outputs:      y     = fixdt(1,32,20)
1647:Src/util.c    ****   // Parameters:   coef  = fixdt(0,16,16) = [0,65535U]
1648:Src/util.c    ****   // yint = (int16_t)(y >> 20); // the integer output is the fixed-point ouput shifted by 20 bits
1649:Src/util.c    ****   // void filtLowPass32(int16_t u, uint16_t coef, int32_t *y) {
1650:Src/util.c    ****   //   int32_t tmp;  
1651:Src/util.c    ****   //   tmp = (int16_t)(u << 4) - (*y >> 16);  
1652:Src/util.c    ****   //   tmp = CLAMP(tmp, -32768, 32767);  // Overflow protection  
1653:Src/util.c    ****   //   *y  = coef * tmp + (*y);
1654:Src/util.c    ****   // }
1655:Src/util.c    **** 
1656:Src/util.c    **** 
1657:Src/util.c    ****   /* rateLimiter16(int16_t u, int16_t rate, int16_t *y);
1658:Src/util.c    ****   * Inputs:       u     = int16
1659:Src/util.c    ****   * Outputs:      y     = fixdt(1,16,4)
1660:Src/util.c    ****   * Parameters:   rate  = fixdt(1,16,4) = [0, 32767] Do NOT make rate negative (>32767)
1661:Src/util.c    ****   */
1662:Src/util.c    **** void rateLimiter16(int16_t u, int16_t rate, int16_t *y) {
 2875              		.loc 1 1662 57 view -0
 2876              		.cfi_startproc
 2877              		@ args = 0, pretend = 0, frame = 0
 2878              		@ frame_needed = 0, uses_anonymous_args = 0
ARM GAS  /tmp/cchLDBog.s 			page 88


 2879              		@ link register save eliminated.
1663:Src/util.c    ****   int16_t q0;
 2880              		.loc 1 1663 3 view .LVU762
1664:Src/util.c    ****   int16_t q1;
 2881              		.loc 1 1664 3 view .LVU763
1665:Src/util.c    **** 
1666:Src/util.c    ****   q0 = (u << 4)  - *y;
 2882              		.loc 1 1666 3 view .LVU764
 2883              		.loc 1 1666 11 is_stmt 0 view .LVU765
 2884 0000 0301     		lsls	r3, r0, #4
 2885 0002 9BB2     		uxth	r3, r3
 2886              		.loc 1 1666 20 view .LVU766
 2887 0004 1088     		ldrh	r0, [r2]
 2888              	.LVL199:
 2889              		.loc 1 1666 18 view .LVU767
 2890 0006 1B1A     		subs	r3, r3, r0
 2891              		.loc 1 1666 6 view .LVU768
 2892 0008 1BB2     		sxth	r3, r3
 2893              	.LVL200:
1667:Src/util.c    **** 
1668:Src/util.c    ****   if (q0 > rate) {
 2894              		.loc 1 1668 3 is_stmt 1 view .LVU769
 2895              		.loc 1 1668 6 is_stmt 0 view .LVU770
 2896 000a 8B42     		cmp	r3, r1
 2897 000c 04DC     		bgt	.L195
1669:Src/util.c    ****     q0 = rate;
1670:Src/util.c    ****   } else {
1671:Src/util.c    ****     q1 = -rate;
 2898              		.loc 1 1671 5 is_stmt 1 view .LVU771
 2899              		.loc 1 1671 8 is_stmt 0 view .LVU772
 2900 000e 4942     		rsbs	r1, r1, #0
 2901              	.LVL201:
 2902              		.loc 1 1671 8 view .LVU773
 2903 0010 09B2     		sxth	r1, r1
 2904              	.LVL202:
1672:Src/util.c    ****     if (q0 < q1) {
 2905              		.loc 1 1672 5 is_stmt 1 view .LVU774
 2906              		.loc 1 1672 8 is_stmt 0 view .LVU775
 2907 0012 8B42     		cmp	r3, r1
 2908 0014 00DB     		blt	.L195
1666:Src/util.c    **** 
 2909              		.loc 1 1666 6 view .LVU776
 2910 0016 1946     		mov	r1, r3
 2911              	.LVL203:
 2912              	.L195:
1673:Src/util.c    ****       q0 = q1;
1674:Src/util.c    ****     }
1675:Src/util.c    ****   }
1676:Src/util.c    **** 
1677:Src/util.c    ****   *y = q0 + *y;
 2913              		.loc 1 1677 3 is_stmt 1 view .LVU777
 2914              		.loc 1 1677 11 is_stmt 0 view .LVU778
 2915 0018 0844     		add	r0, r0, r1
 2916              		.loc 1 1677 6 view .LVU779
 2917 001a 1080     		strh	r0, [r2]	@ movhi
1678:Src/util.c    **** }
 2918              		.loc 1 1678 1 view .LVU780
ARM GAS  /tmp/cchLDBog.s 			page 89


 2919 001c 7047     		bx	lr
 2920              		.cfi_endproc
 2921              	.LFE95:
 2923              		.section	.text.mixerFcn,"ax",%progbits
 2924              		.align	1
 2925              		.global	mixerFcn
 2926              		.syntax unified
 2927              		.thumb
 2928              		.thumb_func
 2930              	mixerFcn:
 2931              	.LVL204:
 2932              	.LFB96:
1679:Src/util.c    **** 
1680:Src/util.c    **** 
1681:Src/util.c    ****   /* mixerFcn(rtu_speed, rtu_steer, &rty_speedR, &rty_speedL); 
1682:Src/util.c    ****   * Inputs:       rtu_speed, rtu_steer                  = fixdt(1,16,4)
1683:Src/util.c    ****   * Outputs:      rty_speedR, rty_speedL                = int16_t
1684:Src/util.c    ****   * Parameters:   SPEED_COEFFICIENT, STEER_COEFFICIENT  = fixdt(0,16,14)
1685:Src/util.c    ****   */
1686:Src/util.c    **** void mixerFcn(int16_t rtu_speed, int16_t rtu_steer, int16_t *rty_speedR, int16_t *rty_speedL) {
 2933              		.loc 1 1686 95 is_stmt 1 view -0
 2934              		.cfi_startproc
 2935              		@ args = 0, pretend = 0, frame = 0
 2936              		@ frame_needed = 0, uses_anonymous_args = 0
 2937              		.loc 1 1686 95 is_stmt 0 view .LVU782
 2938 0000 10B5     		push	{r4, lr}
 2939              	.LCFI27:
 2940              		.cfi_def_cfa_offset 8
 2941              		.cfi_offset 4, -8
 2942              		.cfi_offset 14, -4
1687:Src/util.c    ****     int16_t prodSpeed;
 2943              		.loc 1 1687 5 is_stmt 1 view .LVU783
1688:Src/util.c    ****     int16_t prodSteer;
 2944              		.loc 1 1688 5 view .LVU784
1689:Src/util.c    ****     int32_t tmp;
 2945              		.loc 1 1689 5 view .LVU785
1690:Src/util.c    **** 
1691:Src/util.c    ****     prodSpeed   = (int16_t)((rtu_speed * (int16_t)SPEED_COEFFICIENT) >> 14);
 2946              		.loc 1 1691 5 view .LVU786
 2947              	.LVL205:
1692:Src/util.c    ****     prodSteer   = (int16_t)((rtu_steer * (int16_t)STEER_COEFFICIENT) >> 14);
 2948              		.loc 1 1692 5 view .LVU787
 2949              		.loc 1 1692 17 is_stmt 0 view .LVU788
 2950 0002 4FEA610E 		asr	lr, r1, #1
 2951              	.LVL206:
1693:Src/util.c    **** 
1694:Src/util.c    ****     tmp         = prodSpeed - prodSteer;  
 2952              		.loc 1 1694 5 is_stmt 1 view .LVU789
 2953              		.loc 1 1694 17 is_stmt 0 view .LVU790
 2954 0006 A0EB6101 		sub	r1, r0, r1, asr #1
 2955              	.LVL207:
1695:Src/util.c    ****     tmp         = CLAMP(tmp, -32768, 32767);  // Overflow protection
 2956              		.loc 1 1695 5 is_stmt 1 view .LVU791
 2957              		.loc 1 1695 19 is_stmt 0 view .LVU792
 2958 000a B1F5004F 		cmp	r1, #32768
 2959 000e 26DA     		bge	.L201
 2960              		.loc 1 1695 19 discriminator 1 view .LVU793
ARM GAS  /tmp/cchLDBog.s 			page 90


 2961 0010 174C     		ldr	r4, .L205
 2962 0012 A142     		cmp	r1, r4
 2963 0014 B8BF     		it	lt
 2964 0016 2146     		movlt	r1, r4
 2965              	.LVL208:
 2966              	.L197:
1696:Src/util.c    ****     *rty_speedR = (int16_t)(tmp >> 4);        // Convert from fixed-point to int 
 2967              		.loc 1 1696 5 is_stmt 1 view .LVU794
 2968              		.loc 1 1696 19 is_stmt 0 view .LVU795
 2969 0018 0911     		asrs	r1, r1, #4
 2970              	.LVL209:
 2971              		.loc 1 1696 17 view .LVU796
 2972 001a 1180     		strh	r1, [r2]	@ movhi
1697:Src/util.c    ****     *rty_speedR = CLAMP(*rty_speedR, INPUT_MIN, INPUT_MAX);
 2973              		.loc 1 1697 5 is_stmt 1 view .LVU797
 2974              		.loc 1 1697 19 is_stmt 0 view .LVU798
 2975 001c 154C     		ldr	r4, .L205+4
 2976 001e B4F900C0 		ldrsh	ip, [r4]
 2977              		.loc 1 1697 17 view .LVU799
 2978 0022 6145     		cmp	r1, ip
 2979 0024 1EDC     		bgt	.L202
 2980              		.loc 1 1697 19 discriminator 1 view .LVU800
 2981 0026 144C     		ldr	r4, .L205+8
 2982 0028 B4F90040 		ldrsh	r4, [r4]
 2983              		.loc 1 1697 17 discriminator 1 view .LVU801
 2984 002c A142     		cmp	r1, r4
 2985 002e B8BF     		it	lt
 2986 0030 2146     		movlt	r1, r4
 2987              	.L198:
 2988              		.loc 1 1697 17 discriminator 4 view .LVU802
 2989 0032 1180     		strh	r1, [r2]	@ movhi
1698:Src/util.c    **** 
1699:Src/util.c    ****     tmp         = prodSpeed + prodSteer;
 2990              		.loc 1 1699 5 is_stmt 1 view .LVU803
 2991              		.loc 1 1699 17 is_stmt 0 view .LVU804
 2992 0034 7044     		add	r0, r0, lr
 2993              	.LVL210:
1700:Src/util.c    ****     tmp         = CLAMP(tmp, -32768, 32767);  // Overflow protection
 2994              		.loc 1 1700 5 is_stmt 1 view .LVU805
 2995              		.loc 1 1700 19 is_stmt 0 view .LVU806
 2996 0036 B0F5004F 		cmp	r0, #32768
 2997 003a 15DA     		bge	.L203
 2998              		.loc 1 1700 19 discriminator 1 view .LVU807
 2999 003c 0C4A     		ldr	r2, .L205
 3000              	.LVL211:
 3001              		.loc 1 1700 19 discriminator 1 view .LVU808
 3002 003e 9042     		cmp	r0, r2
 3003 0040 B8BF     		it	lt
 3004 0042 1046     		movlt	r0, r2
 3005              	.LVL212:
 3006              	.L199:
1701:Src/util.c    ****     *rty_speedL = (int16_t)(tmp >> 4);        // Convert from fixed-point to int
 3007              		.loc 1 1701 5 is_stmt 1 view .LVU809
 3008              		.loc 1 1701 19 is_stmt 0 view .LVU810
 3009 0044 0211     		asrs	r2, r0, #4
 3010              		.loc 1 1701 17 view .LVU811
 3011 0046 1A80     		strh	r2, [r3]	@ movhi
ARM GAS  /tmp/cchLDBog.s 			page 91


1702:Src/util.c    ****     *rty_speedL = CLAMP(*rty_speedL, INPUT_MIN, INPUT_MAX);
 3012              		.loc 1 1702 5 is_stmt 1 view .LVU812
 3013              		.loc 1 1702 17 is_stmt 0 view .LVU813
 3014 0048 9445     		cmp	ip, r2
 3015 004a 05DB     		blt	.L200
 3016              		.loc 1 1702 19 discriminator 1 view .LVU814
 3017 004c 0A49     		ldr	r1, .L205+8
 3018 004e B1F900C0 		ldrsh	ip, [r1]
 3019              		.loc 1 1702 17 discriminator 1 view .LVU815
 3020 0052 9445     		cmp	ip, r2
 3021 0054 B8BF     		it	lt
 3022 0056 9446     		movlt	ip, r2
 3023              	.L200:
 3024              		.loc 1 1702 17 discriminator 4 view .LVU816
 3025 0058 A3F800C0 		strh	ip, [r3]	@ movhi
1703:Src/util.c    **** }
 3026              		.loc 1 1703 1 view .LVU817
 3027 005c 10BD     		pop	{r4, pc}
 3028              	.LVL213:
 3029              	.L201:
1695:Src/util.c    ****     *rty_speedR = (int16_t)(tmp >> 4);        // Convert from fixed-point to int 
 3030              		.loc 1 1695 19 discriminator 2 view .LVU818
 3031 005e 47F6FF71 		movw	r1, #32767
 3032              	.LVL214:
1695:Src/util.c    ****     *rty_speedR = (int16_t)(tmp >> 4);        // Convert from fixed-point to int 
 3033              		.loc 1 1695 19 discriminator 2 view .LVU819
 3034 0062 D9E7     		b	.L197
 3035              	.LVL215:
 3036              	.L202:
1697:Src/util.c    **** 
 3037              		.loc 1 1697 17 discriminator 2 view .LVU820
 3038 0064 6146     		mov	r1, ip
 3039 0066 E4E7     		b	.L198
 3040              	.LVL216:
 3041              	.L203:
1700:Src/util.c    ****     *rty_speedL = (int16_t)(tmp >> 4);        // Convert from fixed-point to int
 3042              		.loc 1 1700 19 discriminator 2 view .LVU821
 3043 0068 47F6FF70 		movw	r0, #32767
 3044              	.LVL217:
1700:Src/util.c    ****     *rty_speedL = (int16_t)(tmp >> 4);        // Convert from fixed-point to int
 3045              		.loc 1 1700 19 discriminator 2 view .LVU822
 3046 006c EAE7     		b	.L199
 3047              	.L206:
 3048 006e 00BF     		.align	2
 3049              	.L205:
 3050 0070 0080FFFF 		.word	-32768
 3051 0074 00000000 		.word	INPUT_MAX
 3052 0078 00000000 		.word	INPUT_MIN
 3053              		.cfi_endproc
 3054              	.LFE96:
 3056              		.section	.text.multipleTapDet,"ax",%progbits
 3057              		.align	1
 3058              		.global	multipleTapDet
 3059              		.syntax unified
 3060              		.thumb
 3061              		.thumb_func
 3063              	multipleTapDet:
ARM GAS  /tmp/cchLDBog.s 			page 92


 3064              	.LVL218:
 3065              	.LFB97:
1704:Src/util.c    **** 
1705:Src/util.c    **** 
1706:Src/util.c    **** 
1707:Src/util.c    **** /* =========================== Multiple Tap Function =========================== */
1708:Src/util.c    **** 
1709:Src/util.c    ****   /* multipleTapDet(int16_t u, uint32_t timeNow, MultipleTap *x)
1710:Src/util.c    ****   * This function detects multiple tap presses, such as double tapping, triple tapping, etc.
1711:Src/util.c    ****   * Inputs:       u = int16_t (input signal); timeNow = uint32_t (current time)  
1712:Src/util.c    ****   * Outputs:      x->b_multipleTap (get the output here)
1713:Src/util.c    ****   */
1714:Src/util.c    **** void multipleTapDet(int16_t u, uint32_t timeNow, MultipleTap *x) {
 3066              		.loc 1 1714 66 is_stmt 1 view -0
 3067              		.cfi_startproc
 3068              		@ args = 0, pretend = 0, frame = 0
 3069              		@ frame_needed = 0, uses_anonymous_args = 0
 3070              		@ link register save eliminated.
 3071              		.loc 1 1714 66 is_stmt 0 view .LVU824
 3072 0000 30B4     		push	{r4, r5}
 3073              	.LCFI28:
 3074              		.cfi_def_cfa_offset 8
 3075              		.cfi_offset 4, -8
 3076              		.cfi_offset 5, -4
1715:Src/util.c    ****   uint8_t 	b_timeout;
 3077              		.loc 1 1715 3 is_stmt 1 view .LVU825
1716:Src/util.c    ****   uint8_t 	b_hyst;
 3078              		.loc 1 1716 3 view .LVU826
1717:Src/util.c    ****   uint8_t 	b_pulse;
 3079              		.loc 1 1717 3 view .LVU827
1718:Src/util.c    ****   uint8_t 	z_pulseCnt;
 3080              		.loc 1 1718 3 view .LVU828
1719:Src/util.c    ****   uint8_t   z_pulseCntRst;
 3081              		.loc 1 1719 3 view .LVU829
1720:Src/util.c    ****   uint32_t 	t_time; 
 3082              		.loc 1 1720 3 view .LVU830
1721:Src/util.c    **** 
1722:Src/util.c    ****   // Detect hysteresis
1723:Src/util.c    ****   if (x->b_hysteresis) {
 3083              		.loc 1 1723 3 view .LVU831
 3084              		.loc 1 1723 8 is_stmt 0 view .LVU832
 3085 0002 5479     		ldrb	r4, [r2, #5]	@ zero_extendqisi2
 3086              		.loc 1 1723 6 view .LVU833
 3087 0004 E4B1     		cbz	r4, .L208
1724:Src/util.c    ****     b_hyst = (u > MULTIPLE_TAP_LO);
 3088              		.loc 1 1724 5 is_stmt 1 view .LVU834
 3089              		.loc 1 1724 17 is_stmt 0 view .LVU835
 3090 0006 C828     		cmp	r0, #200
 3091 0008 D4BF     		ite	le
 3092 000a 0020     		movle	r0, #0
 3093              	.LVL219:
 3094              		.loc 1 1724 17 view .LVU836
 3095 000c 0120     		movgt	r0, #1
 3096              	.LVL220:
 3097              	.L209:
1725:Src/util.c    ****   } else {
1726:Src/util.c    ****     b_hyst = (u > MULTIPLE_TAP_HI);
ARM GAS  /tmp/cchLDBog.s 			page 93


1727:Src/util.c    ****   }
1728:Src/util.c    **** 
1729:Src/util.c    ****   // Detect pulse
1730:Src/util.c    ****   b_pulse = (b_hyst != x->b_hysteresis);
 3098              		.loc 1 1730 3 is_stmt 1 view .LVU837
 3099              		.loc 1 1730 21 is_stmt 0 view .LVU838
 3100 000e 231A     		subs	r3, r4, r0
 3101 0010 18BF     		it	ne
 3102 0012 0123     		movne	r3, #1
 3103              	.LVL221:
1731:Src/util.c    **** 
1732:Src/util.c    ****   // Save time when first pulse is detected
1733:Src/util.c    ****   if (b_hyst && b_pulse && (x->z_pulseCntPrev == 0)) {
 3104              		.loc 1 1733 3 is_stmt 1 view .LVU839
 3105              		.loc 1 1733 6 is_stmt 0 view .LVU840
 3106 0014 18B1     		cbz	r0, .L210
 3107              		.loc 1 1733 14 discriminator 1 view .LVU841
 3108 0016 8442     		cmp	r4, r0
 3109 0018 01D0     		beq	.L210
 3110              		.loc 1 1733 30 discriminator 2 view .LVU842
 3111 001a 1479     		ldrb	r4, [r2, #4]	@ zero_extendqisi2
 3112              		.loc 1 1733 25 discriminator 2 view .LVU843
 3113 001c B4B1     		cbz	r4, .L215
 3114              	.L210:
1734:Src/util.c    ****     t_time = timeNow;
1735:Src/util.c    ****   } else {
1736:Src/util.c    ****     t_time = x->t_timePrev;
 3115              		.loc 1 1736 5 is_stmt 1 view .LVU844
 3116              		.loc 1 1736 12 is_stmt 0 view .LVU845
 3117 001e 1468     		ldr	r4, [r2]
 3118              	.LVL222:
 3119              	.L211:
1737:Src/util.c    ****   }
1738:Src/util.c    **** 
1739:Src/util.c    ****   // Create timeout boolean
1740:Src/util.c    ****   b_timeout = (timeNow - t_time > MULTIPLE_TAP_TIMEOUT);
 3120              		.loc 1 1740 3 is_stmt 1 view .LVU846
 3121              		.loc 1 1740 24 is_stmt 0 view .LVU847
 3122 0020 091B     		subs	r1, r1, r4
 3123              	.LVL223:
1741:Src/util.c    **** 
1742:Src/util.c    ****   // Create pulse counter
1743:Src/util.c    ****   if ((!b_hyst) && (x->z_pulseCntPrev == 0)) {
 3124              		.loc 1 1743 3 is_stmt 1 view .LVU848
 3125              		.loc 1 1743 6 is_stmt 0 view .LVU849
 3126 0022 10B9     		cbnz	r0, .L212
 3127              		.loc 1 1743 22 discriminator 1 view .LVU850
 3128 0024 1579     		ldrb	r5, [r2, #4]	@ zero_extendqisi2
 3129              		.loc 1 1743 17 discriminator 1 view .LVU851
 3130 0026 05B9     		cbnz	r5, .L212
1744:Src/util.c    ****     z_pulseCnt = 0U;
 3131              		.loc 1 1744 16 view .LVU852
 3132 0028 2B46     		mov	r3, r5
 3133              	.LVL224:
 3134              	.L212:
1745:Src/util.c    ****   } else {
1746:Src/util.c    ****     z_pulseCnt = b_pulse;
ARM GAS  /tmp/cchLDBog.s 			page 94


1747:Src/util.c    ****   }
1748:Src/util.c    **** 
1749:Src/util.c    ****   // Reset counter if we detected complete tap presses OR there is a timeout
1750:Src/util.c    ****   if ((x->z_pulseCntPrev >= MULTIPLE_TAP_NR) || b_timeout) {
 3135              		.loc 1 1750 3 is_stmt 1 view .LVU853
 3136              		.loc 1 1750 9 is_stmt 0 view .LVU854
 3137 002a 92F804C0 		ldrb	ip, [r2, #4]	@ zero_extendqisi2
 3138              		.loc 1 1750 6 view .LVU855
 3139 002e BCF1030F 		cmp	ip, #3
 3140 0032 0DD8     		bhi	.L217
 3141              		.loc 1 1750 46 discriminator 1 view .LVU856
 3142 0034 B1F5FA6F 		cmp	r1, #2000
 3143 0038 0CD9     		bls	.L213
1751:Src/util.c    ****     z_pulseCntRst = 0U;
 3144              		.loc 1 1751 19 view .LVU857
 3145 003a 4FF0000C 		mov	ip, #0
 3146 003e 09E0     		b	.L213
 3147              	.LVL225:
 3148              	.L208:
1726:Src/util.c    ****   }
 3149              		.loc 1 1726 5 is_stmt 1 view .LVU858
1726:Src/util.c    ****   }
 3150              		.loc 1 1726 17 is_stmt 0 view .LVU859
 3151 0040 B0F5167F 		cmp	r0, #600
 3152 0044 D4BF     		ite	le
 3153 0046 0020     		movle	r0, #0
 3154              	.LVL226:
1726:Src/util.c    ****   }
 3155              		.loc 1 1726 17 view .LVU860
 3156 0048 0120     		movgt	r0, #1
 3157              	.LVL227:
1726:Src/util.c    ****   }
 3158              		.loc 1 1726 17 view .LVU861
 3159 004a E0E7     		b	.L209
 3160              	.LVL228:
 3161              	.L215:
1734:Src/util.c    ****   } else {
 3162              		.loc 1 1734 12 view .LVU862
 3163 004c 0C46     		mov	r4, r1
 3164 004e E7E7     		b	.L211
 3165              	.LVL229:
 3166              	.L217:
 3167              		.loc 1 1751 19 view .LVU863
 3168 0050 4FF0000C 		mov	ip, #0
 3169              	.L213:
 3170              	.LVL230:
1752:Src/util.c    ****   } else {
1753:Src/util.c    ****     z_pulseCntRst = x->z_pulseCntPrev;
1754:Src/util.c    ****   }
1755:Src/util.c    ****   z_pulseCnt = z_pulseCnt + z_pulseCntRst;
 3171              		.loc 1 1755 3 is_stmt 1 view .LVU864
 3172              		.loc 1 1755 14 is_stmt 0 view .LVU865
 3173 0054 6344     		add	r3, r3, ip
 3174              	.LVL231:
 3175              		.loc 1 1755 14 view .LVU866
 3176 0056 DBB2     		uxtb	r3, r3
 3177              	.LVL232:
ARM GAS  /tmp/cchLDBog.s 			page 95


1756:Src/util.c    **** 
1757:Src/util.c    ****   // Check if complete tap presses are detected AND no timeout
1758:Src/util.c    ****   if ((z_pulseCnt >= MULTIPLE_TAP_NR) && (!b_timeout)) {
 3178              		.loc 1 1758 3 is_stmt 1 view .LVU867
 3179              		.loc 1 1758 6 is_stmt 0 view .LVU868
 3180 0058 032B     		cmp	r3, #3
 3181 005a 07D9     		bls	.L214
 3182              		.loc 1 1758 39 discriminator 1 view .LVU869
 3183 005c B1F5FA6F 		cmp	r1, #2000
 3184 0060 04D8     		bhi	.L214
1759:Src/util.c    ****     x->b_multipleTap = !x->b_multipleTap;	// Toggle output
 3185              		.loc 1 1759 5 is_stmt 1 view .LVU870
 3186              		.loc 1 1759 26 is_stmt 0 view .LVU871
 3187 0062 9179     		ldrb	r1, [r2, #6]	@ zero_extendqisi2
 3188              	.LVL233:
 3189              		.loc 1 1759 24 view .LVU872
 3190 0064 B1FA81F1 		clz	r1, r1
 3191 0068 4909     		lsrs	r1, r1, #5
 3192              		.loc 1 1759 22 view .LVU873
 3193 006a 9171     		strb	r1, [r2, #6]
 3194              	.L214:
1760:Src/util.c    ****   }
1761:Src/util.c    **** 
1762:Src/util.c    ****   // Update states
1763:Src/util.c    ****   x->z_pulseCntPrev = z_pulseCnt;
 3195              		.loc 1 1763 3 is_stmt 1 view .LVU874
 3196              		.loc 1 1763 21 is_stmt 0 view .LVU875
 3197 006c 1371     		strb	r3, [r2, #4]
1764:Src/util.c    ****   x->b_hysteresis 	= b_hyst;
 3198              		.loc 1 1764 3 is_stmt 1 view .LVU876
 3199              		.loc 1 1764 20 is_stmt 0 view .LVU877
 3200 006e 5071     		strb	r0, [r2, #5]
 3201              	.LVL234:
1765:Src/util.c    ****   x->t_timePrev 	  = t_time;
 3202              		.loc 1 1765 3 is_stmt 1 view .LVU878
 3203              		.loc 1 1765 20 is_stmt 0 view .LVU879
 3204 0070 1460     		str	r4, [r2]
1766:Src/util.c    **** }
 3205              		.loc 1 1766 1 view .LVU880
 3206 0072 30BC     		pop	{r4, r5}
 3207              	.LCFI29:
 3208              		.cfi_restore 5
 3209              		.cfi_restore 4
 3210              		.cfi_def_cfa_offset 0
 3211              	.LVL235:
 3212              		.loc 1 1766 1 view .LVU881
 3213 0074 7047     		bx	lr
 3214              		.cfi_endproc
 3215              	.LFE97:
 3217              		.section	.bss.old_pos.0,"aw",%nobits
 3218              		.align	2
 3221              	old_pos.0:
 3222 0000 00000000 		.space	4
 3223              		.section	.bss.commandR_raw,"aw",%nobits
 3224              		.align	2
 3227              	commandR_raw:
 3228 0000 00000000 		.space	8
ARM GAS  /tmp/cchLDBog.s 			page 96


 3228      00000000 
 3229              		.section	.bss.commandR,"aw",%nobits
 3230              		.align	2
 3233              	commandR:
 3234 0000 00000000 		.space	8
 3234      00000000 
 3235              		.section	.bss.timeoutFlgSerial_R,"aw",%nobits
 3238              	timeoutFlgSerial_R:
 3239 0000 00       		.space	1
 3240              		.section	.data.timeoutCntSerial_R,"aw"
 3241              		.align	1
 3244              	timeoutCntSerial_R:
 3245 0000 A000     		.short	160
 3246              		.section	.bss.rx_buffer_R,"aw",%nobits
 3247              		.align	2
 3250              	rx_buffer_R:
 3251 0000 00000000 		.space	64
 3251      00000000 
 3251      00000000 
 3251      00000000 
 3251      00000000 
 3252              		.section	.bss.inp_cal_valid,"aw",%nobits
 3255              	inp_cal_valid:
 3256 0000 00       		.space	1
 3257              		.section	.bss.cur_spd_valid,"aw",%nobits
 3260              	cur_spd_valid:
 3261 0000 00       		.space	1
 3262              		.section	.bss.INPUT_MIN,"aw",%nobits
 3263              		.align	1
 3266              	INPUT_MIN:
 3267 0000 0000     		.space	2
 3268              		.section	.bss.INPUT_MAX,"aw",%nobits
 3269              		.align	1
 3272              	INPUT_MAX:
 3273 0000 0000     		.space	2
 3274              		.global	VirtAddVarTab
 3275              		.section	.data.VirtAddVarTab,"aw"
 3276              		.align	2
 3279              	VirtAddVarTab:
 3280 0000 E803     		.short	1000
 3281 0002 E903     		.short	1001
 3282 0004 EA03     		.short	1002
 3283 0006 EB03     		.short	1003
 3284 0008 EC03     		.short	1004
 3285 000a ED03     		.short	1005
 3286 000c EE03     		.short	1006
 3287 000e EF03     		.short	1007
 3288 0010 F003     		.short	1008
 3289 0012 F103     		.short	1009
 3290 0014 F203     		.short	1010
 3291 0016 F303     		.short	1011
 3292 0018 F403     		.short	1012
 3293 001a F503     		.short	1013
 3294 001c F603     		.short	1014
 3295 001e F703     		.short	1015
 3296 0020 F803     		.short	1016
 3297 0022 F903     		.short	1017
ARM GAS  /tmp/cchLDBog.s 			page 97


 3298 0024 FA03     		.short	1018
 3299              		.global	ctrlModReq
 3300              		.section	.data.ctrlModReq,"aw"
 3303              	ctrlModReq:
 3304 0000 02       		.byte	2
 3305              		.global	ctrlModReqRaw
 3306              		.section	.data.ctrlModReqRaw,"aw"
 3309              	ctrlModReqRaw:
 3310 0000 02       		.byte	2
 3311              		.global	timeoutFlgSerial
 3312              		.section	.bss.timeoutFlgSerial,"aw",%nobits
 3315              	timeoutFlgSerial:
 3316 0000 00       		.space	1
 3317              		.global	timeoutFlgADC
 3318              		.section	.bss.timeoutFlgADC,"aw",%nobits
 3321              	timeoutFlgADC:
 3322 0000 00       		.space	1
 3323              		.global	speedAvgAbs
 3324              		.section	.bss.speedAvgAbs,"aw",%nobits
 3325              		.align	1
 3328              	speedAvgAbs:
 3329 0000 0000     		.space	2
 3330              		.global	speedAvg
 3331              		.section	.bss.speedAvg,"aw",%nobits
 3332              		.align	1
 3335              	speedAvg:
 3336 0000 0000     		.space	2
 3337              		.global	input2
 3338              		.section	.data.input2,"aw"
 3339              		.align	2
 3342              	input2:
 3343 0000 0000     		.short	0
 3344 0002 0000     		.short	0
 3345 0004 00       		.byte	0
 3346 0005 03       		.byte	3
 3347 0006 18FC     		.short	-1000
 3348 0008 0000     		.short	0
 3349 000a E803     		.short	1000
 3350 000c 0000     		.short	0
 3351              		.global	input1
 3352              		.section	.data.input1,"aw"
 3353              		.align	2
 3356              	input1:
 3357 0000 0000     		.short	0
 3358 0002 0000     		.short	0
 3359 0004 00       		.byte	0
 3360 0005 03       		.byte	3
 3361 0006 18FC     		.short	-1000
 3362 0008 0000     		.short	0
 3363 000a E803     		.short	1000
 3364 000c 0000     		.short	0
 3365              		.global	inIdx_prev
 3366              		.section	.bss.inIdx_prev,"aw",%nobits
 3369              	inIdx_prev:
 3370 0000 00       		.space	1
 3371              		.global	inIdx
 3372              		.section	.bss.inIdx,"aw",%nobits
ARM GAS  /tmp/cchLDBog.s 			page 98


 3375              	inIdx:
 3376 0000 00       		.space	1
 3377              		.global	rtY_Right
 3378              		.section	.bss.rtY_Right,"aw",%nobits
 3379              		.align	2
 3382              	rtY_Right:
 3383 0000 00000000 		.space	16
 3383      00000000 
 3383      00000000 
 3383      00000000 
 3384              		.global	rtU_Right
 3385              		.section	.bss.rtU_Right,"aw",%nobits
 3386              		.align	2
 3389              	rtU_Right:
 3390 0000 00000000 		.space	16
 3390      00000000 
 3390      00000000 
 3390      00000000 
 3391              		.global	rtDW_Right
 3392              		.section	.bss.rtDW_Right,"aw",%nobits
 3393              		.align	2
 3396              	rtDW_Right:
 3397 0000 00000000 		.space	172
 3397      00000000 
 3397      00000000 
 3397      00000000 
 3397      00000000 
 3398              		.global	rtP_Right
 3399              		.section	.bss.rtP_Right,"aw",%nobits
 3400              		.align	2
 3403              	rtP_Right:
 3404 0000 00000000 		.space	256
 3404      00000000 
 3404      00000000 
 3404      00000000 
 3404      00000000 
 3405              		.global	rtY_Left
 3406              		.section	.bss.rtY_Left,"aw",%nobits
 3407              		.align	2
 3410              	rtY_Left:
 3411 0000 00000000 		.space	16
 3411      00000000 
 3411      00000000 
 3411      00000000 
 3412              		.global	rtU_Left
 3413              		.section	.bss.rtU_Left,"aw",%nobits
 3414              		.align	2
 3417              	rtU_Left:
 3418 0000 00000000 		.space	16
 3418      00000000 
 3418      00000000 
 3418      00000000 
 3419              		.global	rtDW_Left
 3420              		.section	.bss.rtDW_Left,"aw",%nobits
 3421              		.align	2
 3424              	rtDW_Left:
 3425 0000 00000000 		.space	172
ARM GAS  /tmp/cchLDBog.s 			page 99


 3425      00000000 
 3425      00000000 
 3425      00000000 
 3425      00000000 
 3426              		.global	rtM_Right
 3427              		.section	.rodata.rtM_Right,"a"
 3428              		.align	2
 3431              	rtM_Right:
 3432 0000 00000000 		.word	rtM_Right_
 3433              		.global	rtM_Left
 3434              		.section	.rodata.rtM_Left,"a"
 3435              		.align	2
 3438              	rtM_Left:
 3439 0000 00000000 		.word	rtM_Left_
 3440              		.global	rtM_Right_
 3441              		.section	.bss.rtM_Right_,"aw",%nobits
 3442              		.align	2
 3445              	rtM_Right_:
 3446 0000 00000000 		.space	16
 3446      00000000 
 3446      00000000 
 3446      00000000 
 3447              		.global	rtM_Left_
 3448              		.section	.bss.rtM_Left_,"aw",%nobits
 3449              		.align	2
 3452              	rtM_Left_:
 3453 0000 00000000 		.space	16
 3453      00000000 
 3453      00000000 
 3453      00000000 
 3454              		.text
 3455              	.Letext0:
 3456              		.file 2 "/usr/lib/gcc/arm-none-eabi/13.2.1/include/stddef.h"
 3457              		.file 3 "/usr/lib/gcc/arm-none-eabi/13.2.1/include/stdint.h"
 3458              		.file 4 "Drivers/CMSIS/Device/ST/STM32F1xx/Include/stm32f103xe.h"
 3459              		.file 5 "Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_hal_def.h"
 3460              		.file 6 "Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_hal_gpio.h"
 3461              		.file 7 "Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_hal_dma.h"
 3462              		.file 8 "Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_hal_uart.h"
 3463              		.file 9 "Inc/util.h"
 3464              		.file 10 "Inc/rtwtypes.h"
 3465              		.file 11 "Inc/BLDC_controller.h"
 3466              		.file 12 "Inc/eeprom.h"
 3467              		.file 13 "/usr/include/newlib/string.h"
 3468              		.file 14 "Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_hal.h"
 3469              		.file 15 "/usr/include/newlib/stdio.h"
 3470              		.file 16 "Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_hal_flash.h"
 3471              		.file 17 "Inc/setup.h"
 3472              		.file 18 "<built-in>"
ARM GAS  /tmp/cchLDBog.s 			page 100


DEFINED SYMBOLS
                            *ABS*:00000000 util.c
     /tmp/cchLDBog.s:19     .text.BLDC_Init:00000000 $t
     /tmp/cchLDBog.s:25     .text.BLDC_Init:00000000 BLDC_Init
     /tmp/cchLDBog.s:134    .text.BLDC_Init:00000084 $d
     /tmp/cchLDBog.s:3403   .bss.rtP_Right:00000000 rtP_Right
     /tmp/cchLDBog.s:3452   .bss.rtM_Left_:00000000 rtM_Left_
     /tmp/cchLDBog.s:3424   .bss.rtDW_Left:00000000 rtDW_Left
     /tmp/cchLDBog.s:3417   .bss.rtU_Left:00000000 rtU_Left
     /tmp/cchLDBog.s:3410   .bss.rtY_Left:00000000 rtY_Left
     /tmp/cchLDBog.s:3445   .bss.rtM_Right_:00000000 rtM_Right_
     /tmp/cchLDBog.s:3396   .bss.rtDW_Right:00000000 rtDW_Right
     /tmp/cchLDBog.s:3389   .bss.rtU_Right:00000000 rtU_Right
     /tmp/cchLDBog.s:3382   .bss.rtY_Right:00000000 rtY_Right
     /tmp/cchLDBog.s:148    .text.Input_Lim_Init:00000000 $t
     /tmp/cchLDBog.s:154    .text.Input_Lim_Init:00000000 Input_Lim_Init
     /tmp/cchLDBog.s:200    .text.Input_Lim_Init:00000034 $d
     /tmp/cchLDBog.s:3272   .bss.INPUT_MAX:00000000 INPUT_MAX
     /tmp/cchLDBog.s:3266   .bss.INPUT_MIN:00000000 INPUT_MIN
     /tmp/cchLDBog.s:208    .text.UART_DisableRxErrors:00000000 $t
     /tmp/cchLDBog.s:214    .text.UART_DisableRxErrors:00000000 UART_DisableRxErrors
     /tmp/cchLDBog.s:238    .text.poweronMelody:00000000 $t
     /tmp/cchLDBog.s:244    .text.poweronMelody:00000000 poweronMelody
     /tmp/cchLDBog.s:298    .text.poweronMelody:00000024 $d
     /tmp/cchLDBog.s:304    .text.beepCount:00000000 $t
     /tmp/cchLDBog.s:310    .text.beepCount:00000000 beepCount
     /tmp/cchLDBog.s:335    .text.beepCount:00000010 $d
     /tmp/cchLDBog.s:342    .text.beepLong:00000000 $t
     /tmp/cchLDBog.s:348    .text.beepLong:00000000 beepLong
     /tmp/cchLDBog.s:386    .text.beepLong:00000018 $d
     /tmp/cchLDBog.s:392    .text.beepShort:00000000 $t
     /tmp/cchLDBog.s:398    .text.beepShort:00000000 beepShort
     /tmp/cchLDBog.s:436    .text.beepShort:00000018 $d
     /tmp/cchLDBog.s:442    .text.beepShortMany:00000000 $t
     /tmp/cchLDBog.s:448    .text.beepShortMany:00000000 beepShortMany
     /tmp/cchLDBog.s:529    .text.calcAvgSpeed:00000000 $t
     /tmp/cchLDBog.s:535    .text.calcAvgSpeed:00000000 calcAvgSpeed
     /tmp/cchLDBog.s:581    .text.calcAvgSpeed:00000030 $d
     /tmp/cchLDBog.s:3335   .bss.speedAvg:00000000 speedAvg
     /tmp/cchLDBog.s:3328   .bss.speedAvgAbs:00000000 speedAvgAbs
     /tmp/cchLDBog.s:589    .text.standstillHold:00000000 $t
     /tmp/cchLDBog.s:595    .text.standstillHold:00000000 standstillHold
     /tmp/cchLDBog.s:608    .text.electricBrake:00000000 $t
     /tmp/cchLDBog.s:614    .text.electricBrake:00000000 electricBrake
     /tmp/cchLDBog.s:628    .text.cruiseControl:00000000 $t
     /tmp/cchLDBog.s:634    .text.cruiseControl:00000000 cruiseControl
     /tmp/cchLDBog.s:648    .text.checkInputType:00000000 $t
     /tmp/cchLDBog.s:654    .text.checkInputType:00000000 checkInputType
     /tmp/cchLDBog.s:746    .text.checkInputType:00000058 $d
     /tmp/cchLDBog.s:751    .rodata.Input_Init.str1.4:00000000 $d
     /tmp/cchLDBog.s:756    .text.Input_Init:00000000 $t
     /tmp/cchLDBog.s:762    .text.Input_Init:00000000 Input_Init
     /tmp/cchLDBog.s:1126   .text.Input_Init:0000021c $d
     /tmp/cchLDBog.s:3250   .bss.rx_buffer_R:00000000 rx_buffer_R
     /tmp/cchLDBog.s:3279   .data.VirtAddVarTab:00000000 VirtAddVarTab
     /tmp/cchLDBog.s:3356   .data.input1:00000000 input1
     /tmp/cchLDBog.s:3342   .data.input2:00000000 input2
ARM GAS  /tmp/cchLDBog.s 			page 101


     /tmp/cchLDBog.s:1139   .text.calcInputCmd:00000000 $t
     /tmp/cchLDBog.s:1145   .text.calcInputCmd:00000000 calcInputCmd
     /tmp/cchLDBog.s:1286   .text.readInputRaw:00000000 $t
     /tmp/cchLDBog.s:1292   .text.readInputRaw:00000000 readInputRaw
     /tmp/cchLDBog.s:1328   .text.readInputRaw:00000028 $d
     /tmp/cchLDBog.s:3375   .bss.inIdx:00000000 inIdx
     /tmp/cchLDBog.s:3233   .bss.commandR:00000000 commandR
     /tmp/cchLDBog.s:1336   .text.handleTimeout:00000000 $t
     /tmp/cchLDBog.s:1342   .text.handleTimeout:00000000 handleTimeout
     /tmp/cchLDBog.s:1460   .text.handleTimeout:0000007c $d
     /tmp/cchLDBog.s:3244   .data.timeoutCntSerial_R:00000000 timeoutCntSerial_R
     /tmp/cchLDBog.s:3238   .bss.timeoutFlgSerial_R:00000000 timeoutFlgSerial_R
     /tmp/cchLDBog.s:3315   .bss.timeoutFlgSerial:00000000 timeoutFlgSerial
     /tmp/cchLDBog.s:3321   .bss.timeoutFlgADC:00000000 timeoutFlgADC
     /tmp/cchLDBog.s:3303   .data.ctrlModReq:00000000 ctrlModReq
     /tmp/cchLDBog.s:3369   .bss.inIdx_prev:00000000 inIdx_prev
     /tmp/cchLDBog.s:3309   .data.ctrlModReqRaw:00000000 ctrlModReqRaw
     /tmp/cchLDBog.s:1475   .text.readCommand:00000000 $t
     /tmp/cchLDBog.s:1481   .text.readCommand:00000000 readCommand
     /tmp/cchLDBog.s:1532   .text.readCommand:00000044 $d
     /tmp/cchLDBog.s:1541   .text.usart2_rx_check:00000000 $t
     /tmp/cchLDBog.s:1547   .text.usart2_rx_check:00000000 usart2_rx_check
     /tmp/cchLDBog.s:1560   .text.usart_process_command:00000000 $t
     /tmp/cchLDBog.s:1566   .text.usart_process_command:00000000 usart_process_command
     /tmp/cchLDBog.s:1640   .text.usart_process_command:00000048 $d
     /tmp/cchLDBog.s:1646   .text.usart3_rx_check:00000000 $t
     /tmp/cchLDBog.s:1652   .text.usart3_rx_check:00000000 usart3_rx_check
     /tmp/cchLDBog.s:1780   .text.usart3_rx_check:00000080 $d
     /tmp/cchLDBog.s:3221   .bss.old_pos.0:00000000 old_pos.0
     /tmp/cchLDBog.s:3227   .bss.commandR_raw:00000000 commandR_raw
     /tmp/cchLDBog.s:1789   .text.sideboardLeds:00000000 $t
     /tmp/cchLDBog.s:1795   .text.sideboardLeds:00000000 sideboardLeds
     /tmp/cchLDBog.s:1809   .text.sideboardSensors:00000000 $t
     /tmp/cchLDBog.s:1815   .text.sideboardSensors:00000000 sideboardSensors
     /tmp/cchLDBog.s:1829   .text.saveConfig:00000000 $t
     /tmp/cchLDBog.s:1835   .text.saveConfig:00000000 saveConfig
     /tmp/cchLDBog.s:2006   .text.saveConfig:000000e4 $d
     /tmp/cchLDBog.s:3255   .bss.inp_cal_valid:00000000 inp_cal_valid
     /tmp/cchLDBog.s:3260   .bss.cur_spd_valid:00000000 cur_spd_valid
     /tmp/cchLDBog.s:2017   .text.poweroff:00000000 $t
     /tmp/cchLDBog.s:2023   .text.poweroff:00000000 poweroff
     /tmp/cchLDBog.s:2088   .text.poweroff:00000034 $d
     /tmp/cchLDBog.s:2097   .text.filtLowPass32:00000000 $t
     /tmp/cchLDBog.s:2103   .text.filtLowPass32:00000000 filtLowPass32
     /tmp/cchLDBog.s:2172   .text.adcCalibLim:00000000 $t
     /tmp/cchLDBog.s:2178   .text.adcCalibLim:00000000 adcCalibLim
     /tmp/cchLDBog.s:2454   .text.adcCalibLim:00000150 $d
     /tmp/cchLDBog.s:2465   .text.updateCurSpdLim:00000000 $t
     /tmp/cchLDBog.s:2471   .text.updateCurSpdLim:00000000 updateCurSpdLim
     /tmp/cchLDBog.s:2705   .text.updateCurSpdLim:00000150 $d
     /tmp/cchLDBog.s:2717   .text.poweroffPressCheck:00000000 $t
     /tmp/cchLDBog.s:2723   .text.poweroffPressCheck:00000000 poweroffPressCheck
     /tmp/cchLDBog.s:2859   .text.poweroffPressCheck:00000098 $d
     /tmp/cchLDBog.s:2866   .text.rateLimiter16:00000000 $t
     /tmp/cchLDBog.s:2872   .text.rateLimiter16:00000000 rateLimiter16
     /tmp/cchLDBog.s:2924   .text.mixerFcn:00000000 $t
     /tmp/cchLDBog.s:2930   .text.mixerFcn:00000000 mixerFcn
ARM GAS  /tmp/cchLDBog.s 			page 102


     /tmp/cchLDBog.s:3050   .text.mixerFcn:00000070 $d
     /tmp/cchLDBog.s:3057   .text.multipleTapDet:00000000 $t
     /tmp/cchLDBog.s:3063   .text.multipleTapDet:00000000 multipleTapDet
     /tmp/cchLDBog.s:3218   .bss.old_pos.0:00000000 $d
     /tmp/cchLDBog.s:3224   .bss.commandR_raw:00000000 $d
     /tmp/cchLDBog.s:3230   .bss.commandR:00000000 $d
     /tmp/cchLDBog.s:3239   .bss.timeoutFlgSerial_R:00000000 $d
     /tmp/cchLDBog.s:3241   .data.timeoutCntSerial_R:00000000 $d
     /tmp/cchLDBog.s:3247   .bss.rx_buffer_R:00000000 $d
     /tmp/cchLDBog.s:3256   .bss.inp_cal_valid:00000000 $d
     /tmp/cchLDBog.s:3261   .bss.cur_spd_valid:00000000 $d
     /tmp/cchLDBog.s:3263   .bss.INPUT_MIN:00000000 $d
     /tmp/cchLDBog.s:3269   .bss.INPUT_MAX:00000000 $d
     /tmp/cchLDBog.s:3276   .data.VirtAddVarTab:00000000 $d
     /tmp/cchLDBog.s:3316   .bss.timeoutFlgSerial:00000000 $d
     /tmp/cchLDBog.s:3322   .bss.timeoutFlgADC:00000000 $d
     /tmp/cchLDBog.s:3325   .bss.speedAvgAbs:00000000 $d
     /tmp/cchLDBog.s:3332   .bss.speedAvg:00000000 $d
     /tmp/cchLDBog.s:3339   .data.input2:00000000 $d
     /tmp/cchLDBog.s:3353   .data.input1:00000000 $d
     /tmp/cchLDBog.s:3370   .bss.inIdx_prev:00000000 $d
     /tmp/cchLDBog.s:3376   .bss.inIdx:00000000 $d
     /tmp/cchLDBog.s:3379   .bss.rtY_Right:00000000 $d
     /tmp/cchLDBog.s:3386   .bss.rtU_Right:00000000 $d
     /tmp/cchLDBog.s:3393   .bss.rtDW_Right:00000000 $d
     /tmp/cchLDBog.s:3400   .bss.rtP_Right:00000000 $d
     /tmp/cchLDBog.s:3407   .bss.rtY_Left:00000000 $d
     /tmp/cchLDBog.s:3414   .bss.rtU_Left:00000000 $d
     /tmp/cchLDBog.s:3421   .bss.rtDW_Left:00000000 $d
     /tmp/cchLDBog.s:3431   .rodata.rtM_Right:00000000 rtM_Right
     /tmp/cchLDBog.s:3428   .rodata.rtM_Right:00000000 $d
     /tmp/cchLDBog.s:3438   .rodata.rtM_Left:00000000 rtM_Left
     /tmp/cchLDBog.s:3435   .rodata.rtM_Left:00000000 $d
     /tmp/cchLDBog.s:3442   .bss.rtM_Right_:00000000 $d
     /tmp/cchLDBog.s:3449   .bss.rtM_Left_:00000000 $d

UNDEFINED SYMBOLS
memcpy
BLDC_controller_initialize
rtP_Left
HAL_Delay
buzzerCount
buzzerFreq
buzzerPattern
UART3_Init
HAL_UART_Receive_DMA
HAL_FLASH_Unlock
EE_Init
EE_ReadVariable
printf
HAL_FLASH_Lock
huart3
timeoutFlgGen
EE_WriteVariable
HAL_GPIO_WritePin
enable
HAL_GPIO_ReadPin
ARM GAS  /tmp/cchLDBog.s 			page 103


